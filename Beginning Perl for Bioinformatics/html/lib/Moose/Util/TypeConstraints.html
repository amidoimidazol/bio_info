<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Important-Caveat">Important Caveat</a></li>
      <li><a href="#Slightly-Less-Important-Caveat">Slightly Less Important Caveat</a></li>
      <li><a href="#Default-Type-Constraints">Default Type Constraints</a></li>
      <li><a href="#Type-Constraint-Naming">Type Constraint Naming</a></li>
      <li><a href="#Use-with-Other-Constraint-Modules">Use with Other Constraint Modules</a></li>
      <li><a href="#Error-messages">Error messages</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#Type-Constraint-Constructors">Type Constraint Constructors</a></li>
      <li><a href="#Type-Constraint-Utilities">Type Constraint Utilities</a></li>
      <li><a href="#Type-Coercion-Constructors">Type Coercion Constructors</a></li>
      <li><a href="#Creating-and-Finding-Type-Constraints">Creating and Finding Type Constraints</a></li>
    </ul>
  </li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Moose::Util::TypeConstraints - Type constraint system for Moose</p>

<h1 id="VERSION">VERSION</h1>

<p>version 2.0604</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">Moose::Util::TypeConstraints</span><span class="operator">;</span>
  
  <span class="variable">subtype</span> <span class="string">'Natural'</span><span class="operator">,</span>
      <span class="variable">as</span> <span class="string">'Int'</span><span class="operator">,</span>
      <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">};</span>
  
  <span class="variable">subtype</span> <span class="string">'NaturalLessThanTen'</span><span class="operator">,</span>
      <span class="variable">as</span> <span class="string">'Natural'</span><span class="operator">,</span>
      <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">&lt;</span> <span class="number">10</span> <span class="operator">},</span>
      <span class="variable">message</span> <span class="operator">{</span> <span class="string">"This number (</span><span class="variable">$_</span><span class="string">) is not less than ten!"</span> <span class="operator">};</span>
  
  <span class="variable">coerce</span> <span class="string">'Num'</span><span class="operator">,</span>
      <span class="variable">from</span> <span class="string">'Str'</span><span class="operator">,</span>
      <span class="variable">via</span> <span class="operator">{</span> <span class="number">0</span><span class="operator">+</span><span class="variable">$_</span> <span class="operator">};</span>
  
  <span class="variable">class_type</span> <span class="string">'DateTimeClass'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">class</span> <span class="operator">=&gt;</span> <span class="string">'DateTime'</span> <span class="operator">}</span><span class="operator">;</span>
  
  <span class="variable">role_type</span> <span class="string">'Barks'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">role</span> <span class="operator">=&gt;</span> <span class="string">'Some::Library::Role::Barks'</span> <span class="operator">}</span><span class="operator">;</span>
  
  <span class="variable">enum</span> <span class="string">'RGBColors'</span><span class="operator">,</span> <span class="operator">[</span><span class="string">qw(red green blue)</span><span class="operator">]</span><span class="operator">;</span>
  
  <span class="variable">union</span> <span class="string">'StringOrArray'</span><span class="operator">,</span> <span class="operator">[</span><span class="string">qw( String Array )</span><span class="operator">]</span><span class="operator">;</span>
  
  <span class="keyword">no</span> <span class="variable">Moose::Util::TypeConstraints</span><span class="operator">;</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides Moose with the ability to create custom type constraints to be used in attribute definition.</p>

<h2 id="Important-Caveat">Important Caveat</h2>

<p>This is <b>NOT</b> a type system for Perl 5. These are type constraints, and they are not used by Moose unless you tell it to. No type inference is performed, expressions are not typed, etc. etc. etc.</p>

<p>A type constraint is at heart a small &quot;check if a value is valid&quot; function. A constraint can be associated with an attribute. This simplifies parameter validation, and makes your code clearer to read, because you can refer to constraints by name.</p>

<h2 id="Slightly-Less-Important-Caveat">Slightly Less Important Caveat</h2>

<p>It is <b>always</b> a good idea to quote your type names.</p>

<p>This prevents Perl from trying to execute the call as an indirect object call. This can be an issue when you have a subtype with the same name as a valid class.</p>

<p>For instance:</p>

<pre><code><code>  <span class="variable">subtype</span> <span class="string">DateTime</span> <span class="operator">=&gt;</span> <span class="variable">as</span> <span class="string">Object</span> <span class="operator">=&gt;</span> <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">isa</span><span class="operator">(</span><span class="string">'DateTime'</span><span class="operator">)</span> <span class="operator">};</span>
</code></code></pre>

<p>will <i>just work</i>, while this:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DateTime</span><span class="operator">;</span>
  <span class="variable">subtype</span> <span class="string">DateTime</span> <span class="operator">=&gt;</span> <span class="variable">as</span> <span class="string">Object</span> <span class="operator">=&gt;</span> <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">isa</span><span class="operator">(</span><span class="string">'DateTime'</span><span class="operator">)</span> <span class="operator">};</span>
</code></code></pre>

<p>will fail silently and cause many headaches. The simple way to solve this, as well as future proof your subtypes from classes which have yet to have been created, is to quote the type name:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DateTime</span><span class="operator">;</span>
  <span class="variable">subtype</span> <span class="string">'DateTime'</span><span class="operator">,</span> <span class="variable">as</span> <span class="string">'Object'</span><span class="operator">,</span> <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">isa</span><span class="operator">(</span><span class="string">'DateTime'</span><span class="operator">)</span> <span class="operator">};</span>
</code></code></pre>

<h2 id="Default-Type-Constraints">Default Type Constraints</h2>

<p>This module also provides a simple hierarchy for Perl 5 types, here is that hierarchy represented visually.</p>

<pre><code><code>  Any
  Item
      Bool
      Maybe[`a]
      Undef
      Defined
          Value
              Str
                  Num
                      Int
                  ClassName
                  RoleName
          Ref
              ScalarRef[`a]
              ArrayRef[`a]
              HashRef[`a]
              CodeRef
              RegexpRef
              GlobRef
              FileHandle
              Object</code></code></pre>

<p><b>NOTE:</b> Any type followed by a type parameter <code><code>[`a]</code></code> can be parameterized, this means you can say:</p>

<pre><code><code>  ArrayRef[Int]    # an array of integers
  HashRef[CodeRef] # a hash of str to CODE ref mappings
  ScalarRef[Int]   # a reference to an integer
  Maybe[Str]       # value may be a string, may be undefined</code></code></pre>

<p>If Moose finds a name in brackets that it does not recognize as an existing type, it assumes that this is a class name, for example <code><code>ArrayRef[DateTime]</code></code>.</p>

<p><b>NOTE:</b> Unless you parameterize a type, then it is invalid to include the square brackets. I.e. <code><code>ArrayRef[]</code></code> will be treated as a new type name, <i>not</i> as a parameterization of <code><code>ArrayRef</code></code>.</p>

<p><b>NOTE:</b> The <code><code>Undef</code></code> type constraint for the most part works correctly now, but edge cases may still exist, please use it sparingly.</p>

<p><b>NOTE:</b> The <code><code>ClassName</code></code> type constraint does a complex package existence check. This means that your class <b>must</b> be loaded for this type constraint to pass.</p>

<p><b>NOTE:</b> The <code><code>RoleName</code></code> constraint checks a string is a <i>package name</i> which is a role, like <code><code>&#39;MyApp::Role::Comparable&#39;</code></code>.</p>

<h2 id="Type-Constraint-Naming">Type Constraint Naming</h2>

<p>Type name declared via this module can only contain alphanumeric characters, colons (:), and periods (.).</p>

<p>Since the types created by this module are global, it is suggested that you namespace your types just as you would namespace your modules. So instead of creating a <i>Color</i> type for your <b>My::Graphics</b> module, you would call the type <i>My::Graphics::Types::Color</i> instead.</p>

<h2 id="Use-with-Other-Constraint-Modules">Use with Other Constraint Modules</h2>

<p>This module can play nicely with other constraint modules with some slight tweaking. The <code><code>where</code></code> clause in types is expected to be a <code><code>CODE</code></code> reference which checks its first argument and returns a boolean. Since most constraint modules work in a similar way, it should be simple to adapt them to work with Moose.</p>

<p>For instance, this is how you could use it with <a>Declare::Constraints::Simple</a> to declare a completely new type.</p>

<pre><code><code>  <span class="variable">type</span> <span class="string">'HashOfArrayOfObjects'</span><span class="operator">,</span>
      <span class="variable">where</span> <span class="operator">{</span>
          <span class="variable">IsHashRef</span><span class="operator">(</span>
              <span class="string">-keys</span>   <span class="operator">=&gt;</span> <span class="variable">HasLength</span><span class="operator">,</span>
              <span class="string">-values</span> <span class="operator">=&gt;</span> <span class="variable">IsArrayRef</span><span class="operator">(</span><span class="variable">IsObject</span><span class="operator">)</span>
          <span class="operator">)-&gt;(</span><span class="variable">@_</span><span class="operator">);</span>
      <span class="operator">};</span>
</code></code></pre>

<p>For more examples see the <i>t/examples/example_w_DCS.t</i> test file.</p>

<p>Here is an example of using <a>Test::Deep</a> and its non-test related <code><code>eq_deeply</code></code> function.</p>

<pre><code><code>  <span class="variable">type</span> <span class="string">'ArrayOfHashOfBarsAndRandomNumbers'</span><span class="operator">,</span>
      <span class="variable">where</span> <span class="operator">{</span>
          <span class="variable">eq_deeply</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span>
              <span class="variable">array_each</span><span class="operator">(</span><span class="variable">subhashof</span><span class="operator">(</span><span class="operator">{</span>
                  <span class="string">bar</span>           <span class="operator">=&gt;</span> <span class="variable">isa</span><span class="operator">(</span><span class="string">'Bar'</span><span class="operator">),</span>
                  <span class="string">random_number</span> <span class="operator">=&gt;</span> <span class="variable">ignore</span><span class="operator">()</span>
              <span class="operator">}</span><span class="operator">)))</span>
        <span class="operator">};</span>
</code></code></pre>

<p>For a complete example see the <i>t/examples/example_w_TestDeep.t</i> test file.</p>

<h2 id="Error-messages">Error messages</h2>

<p>Type constraints can also specify custom error messages, for when they fail to validate. This is provided as just another coderef, which receives the invalid value in <code><code>$_</code></code>, as in:</p>

<pre><code><code>  <span class="variable">subtype</span> <span class="string">'PositiveInt'</span><span class="operator">,</span>
       <span class="variable">as</span> <span class="string">'Int'</span><span class="operator">,</span>
       <span class="variable">where</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">},</span>
       <span class="variable">message</span> <span class="operator">{</span> <span class="string">"</span><span class="variable">$_</span><span class="string"> is not a positive integer!"</span> <span class="operator">};</span>
</code></code></pre>

<p>If no message is specified, a default message will be used, which indicates which type constraint was being used and what value failed. If <a>Devel::PartialDump</a> (version 0.14 or higher) is installed, it will be used to display the invalid value, otherwise it will just be printed as is.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="Type-Constraint-Constructors">Type Constraint Constructors</h2>

<p>The following functions are used to create type constraints. They will also register the type constraints your create in a global registry that is used to look types up by name.</p>

<p>See the <a href="#SYNOPSIS">&quot;SYNOPSIS&quot;</a> for an example of how to use these.</p>

<dl>

<dt id="subtype-Name-as-Parent-where-..."><b>subtype &#39;Name&#39;, as &#39;Parent&#39;, where { } ...</b></dt>
<dd>

<p>This creates a named subtype.</p>

<p>If you provide a parent that Moose does not recognize, it will automatically create a new class type constraint for this name.</p>

<p>When creating a named type, the <code><code>subtype</code></code> function should either be called with the sugar helpers (<code><code>where</code></code>, <code><code>message</code></code>, etc), or with a name and a hashref of parameters:</p>

<pre><code><code> <span class="variable">subtype</span><span class="operator">(</span> <span class="string">'Foo'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">where</span> <span class="operator">=&gt;</span> <span class="operator">...,</span> <span class="string">message</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">}</span> <span class="operator">);</span>
</code></code></pre>

<p>The valid hashref keys are <code><code>as</code></code> (the parent), <code><code>where</code></code>, <code><code>message</code></code>, and <code><code>optimize_as</code></code>.</p>

</dd>
<dt id="subtype-as-Parent-where-..."><b>subtype as &#39;Parent&#39;, where { } ...</b></dt>
<dd>

<p>This creates an unnamed subtype and will return the type constraint meta-object, which will be an instance of <a href="../../../lib/Moose/Meta/TypeConstraint.html">Moose::Meta::TypeConstraint</a>.</p>

<p>When creating an anonymous type, the <code><code>subtype</code></code> function should either be called with the sugar helpers (<code><code>where</code></code>, <code><code>message</code></code>, etc), or with just a hashref of parameters:</p>

<pre><code><code> <span class="variable">subtype</span><span class="operator">(</span> <span class="operator">{</span> <span class="string">where</span> <span class="operator">=&gt;</span> <span class="operator">...,</span> <span class="string">message</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">}</span> <span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="class_type-class-options-"><b>class_type ($class, ?$options)</b></dt>
<dd>

<p>Creates a new subtype of <code><code>Object</code></code> with the name <code><code>$class</code></code> and the metaclass <a href="../../../lib/Moose/Meta/TypeConstraint/Class.html">Moose::Meta::TypeConstraint::Class</a>.</p>

<pre><code><code>  <span class="comment"># Create a type called 'Box' which tests for objects which -&gt;isa('Box')</span>
  <span class="variable">class_type</span> <span class="string">'Box'</span><span class="operator">;</span>
</code></code></pre>

<p>By default, the name of the type and the name of the class are the same, but you can specify both separately.</p>

<pre><code><code>  <span class="comment"># Create a type called 'Box' which tests for objects which -&gt;isa('ObjectLibrary::Box');</span>
  <span class="variable">class_type</span> <span class="string">'Box'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">class</span> <span class="operator">=&gt;</span> <span class="string">'ObjectLibrary::Box'</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="role_type-role-options-"><b>role_type ($role, ?$options)</b></dt>
<dd>

<p>Creates a <code><code>Role</code></code> type constraint with the name <code><code>$role</code></code> and the metaclass <a href="../../../lib/Moose/Meta/TypeConstraint/Role.html">Moose::Meta::TypeConstraint::Role</a>.</p>

<pre><code><code>  <span class="comment"># Create a type called 'Walks' which tests for objects which -&gt;does('Walks')</span>
  <span class="variable">role_type</span> <span class="string">'Walks'</span><span class="operator">;</span>
</code></code></pre>

<p>By default, the name of the type and the name of the role are the same, but you can specify both separately.</p>

<pre><code><code>  <span class="comment"># Create a type called 'Walks' which tests for objects which -&gt;does('MooseX::Role::Walks');</span>
  <span class="variable">role_type</span> <span class="string">'Walks'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">role</span> <span class="operator">=&gt;</span> <span class="string">'MooseX::Role::Walks'</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="maybe_type-type-"><b>maybe_type ($type)</b></dt>
<dd>

<p>Creates a type constraint for either <code><code>undef</code></code> or something of the given type.</p>

</dd>
<dt id="duck_type-name-methods-"><b>duck_type ($name, \@methods)</b></dt>
<dd>

<p>This will create a subtype of Object and test to make sure the value <code><code>can()</code></code> do the methods in <code><code>\@methods</code></code>.</p>

<p>This is intended as an easy way to accept non-Moose objects that provide a certain interface. If you&#39;re using Moose classes, we recommend that you use a <code><code>requires</code></code>-only Role instead.</p>

</dd>
<dt id="duck_type-methods-"><b>duck_type (\@methods)</b></dt>
<dd>

<p>If passed an ARRAY reference as the only parameter instead of the <code><code>$name</code></code>, <code><code>\@methods</code></code> pair, this will create an unnamed duck type. This can be used in an attribute definition like so:</p>

<pre><code><code>  <span class="variable">has</span> <span class="string">'cache'</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
      <span class="string">is</span>  <span class="operator">=&gt;</span> <span class="string">'ro'</span><span class="operator">,</span>
      <span class="string">isa</span> <span class="operator">=&gt;</span> <span class="variable">duck_type</span><span class="operator">(</span> <span class="operator">[</span><span class="string">qw( get_set )</span><span class="operator">]</span> <span class="operator">),</span>
  <span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="enum-name-values-"><b>enum ($name, \@values)</b></dt>
<dd>

<p>This will create a basic subtype for a given set of strings. The resulting constraint will be a subtype of <code><code>Str</code></code> and will match any of the items in <code><code>\@values</code></code>. It is case sensitive. See the <a href="#SYNOPSIS">&quot;SYNOPSIS&quot;</a> for a simple example.</p>

<p><b>NOTE:</b> This is not a true proper enum type, it is simply a convenient constraint builder.</p>

</dd>
<dt id="enum-values-"><b>enum (\@values)</b></dt>
<dd>

<p>If passed an ARRAY reference as the only parameter instead of the <code><code>$name</code></code>, <code><code>\@values</code></code> pair, this will create an unnamed enum. This can then be used in an attribute definition like so:</p>

<pre><code><code>  <span class="variable">has</span> <span class="string">'sort_order'</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
      <span class="string">is</span>  <span class="operator">=&gt;</span> <span class="string">'ro'</span><span class="operator">,</span>
      <span class="string">isa</span> <span class="operator">=&gt;</span> <span class="variable">enum</span><span class="operator">(</span><span class="operator">[</span><span class="string">qw[ ascending descending ]</span><span class="operator">]</span><span class="operator">),</span>
  <span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="union-name-constraints-"><b>union ($name, \@constraints)</b></dt>
<dd>

<p>This will create a basic subtype where any of the provided constraints may match in order to satisfy this constraint.</p>

</dd>
<dt id="union-constraints-"><b>union (\@constraints)</b></dt>
<dd>

<p>If passed an ARRAY reference as the only parameter instead of the <code><code>$name</code></code>, <code><code>\@constraints</code></code> pair, this will create an unnamed union. This can then be used in an attribute definition like so:</p>

<pre><code><code>  <span class="variable">has</span> <span class="string">'items'</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
      <span class="string">is</span> <span class="operator">=&gt;</span> <span class="string">'ro'</span><span class="operator">,</span>
      <span class="string">isa</span> <span class="operator">=&gt;</span> <span class="variable">union</span><span class="operator">(</span><span class="operator">[</span><span class="string">qw[ Str ArrayRef ]</span><span class="operator">]</span><span class="operator">),</span>
  <span class="operator">);</span>
</code></code></pre>

<p>This is similar to the existing string union:</p>

<pre><code><code>  isa =&gt; &#39;Str|ArrayRef&#39;</code></code></pre>

<p>except that it supports anonymous elements as child constraints:</p>

<pre><code><code>  <span class="variable">has</span> <span class="string">'color'</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
    <span class="string">isa</span> <span class="operator">=&gt;</span> <span class="string">'ro'</span><span class="operator">,</span>
    <span class="string">isa</span> <span class="operator">=&gt;</span> <span class="variable">union</span><span class="operator">(</span><span class="operator">[</span> <span class="string">'Int'</span><span class="operator">,</span>  <span class="variable">enum</span><span class="operator">(</span><span class="operator">[</span><span class="string">qw[ red green blue ]</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">]</span><span class="operator">),</span>
  <span class="operator">);</span>
</code></code></pre>

</dd>
<dt id="as-Parent"><b>as &#39;Parent&#39;</b></dt>
<dd>

<p>This is just sugar for the type constraint construction syntax.</p>

<p>It takes a single argument, which is the name of a parent type.</p>

</dd>
<dt id="where-...-"><b>where { ... }</b></dt>
<dd>

<p>This is just sugar for the type constraint construction syntax.</p>

<p>It takes a subroutine reference as an argument. When the type constraint is tested, the reference is run with the value to be tested in <code><code>$_</code></code>. This reference should return true or false to indicate whether or not the constraint check passed.</p>

</dd>
<dt id="message-...-"><b>message { ... }</b></dt>
<dd>

<p>This is just sugar for the type constraint construction syntax.</p>

<p>It takes a subroutine reference as an argument. When the type constraint fails, then the code block is run with the value provided in <code><code>$_</code></code>. This reference should return a string, which will be used in the text of the exception thrown.</p>

</dd>
<dt id="inline_as-...-"><b>inline_as { ... }</b></dt>
<dd>

<p>This can be used to define a &quot;hand optimized&quot; inlinable version of your type constraint.</p>

<p>You provide a subroutine which will be called <i>as a method</i> on a <a href="../../../lib/Moose/Meta/TypeConstraint.html">Moose::Meta::TypeConstraint</a> object. It will receive a single parameter, the name of the variable to check, typically something like <code><code>&quot;$_&quot;</code></code> or <code><code>&quot;$_[0]&quot;</code></code>.</p>

<p>The subroutine should return a code string suitable for inlining. You can assume that the check will be wrapped in parentheses when it is inlined.</p>

<p>The inlined code should include any checks that your type&#39;s parent types do. If your parent type constraint defines its own inlining, you can simply use that to avoid repeating code. For example, here is the inlining code for the <code><code>Value</code></code> type, which is a subtype of <code><code>Defined</code></code>:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
        <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="variable">parent</span><span class="operator">()-&gt;</span><span class="variable">_inline_check</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">)</span>
        <span class="operator">.</span> <span class="string">' &amp;&amp; !ref('</span> <span class="operator">.</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">.</span> <span class="string">')'</span>
    <span class="operator">}</span>
</code></code></pre>

</dd>
<dt id="optimize_as-...-"><b>optimize_as { ... }</b></dt>
<dd>

<p><b>This feature is deprecated, use <code><code>inline_as</code></code> instead.</b></p>

<p>This can be used to define a &quot;hand optimized&quot; version of your type constraint which can be used to avoid traversing a subtype constraint hierarchy.</p>

<p><b>NOTE:</b> You should only use this if you know what you are doing. All the built in types use this, so your subtypes (assuming they are shallow) will not likely need to use this.</p>

</dd>
<dt id="type-Name-where-..."><b>type &#39;Name&#39;, where { } ...</b></dt>
<dd>

<p>This creates a base type, which has no parent.</p>

<p>The <code><code>type</code></code> function should either be called with the sugar helpers (<code><code>where</code></code>, <code><code>message</code></code>, etc), or with a name and a hashref of parameters:</p>

<pre><code><code>  <span class="variable">type</span><span class="operator">(</span> <span class="string">'Foo'</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">where</span> <span class="operator">=&gt;</span> <span class="operator">...,</span> <span class="string">message</span> <span class="operator">=&gt;</span> <span class="operator">...</span> <span class="operator">}</span> <span class="operator">);</span>
</code></code></pre>

<p>The valid hashref keys are <code><code>where</code></code>, <code><code>message</code></code>, and <code><code>inlined_as</code></code>.</p>

</dd>
</dl>

<h2 id="Type-Constraint-Utilities">Type Constraint Utilities</h2>

<dl>

<dt id="match_on_type-value-type-action-...-default-"><b>match_on_type $value =&gt; ( $type =&gt; \&amp;action, ... ?\&amp;default )</b></dt>
<dd>

<p>This is a utility function for doing simple type based dispatching similar to match/case in OCaml and case/of in Haskell. It is not as featureful as those languages, nor does not it support any kind of automatic destructuring bind. Here is a simple Perl pretty printer dispatching over the core Moose types.</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> ppprint </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">match_on_type</span> <span class="variable">$x</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
          <span class="string">HashRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
              <span class="keyword">my</span> <span class="variable">$hash</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
              <span class="string">'{ '</span>
                  <span class="operator">.</span> <span class="operator">(</span>
                  <span class="keyword">join</span> <span class="string">", "</span> <span class="operator">=&gt;</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">.</span> <span class="string">' =&gt; '</span> <span class="operator">.</span> <span class="variable">ppprint</span><span class="operator">(</span> <span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">)</span> <span class="operator">}</span>
                      <span class="keyword">sort</span> <span class="keyword">keys</span> <span class="variable">%$hash</span>
                  <span class="operator">)</span> <span class="operator">.</span> <span class="string">' }'</span><span class="operator">;</span>
          <span class="operator">},</span>
          <span class="string">ArrayRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
              <span class="keyword">my</span> <span class="variable">$array</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
              <span class="string">'[ '</span> <span class="operator">.</span> <span class="operator">(</span> <span class="keyword">join</span> <span class="string">", "</span> <span class="operator">=&gt;</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="variable">ppprint</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@$array</span> <span class="operator">)</span> <span class="operator">.</span> <span class="string">' ]'</span><span class="operator">;</span>
          <span class="operator">},</span>
          <span class="string">CodeRef</span>   <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="string">'sub { ... }'</span><span class="operator">},</span>
          <span class="string">RegexpRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">'qr/'</span> <span class="operator">.</span> <span class="variable">$_</span> <span class="operator">.</span> <span class="string">'/'</span> <span class="operator">},</span>
          <span class="string">GlobRef</span>   <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">'*'</span> <span class="operator">.</span> <span class="variable">B::svref_2object</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)-&gt;</span><span class="variable">NAME</span> <span class="operator">},</span>
          <span class="string">Object</span>    <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">can</span><span class="operator">(</span><span class="string">'to_string'</span><span class="operator">)</span> <span class="operator">?</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">to_string</span> <span class="operator">:</span> <span class="variable">$_</span> <span class="operator">},</span>
          <span class="string">ScalarRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">'\\'</span> <span class="operator">.</span> <span class="variable">ppprint</span><span class="operator">(</span> <span class="variable">$</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">)</span> <span class="operator">},</span>
          <span class="string">Num</span>       <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">$_</span><span class="operator">},</span>
          <span class="string">Str</span>       <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">'"'</span> <span class="operator">.</span> <span class="variable">$_</span> <span class="operator">.</span> <span class="string">'"'</span> <span class="operator">},</span>
          <span class="string">Undef</span>     <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="string">'undef'</span><span class="operator">},</span>
          <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">die</span> <span class="string">"I don't know what </span><span class="variable">$_</span><span class="string"> is"</span> <span class="operator">}</span>
      <span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Or a simple JSON serializer:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> to_json </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">match_on_type</span> <span class="variable">$x</span> <span class="operator">=&gt;</span> <span class="operator">(</span>
          <span class="string">HashRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
              <span class="keyword">my</span> <span class="variable">$hash</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
              <span class="string">'{ '</span>
                  <span class="operator">.</span> <span class="operator">(</span>
                  <span class="keyword">join</span> <span class="string">", "</span> <span class="operator">=&gt;</span>
                      <span class="keyword">map</span> <span class="operator">{</span> <span class="string">'"'</span> <span class="operator">.</span> <span class="variable">$_</span> <span class="operator">.</span> <span class="string">'" : '</span> <span class="operator">.</span> <span class="variable">to_json</span><span class="operator">(</span> <span class="variable">$hash</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">)</span> <span class="operator">}</span>
                      <span class="keyword">sort</span> <span class="keyword">keys</span> <span class="variable">%$hash</span>
                  <span class="operator">)</span> <span class="operator">.</span> <span class="string">' }'</span><span class="operator">;</span>
          <span class="operator">},</span>
          <span class="string">ArrayRef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
              <span class="keyword">my</span> <span class="variable">$array</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
              <span class="string">'[ '</span> <span class="operator">.</span> <span class="operator">(</span> <span class="keyword">join</span> <span class="string">", "</span> <span class="operator">=&gt;</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="variable">to_json</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@$array</span> <span class="operator">)</span> <span class="operator">.</span> <span class="string">' ]'</span><span class="operator">;</span>
          <span class="operator">},</span>
          <span class="string">Num</span>   <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">$_</span><span class="operator">},</span>
          <span class="string">Str</span>   <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">'"'</span> <span class="operator">.</span> <span class="variable">$_</span> <span class="operator">.</span> <span class="string">'"'</span> <span class="operator">},</span>
          <span class="string">Undef</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="string">'null'</span><span class="operator">},</span>
          <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">die</span> <span class="string">"</span><span class="variable">$_</span><span class="string"> is not acceptable json type"</span> <span class="operator">}</span>
      <span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The matcher is done by mapping a <code><code>$type</code></code> to an <code><code>\&amp;action</code></code>. The <code><code>$type</code></code> can be either a string type or a <a href="../../../lib/Moose/Meta/TypeConstraint.html">Moose::Meta::TypeConstraint</a> object, and <code><code>\&amp;action</code></code> is a subroutine reference. This function will dispatch on the first match for <code><code>$value</code></code>. It is possible to have a catch-all by providing an additional subroutine reference as the final argument to <code><code>match_on_type</code></code>.</p>

</dd>
</dl>

<h2 id="Type-Coercion-Constructors">Type Coercion Constructors</h2>

<p>You can define coercions for type constraints, which allow you to automatically transform values to something valid for the type constraint. If you ask your accessor to coerce, then Moose will run the type-coercion code first, followed by the type constraint check. This feature should be used carefully as it is very powerful and could easily take off a limb if you are not careful.</p>

<p>See the <a href="#SYNOPSIS">&quot;SYNOPSIS&quot;</a> for an example of how to use these.</p>

<dl>

<dt id="coerce-Name-from-OtherName-via-...-"><b>coerce &#39;Name&#39;, from &#39;OtherName&#39;, via { ... }</b></dt>
<dd>

<p>This defines a coercion from one type to another. The <code><code>Name</code></code> argument is the type you are coercing <i>to</i>.</p>

<p>To define multiple coercions, supply more sets of from/via pairs:</p>

<pre><code><code>  <span class="variable">coerce</span> <span class="string">'Name'</span><span class="operator">,</span>
    <span class="variable">from</span> <span class="string">'OtherName'</span><span class="operator">,</span> <span class="variable">via</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">},</span>
    <span class="variable">from</span> <span class="string">'ThirdName'</span><span class="operator">,</span> <span class="variable">via</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">};</span>
</code></code></pre>

</dd>
<dt id="from-OtherName"><b>from &#39;OtherName&#39;</b></dt>
<dd>

<p>This is just sugar for the type coercion construction syntax.</p>

<p>It takes a single type name (or type object), which is the type being coerced <i>from</i>.</p>

</dd>
<dt id="via-...-"><b>via { ... }</b></dt>
<dd>

<p>This is just sugar for the type coercion construction syntax.</p>

<p>It takes a subroutine reference. This reference will be called with the value to be coerced in <code><code>$_</code></code>. It is expected to return a new value of the proper type for the coercion.</p>

</dd>
</dl>

<h2 id="Creating-and-Finding-Type-Constraints">Creating and Finding Type Constraints</h2>

<p>These are additional functions for creating and finding type constraints. Most of these functions are not available for importing. The ones that are importable as specified.</p>

<dl>

<dt id="find_type_constraint-type_name-"><b>find_type_constraint($type_name)</b></dt>
<dd>

<p>This function can be used to locate the <a href="../../../lib/Moose/Meta/TypeConstraint.html">Moose::Meta::TypeConstraint</a> object for a named type.</p>

<p>This function is importable.</p>

</dd>
<dt id="register_type_constraint-type_object-"><b>register_type_constraint($type_object)</b></dt>
<dd>

<p>This function will register a <a href="../../../lib/Moose/Meta/TypeConstraint.html">Moose::Meta::TypeConstraint</a> with the global type registry.</p>

<p>This function is importable.</p>

</dd>
<dt id="normalize_type_constraint_name-type_constraint_name-"><b>normalize_type_constraint_name($type_constraint_name)</b></dt>
<dd>

<p>This method takes a type constraint name and returns the normalized form. This removes any whitespace in the string.</p>

</dd>
<dt id="create_type_constraint_union-pipe_separated_types-type_constraint_names-"><b>create_type_constraint_union($pipe_separated_types | @type_constraint_names)</b></dt>
<dd>

</dd>
<dt id="create_named_type_constraint_union-name-pipe_separated_types-type_constraint_names-"><b>create_named_type_constraint_union($name, $pipe_separated_types | @type_constraint_names)</b></dt>
<dd>

<p>This can take a union type specification like <code><code>&#39;Int|ArrayRef[Int]&#39;</code></code>, or a list of names. It returns a new <a href="../../../lib/Moose/Meta/TypeConstraint/Union.html">Moose::Meta::TypeConstraint::Union</a> object.</p>

</dd>
<dt id="create_parameterized_type_constraint-type_name-"><b>create_parameterized_type_constraint($type_name)</b></dt>
<dd>

<p>Given a <code><code>$type_name</code></code> in the form of <code><code>&#39;BaseType[ContainerType]&#39;</code></code>, this will create a new <a href="../../../lib/Moose/Meta/TypeConstraint/Parameterized.html">Moose::Meta::TypeConstraint::Parameterized</a> object. The <code><code>BaseType</code></code> must exist already exist as a parameterizable type.</p>

</dd>
<dt id="create_class_type_constraint-class-options-"><b>create_class_type_constraint($class, $options)</b></dt>
<dd>

<p>Given a class name this function will create a new <a href="../../../lib/Moose/Meta/TypeConstraint/Class.html">Moose::Meta::TypeConstraint::Class</a> object for that class name.</p>

<p>The <code><code>$options</code></code> is a hash reference that will be passed to the <a href="../../../lib/Moose/Meta/TypeConstraint/Class.html">Moose::Meta::TypeConstraint::Class</a> constructor (as a hash).</p>

</dd>
<dt id="create_role_type_constraint-role-options-"><b>create_role_type_constraint($role, $options)</b></dt>
<dd>

<p>Given a role name this function will create a new <a href="../../../lib/Moose/Meta/TypeConstraint/Role.html">Moose::Meta::TypeConstraint::Role</a> object for that role name.</p>

<p>The <code><code>$options</code></code> is a hash reference that will be passed to the <a href="../../../lib/Moose/Meta/TypeConstraint/Role.html">Moose::Meta::TypeConstraint::Role</a> constructor (as a hash).</p>

</dd>
<dt id="create_enum_type_constraint-name-values-"><b>create_enum_type_constraint($name, $values)</b></dt>
<dd>

<p>Given a enum name this function will create a new <a href="../../../lib/Moose/Meta/TypeConstraint/Enum.html">Moose::Meta::TypeConstraint::Enum</a> object for that enum name.</p>

</dd>
<dt id="create_duck_type_constraint-name-methods-"><b>create_duck_type_constraint($name, $methods)</b></dt>
<dd>

<p>Given a duck type name this function will create a new <a href="../../../lib/Moose/Meta/TypeConstraint/DuckType.html">Moose::Meta::TypeConstraint::DuckType</a> object for that enum name.</p>

</dd>
<dt id="find_or_parse_type_constraint-type_name-"><b>find_or_parse_type_constraint($type_name)</b></dt>
<dd>

<p>Given a type name, this first attempts to find a matching constraint in the global registry.</p>

<p>If the type name is a union or parameterized type, it will create a new object of the appropriate, but if given a &quot;regular&quot; type that does not yet exist, it simply returns false.</p>

<p>When given a union or parameterized type, the member or base type must already exist.</p>

<p>If it creates a new union or parameterized type, it will add it to the global registry.</p>

</dd>
<dt id="find_or_create_isa_type_constraint-type_name-"><b>find_or_create_isa_type_constraint($type_name)</b></dt>
<dd>

</dd>
<dt id="find_or_create_does_type_constraint-type_name-"><b>find_or_create_does_type_constraint($type_name)</b></dt>
<dd>

<p>These functions will first call <code><code>find_or_parse_type_constraint</code></code>. If that function does not return a type, a new type object will be created.</p>

<p>The <code><code>isa</code></code> variant will use <code><code>create_class_type_constraint</code></code> and the <code><code>does</code></code> variant will use <code><code>create_role_type_constraint</code></code>.</p>

</dd>
<dt id="get_type_constraint_registry"><b>get_type_constraint_registry</b></dt>
<dd>

<p>Returns the <a href="../../../lib/Moose/Meta/TypeConstraint/Registry.html">Moose::Meta::TypeConstraint::Registry</a> object which keeps track of all type constraints.</p>

</dd>
<dt id="list_all_type_constraints"><b>list_all_type_constraints</b></dt>
<dd>

<p>This will return a list of type constraint names in the global registry. You can then fetch the actual type object using <code><code>find_type_constraint($type_name)</code></code>.</p>

</dd>
<dt id="list_all_builtin_type_constraints"><b>list_all_builtin_type_constraints</b></dt>
<dd>

<p>This will return a list of builtin type constraints, meaning those which are defined in this module. See the <a href="#Default-Type-Constraints">&quot;Default Type Constraints&quot;</a> section for a complete list.</p>

</dd>
<dt id="export_type_constraints_as_functions"><b>export_type_constraints_as_functions</b></dt>
<dd>

<p>This will export all the current type constraints as functions into the caller&#39;s namespace (<code><code>Int()</code></code>, <code><code>Str()</code></code>, etc). Right now, this is mostly used for testing, but it might prove useful to others.</p>

</dd>
<dt id="get_all_parameterizable_types"><b>get_all_parameterizable_types</b></dt>
<dd>

<p>This returns all the parameterizable types that have been registered, as a list of type objects.</p>

</dd>
<dt id="add_parameterizable_type-type-"><b>add_parameterizable_type($type)</b></dt>
<dd>

<p>Adds <code><code>$type</code></code> to the list of parameterizable types</p>

</dd>
</dl>

<h1 id="BUGS">BUGS</h1>

<p>See <a href="../../../lib/Moose.html#BUGS">&quot;BUGS&quot; in Moose</a> for details on reporting bugs.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Moose is maintained by the Moose Cabal, along with the help of many contributors. See <a href="../../../lib/Moose.html#CABAL">&quot;CABAL&quot; in Moose</a> and <a href="../../../lib/Moose.html#CONTRIBUTORS">&quot;CONTRIBUTORS&quot; in Moose</a> for details.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>This software is copyright (c) 2012 by Infinity Interactive, Inc..</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>


</body>

</html>


