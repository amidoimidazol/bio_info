<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#INTERFACE-SUPPORT">INTERFACE SUPPORT</a></li>
  <li><a href="#IMPORTABLE-SUBS">IMPORTABLE SUBS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Perl::Critic::Utils::PPI - Utility functions for dealing with PPI objects.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Provides classification of <a>PPI::Elements</a>.</p>

<h1 id="INTERFACE-SUPPORT">INTERFACE SUPPORT</h1>

<p>This is considered to be a public module. Any changes to its interface will go through a deprecation cycle.</p>

<h1 id="IMPORTABLE-SUBS">IMPORTABLE SUBS</h1>

<dl>

<dt id="is_ppi_expression_or_generic_statement-element-"><code><code>is_ppi_expression_or_generic_statement( $element )</code></code></dt>
<dd>

<p>Answers whether the parameter is an expression or an undifferentiated statement. I.e. the parameter either is a <a href="../../../../lib/PPI/Statement/Expression.html">PPI::Statement::Expression</a> or the class of the parameter is <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a> and not one of its subclasses other than <code><code>Expression</code></code>.</p>

</dd>
<dt id="is_ppi_generic_statement-element-"><code><code>is_ppi_generic_statement( $element )</code></code></dt>
<dd>

<p>Answers whether the parameter is an undifferentiated statement, i.e. the parameter is a <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a> but not one of its subclasses.</p>

</dd>
<dt id="is_ppi_statement_subclass-element-"><code><code>is_ppi_statement_subclass( $element )</code></code></dt>
<dd>

<p>Answers whether the parameter is a specialized statement, i.e. the parameter is a <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a> but the class of the parameter is not <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a>.</p>

</dd>
<dt id="is_ppi_simple_statement-element-"><code><code>is_ppi_simple_statement( $element )</code></code></dt>
<dd>

<p>Answers whether the parameter represents a simple statement, i.e. whether the parameter is a <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a>, <a href="../../../../lib/PPI/Statement/Break.html">PPI::Statement::Break</a>, <a href="../../../../lib/PPI/Statement/Include.html">PPI::Statement::Include</a>, <a href="../../../../lib/PPI/Statement/Null.html">PPI::Statement::Null</a>, <a href="../../../../lib/PPI/Statement/Package.html">PPI::Statement::Package</a>, or <a href="../../../../lib/PPI/Statement/Variable.html">PPI::Statement::Variable</a>.</p>

</dd>
<dt id="is_ppi_constant_element-element-"><code><code>is_ppi_constant_element( $element )</code></code></dt>
<dd>

<p>Answers whether the parameter represents a constant value, i.e. whether the parameter is a <a href="../../../../lib/PPI/Token/Number.html">PPI::Token::Number</a>, <a href="../../../../lib/PPI/Token/Quote/Literal.html">PPI::Token::Quote::Literal</a>, <a href="../../../../lib/PPI/Token/Quote/Single.html">PPI::Token::Quote::Single</a>, or <a href="../../../../lib/PPI/Token/QuoteLike/Words.html">PPI::Token::QuoteLike::Words</a>, or is a <a href="../../../../lib/PPI/Token/Quote/Double.html">PPI::Token::Quote::Double</a> or <a href="../../../../lib/PPI/Token/Quote/Interpolate.html">PPI::Token::Quote::Interpolate</a> which does not in fact contain any interpolated variables.</p>

<p>This subroutine does <b>not</b> interpret any form of here document as a constant value, and may not until <a href="../../../../lib/PPI/Token/HereDoc.html">PPI::Token::HereDoc</a> acquires the relevant portions of the <a href="../../../../lib/PPI/Token/Quote.html">PPI::Token::Quote</a> interface.</p>

<p>This subroutine also does <b>not</b> interpret entities created by the <a href="../../../../lib/Readonly.html">Readonly</a> module or the <a href="../../../../lib/constant.html">constant</a> pragma as constants, because the infrastructure to detect these appears not to be present, and the author of this subroutine (<b>not</b> Mr. Shank or Mr. Thalhammer) lacks the knowledge/expertise/gumption to put it in place.</p>

</dd>
<dt id="is_subroutine_declaration-element-"><code><code>is_subroutine_declaration( $element )</code></code></dt>
<dd>

<p>Is the parameter a subroutine declaration, named or not?</p>

</dd>
<dt id="is_in_subroutine-element-"><code><code>is_in_subroutine( $element )</code></code></dt>
<dd>

<p>Is the parameter a subroutine or inside one?</p>

</dd>
<dt id="get_constant_name_element_from_declaring_statement-statement-"><code><code>get_constant_name_element_from_declaring_statement($statement)</code></code></dt>
<dd>

<p><b>This subroutine is deprecated.</b> You should use <a href="../../../../lib/PPIx/Utilities/Statement.html#get_constant_name_elements_from_declaring_statement-">&quot;get_constant_name_elements_from_declaring_statement()&quot; in PPIx::Utilities::Statement</a> instead.</p>

<p>Given a <a href="../../../../lib/PPI/Statement.html">PPI::Statement</a>, if the statement is a <code><code>use constant</code></code> or <a href="../../../../lib/Readonly.html">Readonly</a> declaration statement, return the name of the thing being defined.</p>

<p>Given</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">constant</span> <span class="number">1.16</span> <span class="string">FOO</span> <span class="operator">=&gt;</span> <span class="string">'bar'</span><span class="operator">;</span>
</code></code></pre>

<p>this will return &quot;FOO&quot;. Similarly, given</p>

<pre><code><code>    <span class="variable">Readonly::Hash</span> <span class="keyword">my</span> <span class="variable">%FOO</span> <span class="operator">=&gt;</span> <span class="operator">(</span> <span class="string">bar</span> <span class="operator">=&gt;</span> <span class="string">'baz'</span> <span class="operator">);</span>
</code></code></pre>

<p>this will return &quot;%FOO&quot;.</p>

<p><b>Caveat:</b> in the case where multiple constants are declared using the same <code><code>use constant</code></code> statement (e.g. <code><code><span class="keyword">use</span> <span class="variable">constant</span> <span class="operator">{</span> <span class="string">FOO</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">BAR</span> <span class="operator">=&gt;</span> <span class="number">2</span> <span class="operator">};</span>
</code></code>, this subroutine will return the declaring <a href="../../../../lib/PPI/Structure/Constructor.html">PPI::Structure::Constructor</a>. In the case of <code><code><span class="keyword">use</span> <span class="variable">constant</span> <span class="number">1.16</span> <span class="operator">{</span> <span class="string">FOO</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">BAR</span> <span class="operator">=&gt;</span> <span class="number">2</span> <span class="operator">};</span>
</code></code> it may return a <a href="../../../../lib/PPI/Structure/Block.html">PPI::Structure::Block</a> instead of a <a href="../../../../lib/PPI/Structure/Constructor.html">PPI::Structure::Constructor</a>, due to a parse error in <a href="../../../../lib/PPI.html">PPI</a>.</p>

</dd>
<dt id="get_next_element_in_same_simple_statement-element-"><code><code>get_next_element_in_same_simple_statement( $element )</code></code></dt>
<dd>

<p>Given a <a href="../../../../lib/PPI/Element.html">PPI::Element</a>, this subroutine returns the next element in the same simple statement as defined by is_ppi_simple_statement(). If no next element can be found, this subroutine simply returns.</p>

<p>If the $element is undefined or unblessed, we simply return.</p>

<p>If the $element satisfies <code><code>is_ppi_simple_statement()</code></code>, we return, <b>unless</b> it has a parent which is a <a href="../../../../lib/PPI/Structure/List.html">PPI::Structure::List</a>.</p>

<p>If the $element is the last significant element in its <a href="../../../../lib/PPI/Node.html">PPI::Node</a>, we replace it with its parent and iterate again.</p>

<p>Otherwise, we return <code><code>$element-&gt;snext_sibling()</code></code>.</p>

</dd>
<dt id="get_previous_module_used_on_same_line-element-"><code><code>get_previous_module_used_on_same_line( $element )</code></code></dt>
<dd>

<p>Given a <a href="../../../../lib/PPI/Element.html">PPI::Element</a>, returns the <a href="../../../../lib/PPI/Element.html">PPI::Element</a> representing the name of the module included by the previous <code><code>use</code></code> or <code><code>require</code></code> on the same line as the $element. If none is found, simply returns.</p>

<p>For example, with the line</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">version</span><span class="operator">;</span> <span class="keyword">our</span> <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="operator">...;</span>
</code></code></pre>

<p>given the <a href="../../../../lib/PPI/Token/Symbol.html">PPI::Token::Symbol</a> instance for <code><code>$VERSION</code></code>, this will return &quot;version&quot;.</p>

<p>If the given element is in a <code><code>use</code></code> or &lt;require&gt;, the return is from the previous <code><code>use</code></code> or <code><code>require</code></code> on the line, if any.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Elliot Shank &lt;perl@galumph.com&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2007-2011 Elliot Shank.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself. The full text of this license can be found in the LICENSE file included with this module.</p>


</body>

</html>


