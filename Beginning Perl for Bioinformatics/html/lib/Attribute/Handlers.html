<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Typed-lexicals">Typed lexicals</a></li>
      <li><a href="#Type-specific-attribute-handlers">Type-specific attribute handlers</a></li>
      <li><a href="#Non-interpretive-attribute-handlers">Non-interpretive attribute handlers</a></li>
      <li><a href="#Phase-specific-attribute-handlers">Phase-specific attribute handlers</a></li>
      <li><a href="#Attributes-as-interfaces">Attributes as  interfaces</a>
        <ul>
          <li><a href="#Passing-the-tied-object-to">Passing the tied object to </a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#EXAMPLES">EXAMPLES</a></li>
  <li><a href="#UTILITY-FUNCTIONS">UTILITY FUNCTIONS</a></li>
  <li><a href="#DIAGNOSTICS">DIAGNOSTICS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Attribute::Handlers - Simpler definition of attribute handlers</p>

<h1 id="VERSION">VERSION</h1>

<p>This document describes version 0.93 of Attribute::Handlers, released July 20, 2011.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">MyClass</span><span class="operator">;</span>
    <span class="keyword">require</span> <span class="number">5.006</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    <span class="keyword">no</span> <span class="variable">warnings</span> <span class="string">'redefine'</span><span class="operator">;</span>
    
    
    <span class="keyword">sub</span><span class="variable"> Good : ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$package</span><span class="operator">,</span> <span class="variable">$symbol</span><span class="operator">,</span> <span class="variable">$referent</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    
        <span class="comment"># Invoked for any scalar variable with a :Good attribute,</span>
        <span class="comment"># provided the variable was declared in MyClass (or</span>
        <span class="comment"># a derived class) or typed to MyClass.</span>
    
        <span class="comment"># Do whatever to $referent here (executed in CHECK phase).</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> Bad : ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># Invoked for any scalar variable with a :Bad attribute,</span>
        <span class="comment"># provided the variable was declared in MyClass (or</span>
        <span class="comment"># a derived class) or typed to MyClass.</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> Good : ATTR</span><span class="operator">(</span>ARRAY<span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># Invoked for any array variable with a :Good attribute,</span>
        <span class="comment"># provided the variable was declared in MyClass (or</span>
        <span class="comment"># a derived class) or typed to MyClass.</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> Good : ATTR</span><span class="operator">(</span>HASH<span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># Invoked for any hash variable with a :Good attribute,</span>
        <span class="comment"># provided the variable was declared in MyClass (or</span>
        <span class="comment"># a derived class) or typed to MyClass.</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> Ugly : ATTR</span><span class="operator">(</span>CODE<span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># Invoked for any subroutine declared in MyClass (or a </span>
        <span class="comment"># derived class) with an :Ugly attribute.</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> Omni : ATTR </span><span class="operator">{</span>
        <span class="comment"># Invoked for any scalar, array, hash, or subroutine</span>
        <span class="comment"># with an :Omni attribute, provided the variable or</span>
        <span class="comment"># subroutine was declared in MyClass (or a derived class)</span>
        <span class="comment"># or the variable was typed to MyClass.</span>
        <span class="comment"># Use ref($_[2]) to determine what kind of referent it was.</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
    
    
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotie</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Cycle</span> <span class="operator">=&gt;</span> <span class="variable">Tie::Cycle</span> <span class="operator">}</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$next</span> <span class="operator">:</span> <span class="variable">Cycle</span><span class="operator">(</span><span class="operator">[</span><span class="string">'A'</span><span class="operator">..</span><span class="string">'Z'</span><span class="operator">]</span><span class="operator">);</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module, when inherited by a package, allows that package&#39;s class to define attribute handler subroutines for specific attributes. Variables and subroutines subsequently defined in that package, or in packages derived from that package may be given attributes with the same names as the attribute handler subroutines, which will then be called in one of the compilation phases (i.e. in a <code><code>BEGIN</code></code>, <code><code>CHECK</code></code>, <code><code>INIT</code></code>, or <code><code>END</code></code> block). (<code><code>UNITCHECK</code></code> blocks don&#39;t correspond to a global compilation phase, so they can&#39;t be specified here.)</p>

<p>To create a handler, define it as a subroutine with the same name as the desired attribute, and declare the subroutine itself with the attribute <code><code>:ATTR</code></code>. For example:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> Loud :ATTR </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$package</span><span class="operator">,</span> <span class="variable">$symbol</span><span class="operator">,</span> <span class="variable">$referent</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$phase</span><span class="operator">,</span>
            <span class="variable">$filename</span><span class="operator">,</span> <span class="variable">$linenum</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">STDERR</span>
            <span class="keyword">ref</span><span class="operator">(</span><span class="variable">$referent</span><span class="operator">),</span> <span class="string">" "</span><span class="operator">,</span>
            <span class="variable">*</span><span class="operator">{</span><span class="variable">$symbol</span><span class="operator">}{</span><span class="string">NAME</span><span class="operator">}</span><span class="operator">,</span> <span class="string">" "</span><span class="operator">,</span>
            <span class="string">"(</span><span class="variable">$referent</span><span class="string">) "</span><span class="operator">,</span> <span class="string">"was just declared "</span><span class="operator">,</span>
            <span class="string">"and ascribed the ${attr} attribute "</span><span class="operator">,</span>
            <span class="string">"with data (</span><span class="variable">$data</span><span class="string">)\n"</span><span class="operator">,</span>
            <span class="string">"in phase </span><span class="variable">$phase</span><span class="string">\n"</span><span class="operator">,</span>
            <span class="string">"in file </span><span class="variable">$filename</span><span class="string"> at line </span><span class="variable">$linenum</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>This creates a handler for the attribute <code><code>:Loud</code></code> in the class LoudDecl. Thereafter, any subroutine declared with a <code><code>:Loud</code></code> attribute in the class LoudDecl:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> foo: Loud </span><span class="operator">{...}</span>
</code></code></pre>

<p>causes the above handler to be invoked, and passed:</p>

<dl>

<dt id="pod-0-">[0]</dt>
<dd>

<p>the name of the package into which it was declared;</p>

</dd>
<dt id="pod-1-">[1]</dt>
<dd>

<p>a reference to the symbol table entry (typeglob) containing the subroutine;</p>

</dd>
<dt id="pod-2-">[2]</dt>
<dd>

<p>a reference to the subroutine;</p>

</dd>
<dt id="pod-3-">[3]</dt>
<dd>

<p>the name of the attribute;</p>

</dd>
<dt id="pod-4-">[4]</dt>
<dd>

<p>any data associated with that attribute;</p>

</dd>
<dt id="pod-5-">[5]</dt>
<dd>

<p>the name of the phase in which the handler is being invoked;</p>

</dd>
<dt id="pod-6-">[6]</dt>
<dd>

<p>the filename in which the handler is being invoked;</p>

</dd>
<dt id="pod-7-">[7]</dt>
<dd>

<p>the line number in this file.</p>

</dd>
</dl>

<p>Likewise, declaring any variables with the <code><code>:Loud</code></code> attribute within the package:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$foo</span> <span class="operator">:</span><span class="variable">Loud</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">@foo</span> <span class="operator">:</span><span class="variable">Loud</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">%foo</span> <span class="operator">:</span><span class="variable">Loud</span><span class="operator">;</span>
</code></code></pre>

<p>will cause the handler to be called with a similar argument list (except, of course, that <code><code>$_[2]</code></code> will be a reference to the variable).</p>

<p>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</p>

<p>If a lexical variable is given an attribute, there is no symbol table to which it belongs, so the symbol table argument (<code><code>$_[1]</code></code>) is set to the string <code><code>&#39;LEXICAL&#39;</code></code> in that case. Likewise, ascribing an attribute to an anonymous subroutine results in a symbol table argument of <code><code>&#39;ANON&#39;</code></code>.</p>

<p>The data argument passes in the value (if any) associated with the attribute. For example, if <code><code>&amp;foo</code></code> had been declared:</p>

<pre><code><code>        <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>"turn it up to 11, man!"<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>then a reference to an array containing the string <code><code>&quot;turn it up to 11, man!&quot;</code></code> would be passed as the last argument.</p>

<p>Attribute::Handlers makes strenuous efforts to convert the data argument (<code><code>$_[4]</code></code>) to a usable form before passing it to the handler (but see <a href="#Non-interpretive-attribute-handlers">&quot;Non-interpretive attribute handlers&quot;</a>). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>till=&gt;ears=&gt;are=&gt;bleeding<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>qw/till ears are bleeding/<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>qw/till, ears, are, bleeding/<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>till,ears,are,bleeding<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>causes it to pass <code><code>[&#39;till&#39;,&#39;ears&#39;,&#39;are&#39;,&#39;bleeding&#39;]</code></code> as the handler&#39;s data argument. While:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>['till','ears','are','bleeding']<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>causes it to pass <code><code>[ [&#39;till&#39;,&#39;ears&#39;,&#39;are&#39;,&#39;bleeding&#39;] ]</code></code>; the array reference specified in the data being passed inside the standard array reference indicating successful interpretation.</p>

<p>However, if the data can&#39;t be parsed as valid Perl, then it is passed as an uninterpreted string. For example:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>my,ears,are,bleeding<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> foo :Loud</span><span class="operator">(</span>qw/my ears are bleeding<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>cause the strings <code><code>&#39;my,ears,are,bleeding&#39;</code></code> and <code><code>&#39;qw/my ears are bleeding&#39;</code></code> respectively to be passed as the data argument.</p>

<p>If no value is associated with the attribute, <code><code>undef</code></code> is passed.</p>

<h2 id="Typed-lexicals">Typed lexicals</h2>

<p>Regardless of the package in which it is declared, if a lexical variable is ascribed an attribute, the handler that is invoked is the one belonging to the package to which it is typed. For example, the following declarations:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">OtherClass</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">LoudDecl</span> <span class="variable">$loudobj</span> <span class="operator">:</span> <span class="variable">Loud</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">LoudDecl</span> <span class="variable">@loudobjs</span> <span class="operator">:</span> <span class="variable">Loud</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">LoudDecl</span> <span class="variable">%loudobjex</span> <span class="operator">:</span> <span class="variable">Loud</span><span class="operator">;</span>
</code></code></pre>

<p>causes the LoudDecl::Loud handler to be invoked (even if OtherClass also defines a handler for <code><code>:Loud</code></code> attributes).</p>

<h2 id="Type-specific-attribute-handlers">Type-specific attribute handlers</h2>

<p>If an attribute handler is declared and the <code><code>:ATTR</code></code> specifier is given the name of a built-in type (<code><code>SCALAR</code></code>, <code><code>ARRAY</code></code>, <code><code>HASH</code></code>, or <code><code>CODE</code></code>), the handler is only applied to declarations of that type. For example, the following definition:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> RealLoud :ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"Yeeeeow!"</span> <span class="operator">}</span>
</code></code></pre>

<p>creates an attribute handler that applies only to scalars:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Painful</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">base</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$metal</span> <span class="operator">:</span> <span class="variable">RealLoud</span><span class="operator">;</span>           <span class="comment"># invokes &amp;LoudDecl::RealLoud</span>
    <span class="keyword">my</span> <span class="variable">@metal</span> <span class="operator">:</span> <span class="variable">RealLoud</span><span class="operator">;</span>           <span class="comment"># error: unknown attribute</span>
    <span class="keyword">my</span> <span class="variable">%metal</span> <span class="operator">:</span> <span class="variable">RealLoud</span><span class="operator">;</span>           <span class="comment"># error: unknown attribute</span>
    <span class="keyword">sub</span><span class="variable"> metal : RealLoud </span><span class="operator">{...}</span>      <span class="comment"># error: unknown attribute</span>
</code></code></pre>

<p>You can, of course, declare separate handlers for these types as well (but you&#39;ll need to specify <code><code>no warnings &#39;redefine&#39;</code></code> to do it quietly):</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    <span class="keyword">no</span> <span class="variable">warnings</span> <span class="string">'redefine'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> RealLoud :ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"Yeeeeow!"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> RealLoud :ATTR</span><span class="operator">(</span>ARRAY<span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"Urrrrrrrrrr!"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> RealLoud :ATTR</span><span class="operator">(</span>HASH<span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="string">"Arrrrrgggghhhhhh!"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> RealLoud :ATTR</span><span class="operator">(</span>CODE<span class="operator">)</span> <span class="operator">{</span> <span class="variable">croak</span> <span class="string">"Real loud sub torpedoed"</span> <span class="operator">}</span>
</code></code></pre>

<p>You can also explicitly indicate that a single handler is meant to be used for all types of referents like so:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">LoudDecl</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> SeriousLoud :ATTR</span><span class="operator">(</span>ANY<span class="operator">)</span> <span class="operator">{</span> <span class="keyword">warn</span> <span class="string">"Hearing loss imminent"</span> <span class="operator">}</span>
</code></code></pre>

<p>(I.e. <code><code>ATTR(ANY)</code></code> is a synonym for <code><code>:ATTR</code></code>).</p>

<h2 id="Non-interpretive-attribute-handlers">Non-interpretive attribute handlers</h2>

<p>Occasionally the strenuous efforts Attribute::Handlers makes to convert the data argument (<code><code>$_[4]</code></code>) to a usable form before passing it to the handler get in the way.</p>

<p>You can turn off that eagerness-to-help by declaring an attribute handler with the keyword <code><code>RAWDATA</code></code>. For example:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> Raw          : ATTR</span><span class="operator">(</span>RAWDATA<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Nekkid       : ATTR</span><span class="operator">(</span>SCALAR,RAWDATA<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Au::Naturale : ATTR</span><span class="operator">(</span>RAWDATA,ANY<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>Then the handler makes absolutely no attempt to interpret the data it receives and simply passes it as a string:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$power</span> <span class="operator">:</span> <span class="variable">Raw</span><span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">100</span><span class="operator">);</span>        <span class="comment"># handlers receives "1..100"</span>
</code></code></pre>

<h2 id="Phase-specific-attribute-handlers">Phase-specific attribute handlers</h2>

<p>By default, attribute handlers are called at the end of the compilation phase (in a <code><code>CHECK</code></code> block). This seems to be optimal in most cases because most things that can be defined are defined by that point but nothing has been executed.</p>

<p>However, it is possible to set up attribute handlers that are called at other points in the program&#39;s compilation or execution, by explicitly stating the phase (or phases) in which you wish the attribute handler to be called. For example:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> Early    :ATTR</span><span class="operator">(</span>SCALAR,BEGIN<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Normal   :ATTR</span><span class="operator">(</span>SCALAR,CHECK<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Late     :ATTR</span><span class="operator">(</span>SCALAR,INIT<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Final    :ATTR</span><span class="operator">(</span>SCALAR,END<span class="operator">)</span> <span class="operator">{...}</span>
    <span class="keyword">sub</span><span class="variable"> Bookends :ATTR</span><span class="operator">(</span>SCALAR,BEGIN,END<span class="operator">)</span> <span class="operator">{...}</span>
</code></code></pre>

<p>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler&#39;s final argument.</p>

<p>Note that attribute handlers that are scheduled for the <code><code>BEGIN</code></code> phase are handled as soon as the attribute is detected (i.e. before any subsequently defined <code><code>BEGIN</code></code> blocks are executed).</p>

<h2 id="Attributes-as-interfaces">Attributes as <code><code>tie</code></code> interfaces</h2>

<p>Attributes make an excellent and intuitive interface through which to tie variables. For example:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Tie::Cycle</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> UNIVERSAL::Cycle : ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$package</span><span class="operator">,</span> <span class="variable">$symbol</span><span class="operator">,</span> <span class="variable">$referent</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$phase</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="variable">$data</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$data</span> <span class="operator">]</span> <span class="keyword">unless</span> <span class="keyword">ref</span> <span class="variable">$data</span> <span class="keyword">eq</span> <span class="string">'ARRAY'</span><span class="operator">;</span>
        <span class="keyword">tie</span> <span class="variable">$$referent</span><span class="operator">,</span> <span class="string">'Tie::Cycle'</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="comment"># and thereafter...</span>
    
    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$next</span> <span class="operator">:</span> <span class="variable">Cycle</span><span class="operator">(</span><span class="string">'A'</span><span class="operator">..</span><span class="string">'Z'</span><span class="operator">);</span>     <span class="comment"># $next is now a tied variable</span>
    
    <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">$next</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Note that, because the <code><code>Cycle</code></code> attribute receives its arguments in the <code><code>$data</code></code> variable, if the attribute is given a list of arguments, <code><code>$data</code></code> will consist of a single array reference; otherwise, it will consist of the single argument directly. Since Tie::Cycle requires its cycling values to be passed as an array reference, this means that we need to wrap non-array-reference arguments in an array constructor:</p>

<pre><code><code>    <span class="variable">$data</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$data</span> <span class="operator">]</span> <span class="keyword">unless</span> <span class="keyword">ref</span> <span class="variable">$data</span> <span class="keyword">eq</span> <span class="string">'ARRAY'</span><span class="operator">;</span>
</code></code></pre>

<p>Typically, however, things are the other way around: the tieable class expects its arguments as a flattened list, so the attribute looks like:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> UNIVERSAL::Cycle : ATTR</span><span class="operator">(</span>SCALAR<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$package</span><span class="operator">,</span> <span class="variable">$symbol</span><span class="operator">,</span> <span class="variable">$referent</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$phase</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@data</span> <span class="operator">=</span> <span class="keyword">ref</span> <span class="variable">$data</span> <span class="keyword">eq</span> <span class="string">'ARRAY'</span> <span class="operator">?</span> <span class="variable">@$data</span> <span class="operator">:</span> <span class="variable">$data</span><span class="operator">;</span>
        <span class="keyword">tie</span> <span class="variable">$$referent</span><span class="operator">,</span> <span class="string">'Tie::Whatever'</span><span class="operator">,</span> <span class="variable">@data</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>This software pattern is so widely applicable that Attribute::Handlers provides a way to automate it: specifying <code><code>&#39;autotie&#39;</code></code> in the <code><code>use Attribute::Handlers</code></code> statement. So, the cycling example, could also be written:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotie</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Cycle</span> <span class="operator">=&gt;</span> <span class="string">'Tie::Cycle'</span> <span class="operator">}</span><span class="operator">;</span>
    
    <span class="comment"># and thereafter...</span>
    
    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$next</span> <span class="operator">:</span> <span class="variable">Cycle</span><span class="operator">(</span><span class="operator">[</span><span class="string">'A'</span><span class="operator">..</span><span class="string">'Z'</span><span class="operator">]</span><span class="operator">);</span>     <span class="comment"># $next is now a tied variable</span>
    
    <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">$next</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Note that we now have to pass the cycling values as an array reference, since the <code><code>autotie</code></code> mechanism passes <code><code>tie</code></code> a list of arguments as a list (as in the Tie::Whatever example), <i>not</i> as an array reference (as in the original Tie::Cycle example at the start of this section).</p>

<p>The argument after <code><code>&#39;autotie&#39;</code></code> is a reference to a hash in which each key is the name of an attribute to be created, and each value is the class to which variables ascribed that attribute should be tied.</p>

<p>Note that there is no longer any need to import the Tie::Cycle module -- Attribute::Handlers takes care of that automagically. You can even pass arguments to the module&#39;s <code><code>import</code></code> subroutine, by appending them to the class name. For example:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span>
         <span class="string">autotie</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Dir</span> <span class="operator">=&gt;</span> <span class="string">'Tie::Dir qw(DIR_UNLINK)'</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>If the attribute name is unqualified, the attribute is installed in the current package. Otherwise it is installed in the qualifier&#39;s package:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Here</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotie</span> <span class="operator">=&gt;</span> <span class="operator">{</span>
         <span class="variable">Other::Good</span> <span class="operator">=&gt;</span> <span class="variable">Tie::SecureHash</span><span class="operator">,</span> <span class="comment"># tie attr installed in Other::</span>
                 <span class="string">Bad</span> <span class="operator">=&gt;</span> <span class="variable">Tie::Taxes</span><span class="operator">,</span>      <span class="comment"># tie attr installed in Here::</span>
     <span class="variable">UNIVERSAL::Ugly</span> <span class="operator">=&gt;</span> <span class="variable">Software::Patent</span> <span class="comment"># tie attr installed everywhere</span>
    <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- <code><code>__CALLER__</code></code>, which may be specified as the qualifier of an attribute:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Tie::Me::Kangaroo</span><span class="operator">:</span><span class="variable">Down::Sport</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotie</span> <span class="operator">=&gt;</span>
         <span class="operator">{</span> <span class="string">'__CALLER__::Roo'</span> <span class="operator">=&gt;</span> <span class="keyword">__PACKAGE__</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>This causes Attribute::Handlers to define the <code><code>Roo</code></code> attribute in the package that imports the Tie::Me::Kangaroo:Down::Sport module.</p>

<p>Note that it is important to quote the __CALLER__::Roo identifier because a bug in perl 5.8 will refuse to parse it and cause an unknown error.</p>

<h3 id="Passing-the-tied-object-to">Passing the tied object to <code><code>tie</code></code></h3>

<p>Occasionally it is important to pass a reference to the object being tied to the TIESCALAR, TIEHASH, etc. that ties it.</p>

<p>The <code><code>autotie</code></code> mechanism supports this too. The following code:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotieref</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Selfish</span> <span class="operator">=&gt;</span> <span class="variable">Tie::Selfish</span> <span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">:</span> <span class="variable">Selfish</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</code></code></pre>

<p>has the same effect as:</p>

<pre><code><code>    <span class="keyword">tie</span> <span class="keyword">my</span> <span class="variable">$var</span><span class="operator">,</span> <span class="string">'Tie::Selfish'</span><span class="operator">,</span> <span class="variable">@args</span><span class="operator">;</span>
</code></code></pre>

<p>But when <code><code>&quot;autotieref&quot;</code></code> is used instead of <code><code>&quot;autotie&quot;</code></code>:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span> <span class="string">autotieref</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">Selfish</span> <span class="operator">=&gt;</span> <span class="variable">Tie::Selfish</span> <span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">:</span> <span class="variable">Selfish</span><span class="operator">(</span><span class="variable">@args</span><span class="operator">);</span>
</code></code></pre>

<p>the effect is to pass the <code><code>tie</code></code> call an extra reference to the variable being tied:</p>

<pre><code><code>    <span class="keyword">tie</span> <span class="keyword">my</span> <span class="variable">$var</span><span class="operator">,</span> <span class="string">'Tie::Selfish'</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var</span><span class="operator">,</span> <span class="variable">@args</span><span class="operator">;</span>
</code></code></pre>

<h1 id="EXAMPLES">EXAMPLES</h1>

<p>If the class shown in <a href="#SYNOPSIS">&quot;SYNOPSIS&quot;</a> were placed in the MyClass.pm module, then the following code:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">MyClass</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">MyClass</span> <span class="variable">$slr</span> <span class="operator">:</span><span class="variable">Good</span> <span class="operator">:</span><span class="variable">Bad</span><span class="operator">(</span><span class="number">1</span><span class="operator">**</span><span class="number">1</span><span class="operator">-</span><span class="number">1</span><span class="operator">)</span> <span class="operator">:</span><span class="variable">Omni</span><span class="operator">(-</span><span class="variable">vorous</span><span class="operator">);</span>
    
    <span class="keyword">package</span> <span class="variable">SomeOtherClass</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">base</span> <span class="variable">MyClass</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> tent </span><span class="operator">{</span> <span class="string">'acle'</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> fn :Ugly</span><span class="operator">(</span>sister<span class="operator">)</span> <span class="operator">:</span><span class="variable">Omni</span><span class="operator">(</span><span class="string">'po'</span><span class="operator">,</span><span class="variable">tent</span><span class="operator">())</span> <span class="operator">{...}</span>
    <span class="keyword">my</span> <span class="variable">@arr</span> <span class="operator">:</span><span class="variable">Good</span> <span class="operator">:</span><span class="variable">Omni</span><span class="operator">(</span><span class="regex">s/cie/nt/</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">%hsh</span> <span class="operator">:</span><span class="variable">Good</span><span class="operator">(</span><span class="string">q/bye/</span><span class="operator">)</span> <span class="operator">:</span><span class="variable">Omni</span><span class="operator">(</span><span class="string">q/bus/</span><span class="operator">);</span>
</code></code></pre>

<p>would cause the following handlers to be invoked:</p>

<pre><code><code>    <span class="comment"># my MyClass $slr :Good :Bad(1**1-1) :Omni(-vorous);</span>
    
    <span class="variable">MyClass::Good</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">SCALAR</span><span class="operator">)(</span> <span class="string">'MyClass'</span><span class="operator">,</span>          <span class="comment"># class</span>
                                <span class="string">'LEXICAL'</span><span class="operator">,</span>          <span class="comment"># no typeglob</span>
                                <span class="operator">\</span><span class="variable">$slr</span><span class="operator">,</span>              <span class="comment"># referent</span>
                                <span class="string">'Good'</span><span class="operator">,</span>             <span class="comment"># attr name</span>
                                <span class="keyword">undef</span>               <span class="comment"># no attr data</span>
                                <span class="string">'CHECK'</span><span class="operator">,</span>            <span class="comment"># compiler phase</span>
                              <span class="operator">);</span>
    
    <span class="variable">MyClass::Bad</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">SCALAR</span><span class="operator">)(</span> <span class="string">'MyClass'</span><span class="operator">,</span>           <span class="comment"># class</span>
                               <span class="string">'LEXICAL'</span><span class="operator">,</span>           <span class="comment"># no typeglob</span>
                               <span class="operator">\</span><span class="variable">$slr</span><span class="operator">,</span>               <span class="comment"># referent</span>
                               <span class="string">'Bad'</span><span class="operator">,</span>               <span class="comment"># attr name</span>
                               <span class="number">0</span>                    <span class="comment"># eval'd attr data</span>
                               <span class="string">'CHECK'</span><span class="operator">,</span>             <span class="comment"># compiler phase</span>
                             <span class="operator">);</span>
    
    <span class="variable">MyClass::Omni</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">SCALAR</span><span class="operator">)(</span> <span class="string">'MyClass'</span><span class="operator">,</span>          <span class="comment"># class</span>
                                <span class="string">'LEXICAL'</span><span class="operator">,</span>          <span class="comment"># no typeglob</span>
                                <span class="operator">\</span><span class="variable">$slr</span><span class="operator">,</span>              <span class="comment"># referent</span>
                                <span class="string">'Omni'</span><span class="operator">,</span>             <span class="comment"># attr name</span>
                                <span class="string">'-vorous'</span>           <span class="comment"># eval'd attr data</span>
                                <span class="string">'CHECK'</span><span class="operator">,</span>            <span class="comment"># compiler phase</span>
                              <span class="operator">);</span>
    
    
    <span class="comment"># sub fn :Ugly(sister) :Omni('po',tent()) {...}</span>
    
    <span class="variable">MyClass::UGLY</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">CODE</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>     <span class="comment"># class</span>
                              <span class="operator">\</span><span class="variable">*SomeOtherClass::fn</span><span class="operator">,</span> <span class="comment"># typeglob</span>
                              <span class="operator">\&amp;</span><span class="variable">SomeOtherClass::fn</span><span class="operator">,</span> <span class="comment"># referent</span>
                              <span class="string">'Ugly'</span><span class="operator">,</span>               <span class="comment"># attr name</span>
                              <span class="string">'sister'</span>              <span class="comment"># eval'd attr data</span>
                              <span class="string">'CHECK'</span><span class="operator">,</span>              <span class="comment"># compiler phase</span>
                            <span class="operator">);</span>
    
    <span class="variable">MyClass::Omni</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">CODE</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>     <span class="comment"># class</span>
                              <span class="operator">\</span><span class="variable">*SomeOtherClass::fn</span><span class="operator">,</span> <span class="comment"># typeglob</span>
                              <span class="operator">\&amp;</span><span class="variable">SomeOtherClass::fn</span><span class="operator">,</span> <span class="comment"># referent</span>
                              <span class="string">'Omni'</span><span class="operator">,</span>               <span class="comment"># attr name</span>
                              <span class="operator">[</span><span class="string">'po'</span><span class="operator">,</span><span class="string">'acle'</span><span class="operator">]</span>         <span class="comment"># eval'd attr data</span>
                              <span class="string">'CHECK'</span><span class="operator">,</span>              <span class="comment"># compiler phase</span>
                            <span class="operator">);</span>
    
    
    <span class="comment"># my @arr :Good :Omni(s/cie/nt/);</span>
    
    <span class="variable">MyClass::Good</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">ARRAY</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>    <span class="comment"># class</span>
                               <span class="string">'LEXICAL'</span><span class="operator">,</span>           <span class="comment"># no typeglob</span>
                               <span class="operator">\</span><span class="variable">@arr</span><span class="operator">,</span>               <span class="comment"># referent</span>
                               <span class="string">'Good'</span><span class="operator">,</span>              <span class="comment"># attr name</span>
                               <span class="keyword">undef</span>                <span class="comment"># no attr data</span>
                               <span class="string">'CHECK'</span><span class="operator">,</span>             <span class="comment"># compiler phase</span>
                             <span class="operator">);</span>
    
    <span class="variable">MyClass::Omni</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">ARRAY</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>    <span class="comment"># class</span>
                               <span class="string">'LEXICAL'</span><span class="operator">,</span>           <span class="comment"># no typeglob</span>
                               <span class="operator">\</span><span class="variable">@arr</span><span class="operator">,</span>               <span class="comment"># referent</span>
                               <span class="string">'Omni'</span><span class="operator">,</span>              <span class="comment"># attr name</span>
                               <span class="string">""</span>                   <span class="comment"># eval'd attr data </span>
                               <span class="string">'CHECK'</span><span class="operator">,</span>             <span class="comment"># compiler phase</span>
                             <span class="operator">);</span>
    
    
    <span class="comment"># my %hsh :Good(q/bye) :Omni(q/bus/);</span>
                              
    <span class="variable">MyClass::Good</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">HASH</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>     <span class="comment"># class</span>
                              <span class="string">'LEXICAL'</span><span class="operator">,</span>            <span class="comment"># no typeglob</span>
                              <span class="operator">\</span><span class="variable">%hsh</span><span class="operator">,</span>                <span class="comment"># referent</span>
                              <span class="string">'Good'</span><span class="operator">,</span>               <span class="comment"># attr name</span>
                              <span class="string">'q/bye'</span>               <span class="comment"># raw attr data</span>
                              <span class="string">'CHECK'</span><span class="operator">,</span>              <span class="comment"># compiler phase</span>
                            <span class="operator">);</span>
                    
    <span class="variable">MyClass::Omni</span><span class="operator">:</span><span class="variable">ATTR</span><span class="operator">(</span><span class="variable">HASH</span><span class="operator">)(</span> <span class="string">'SomeOtherClass'</span><span class="operator">,</span>     <span class="comment"># class</span>
                              <span class="string">'LEXICAL'</span><span class="operator">,</span>            <span class="comment"># no typeglob</span>
                              <span class="operator">\</span><span class="variable">%hsh</span><span class="operator">,</span>                <span class="comment"># referent</span>
                              <span class="string">'Omni'</span><span class="operator">,</span>               <span class="comment"># attr name</span>
                              <span class="string">'bus'</span>                 <span class="comment"># eval'd attr data</span>
                              <span class="string">'CHECK'</span><span class="operator">,</span>              <span class="comment"># compiler phase</span>
                            <span class="operator">);</span>
</code></code></pre>

<p>Installing handlers into UNIVERSAL, makes them...err..universal. For example:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Descriptions</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Attribute::Handlers</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">%name</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> name </span><span class="operator">{</span> <span class="keyword">return</span> <span class="variable">$name</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">2</span><span class="operator">]}</span><span class="operator">||</span><span class="variable">*</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]}{</span><span class="string">NAME</span><span class="operator">}</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> UNIVERSAL::Name :ATTR </span><span class="operator">{</span>
        <span class="variable">$name</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">2</span><span class="operator">]}</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">4</span><span class="operator">]</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> UNIVERSAL::Purpose :ATTR </span><span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">STDERR</span> <span class="string">"Purpose of "</span><span class="operator">,</span> <span class="operator">&amp;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" is </span><span class="variable">$_</span><span class="string">[4]\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> UNIVERSAL::Unit :ATTR </span><span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">STDERR</span> <span class="operator">&amp;</span><span class="variable">name</span><span class="operator">,</span> <span class="string">" measured in </span><span class="variable">$_</span><span class="string">[4]\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Let&#39;s you write:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Descriptions</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$capacity</span> <span class="operator">:</span> <span class="variable">Name</span><span class="operator">(</span><span class="variable">capacity</span><span class="operator">)</span>
                 <span class="operator">:</span> <span class="variable">Purpose</span><span class="operator">(</span><span class="variable">to</span> <span class="variable">store</span> <span class="variable">max</span> <span class="variable">storage</span> <span class="variable">capacity</span> <span class="keyword">for</span> <span class="variable">files</span><span class="operator">)</span>
                 <span class="operator">:</span> <span class="variable">Unit</span><span class="operator">(</span><span class="variable">Gb</span><span class="operator">);</span>
    
    
    <span class="keyword">package</span> <span class="variable">Other</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> foo : Purpose</span><span class="operator">(</span>to foo all data before barring it<span class="operator">)</span> <span class="operator">{</span> <span class="operator">}</span>
    
    <span class="comment"># etc.</span>
</code></code></pre>

<h1 id="UTILITY-FUNCTIONS">UTILITY FUNCTIONS</h1>

<p>This module offers a single utility function, <code><code>findsym()</code></code>.</p>

<dl>

<dt id="findsym">findsym</dt>
<dd>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$symbol</span> <span class="operator">=</span> <span class="variable">Attribute::Handlers::findsym</span><span class="operator">(</span><span class="variable">$package</span><span class="operator">,</span> <span class="variable">$referent</span><span class="operator">);</span>
</code></code></pre>

<p>The function looks in the symbol table of <code><code>$package</code></code> for the typeglob for <code><code>$referent</code></code>, which is a reference to a variable or subroutine (SCALAR, ARRAY, HASH, or CODE). If it finds the typeglob, it returns it. Otherwise, it returns undef. Note that <code><code>findsym</code></code> memoizes the typeglobs it has previously successfully found, so subsequent calls with the same arguments should be much faster.</p>

</dd>
</dl>

<h1 id="DIAGNOSTICS">DIAGNOSTICS</h1>

<dl>

<dt id="Bad-attribute-type:-ATTR-s-"><code><code>Bad attribute type: ATTR(%s)</code></code></dt>
<dd>

<p>An attribute handler was specified with an <code><code>:ATTR(</code><i><code>ref_type</code></i><code>)</code></code>, but the type of referent it was defined to handle wasn&#39;t one of the five permitted: <code><code>SCALAR</code></code>, <code><code>ARRAY</code></code>, <code><code>HASH</code></code>, <code><code>CODE</code></code>, or <code><code>ANY</code></code>.</p>

</dd>
<dt id="Attribute-handler-s-doesnt-handle-s-attributes"><code><code>Attribute handler %s doesn&#39;t handle %s attributes</code></code></dt>
<dd>

<p>A handler for attributes of the specified name <i>was</i> defined, but not for the specified type of declaration. Typically encountered whe trying to apply a <code><code>VAR</code></code> attribute handler to a subroutine, or a <code><code>SCALAR</code></code> attribute handler to some other type of variable.</p>

</dd>
<dt id="Declaration-of-s-attribute-in-package-s-may-clash-with-future-reserved-word"><code><code>Declaration of %s attribute in package %s may clash with future reserved word</code></code></dt>
<dd>

<p>A handler for an attributes with an all-lowercase name was declared. An attribute with an all-lowercase name might have a meaning to Perl itself some day, even though most don&#39;t yet. Use a mixed-case attribute name, instead.</p>

</dd>
<dt id="Cant-have-two-ATTR-specifiers-on-one-subroutine"><code><code>Can&#39;t have two ATTR specifiers on one subroutine</code></code></dt>
<dd>

<p>You just can&#39;t, okay? Instead, put all the specifications together with commas between them in a single <code><code>ATTR(</code><i><code>specification</code></i><code>)</code></code>.</p>

</dd>
<dt id="Cant-autotie-a-s"><code><code>Can&#39;t autotie a %s</code></code></dt>
<dd>

<p>You can only declare autoties for types <code><code>&quot;SCALAR&quot;</code></code>, <code><code>&quot;ARRAY&quot;</code></code>, and <code><code>&quot;HASH&quot;</code></code>. They&#39;re the only things (apart from typeglobs -- which are not declarable) that Perl can tie.</p>

</dd>
<dt id="Internal-error:-s-symbol-went-missing"><code><code>Internal error: %s symbol went missing</code></code></dt>
<dd>

<p>Something is rotten in the state of the program. An attributed subroutine ceased to exist between the point it was declared and the point at which its attribute handler(s) would have been called.</p>

</dd>
<dt id="Wont-be-able-to-apply-END-handler"><code><code>Won&#39;t be able to apply END handler</code></code></dt>
<dd>

<p>You have defined an END handler for an attribute that is being applied to a lexical variable. Since the variable may not be available during END this won&#39;t happen.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Damian Conway (damian@conway.org). The maintainer of this module is now Rafael Garcia-Suarez (rgarciasuarez@gmail.com).</p>

<p>Maintainer of the CPAN release is Steffen Mueller (smueller@cpan.org). Contact him with technical difficulties with respect to the packaging of the CPAN module.</p>

<h1 id="BUGS">BUGS</h1>

<p>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<pre><code><code>         Copyright (c) 2001-2009, Damian Conway. All Rights Reserved.
       This module is free software. It may be used, redistributed
           and/or modified under the same terms as Perl itself.</code></code></pre>


</body>

</html>


