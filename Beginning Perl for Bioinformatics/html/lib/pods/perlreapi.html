<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#Callbacks">Callbacks</a>
    <ul>
      <li><a href="#comp">comp</a></li>
      <li><a href="#exec">exec</a></li>
      <li><a href="#intuit">intuit</a></li>
      <li><a href="#checkstr">checkstr</a></li>
      <li><a href="#free">free</a></li>
      <li><a href="#Numbered-capture-callbacks">Numbered capture callbacks</a>
        <ul>
          <li><a href="#numbered_buff_FETCH">numbered_buff_FETCH</a></li>
          <li><a href="#numbered_buff_STORE">numbered_buff_STORE</a></li>
          <li><a href="#numbered_buff_LENGTH">numbered_buff_LENGTH</a></li>
        </ul>
      </li>
      <li><a href="#Named-capture-callbacks">Named capture callbacks</a>
        <ul>
          <li><a href="#named_buff">named_buff</a></li>
          <li><a href="#named_buff_iter">named_buff_iter</a></li>
        </ul>
      </li>
      <li><a href="#qr_package">qr_package</a></li>
      <li><a href="#dupe">dupe</a></li>
    </ul>
  </li>
  <li><a href="#The-REGEXP-structure">The REGEXP structure</a>
    <ul>
      <li><a href="#"></a></li>
      <li><a href="#1"></a></li>
      <li><a href="#2"></a></li>
      <li><a href="#3"> </a></li>
      <li><a href="#4"></a></li>
      <li><a href="#5"></a></li>
      <li><a href="#and">, , and </a></li>
      <li><a href="#6"></a></li>
      <li><a href="#7"></a></li>
      <li><a href="#8"></a></li>
      <li><a href="#9"></a></li>
      <li><a href="#10"> </a></li>
      <li><a href="#11"></a></li>
      <li><a href="#12"></a></li>
      <li><a href="#13">  </a></li>
      <li><a href="#14"> </a></li>
      <li><a href="#15"></a></li>
      <li><a href="#16"></a></li>
    </ul>
  </li>
  <li><a href="#HISTORY">HISTORY</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlreapi - perl regular expression plugin interface</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>As of Perl 5.9.5 there is a new interface for plugging and using other regular expression engines than the default one.</p>

<p>Each engine is supposed to provide access to a constant structure of the following format:</p>

<pre><code><code>    <span class="variable">typedef</span> <span class="variable">struct</span> <span class="variable">regexp_engine</span> <span class="operator">{</span>
        <span class="variable">REGEXP</span><span class="operator">*</span> <span class="operator">(</span><span class="variable">*comp</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">pattern</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
        <span class="variable">I32</span>     <span class="operator">(</span><span class="variable">*exec</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">stringarg</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">strend</span><span class="operator">,</span>
                         <span class="variable">char</span><span class="operator">*</span> <span class="variable">strbeg</span><span class="operator">,</span> <span class="variable">I32</span> <span class="variable">minend</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">screamer</span><span class="operator">,</span>
                         <span class="variable">void</span><span class="operator">*</span> <span class="variable">data</span><span class="operator">,</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
        <span class="variable">char</span><span class="operator">*</span>   <span class="operator">(</span><span class="variable">*intuit</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*sv</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*strpos</span><span class="operator">,</span>
                           <span class="variable">char</span> <span class="variable">*strend</span><span class="operator">,</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">,</span>
                           <span class="variable">struct</span> <span class="variable">re_scream_pos_data_s</span> <span class="variable">*data</span><span class="operator">);</span>
        <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*checkstr</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
        <span class="variable">void</span>    <span class="operator">(</span><span class="variable">*free</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
        <span class="variable">void</span>    <span class="operator">(</span><span class="variable">*numbered_buff_FETCH</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">,</span>
                                 <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">sv</span><span class="operator">);</span>
        <span class="variable">void</span>    <span class="operator">(</span><span class="variable">*numbered_buff_STORE</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">,</span>
                                       <span class="variable">SV</span> <span class="variable">const</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">value</span><span class="operator">);</span>
        <span class="variable">I32</span>     <span class="operator">(</span><span class="variable">*numbered_buff_LENGTH</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">sv</span><span class="operator">,</span>
                                        <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">);</span>
        <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*named_buff</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">key</span><span class="operator">,</span>
                               <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">value</span><span class="operator">,</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
        <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*named_buff_iter</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">lastkey</span><span class="operator">,</span>
                                    <span class="variable">const</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
        <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*qr_package</span><span class="operator">)(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
    <span class="comment">#ifdef USE_ITHREADS</span>
        <span class="variable">void</span><span class="operator">*</span>   <span class="operator">(</span><span class="variable">*dupe</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">CLONE_PARAMS</span> <span class="variable">*param</span><span class="operator">);</span>
    <span class="comment">#endif</span>
</code></code></pre>

<p>When a regexp is compiled, its <code><code>engine</code></code> field is then set to point at the appropriate structure, so that when it needs to be used Perl can find the right routines to do so.</p>

<p>In order to install a new regexp handler, <code><code><span class="variable">$^H</span><span class="operator">{</span><span class="variable">regcomp</span><span class="operator">}</span>
</code></code> is set to an integer which (when casted appropriately) resolves to one of these structures. When compiling, the <code><code>comp</code></code> method is executed, and the resulting regexp structure&#39;s engine field is expected to point back at the same structure.</p>

<p>The pTHX_ symbol in the definition is a macro used by perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</p>

<h1 id="Callbacks">Callbacks</h1>

<h2 id="comp">comp</h2>

<pre><code><code>    <span class="variable">REGEXP</span><span class="operator">*</span> <span class="variable">comp</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">pattern</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
</code></code></pre>

<p>Compile the pattern stored in <code><code>pattern</code></code> using the given <code><code>flags</code></code> and return a pointer to a prepared <code><code>REGEXP</code></code> structure that can perform the match. See <a href="#The-REGEXP-structure">&quot;The REGEXP structure&quot;</a> below for an explanation of the individual fields in the REGEXP struct.</p>

<p>The <code><code>pattern</code></code> parameter is the scalar that was used as the pattern. previous versions of perl would pass two <code><code>char*</code></code> indicating the start and end of the stringified pattern, the following snippet can be used to get the old parameters:</p>

<pre><code><code>    <span class="variable">STRLEN</span> <span class="variable">plen</span><span class="operator">;</span>
    <span class="variable">char</span><span class="operator">*</span>  <span class="keyword">exp</span> <span class="operator">=</span> <span class="variable">SvPV</span><span class="operator">(</span><span class="variable">pattern</span><span class="operator">,</span> <span class="variable">plen</span><span class="operator">);</span>
    <span class="variable">char</span><span class="operator">*</span> <span class="variable">xend</span> <span class="operator">=</span> <span class="keyword">exp</span> <span class="operator">+</span> <span class="variable">plen</span><span class="operator">;</span>
</code></code></pre>

<p>Since any scalar can be passed as a pattern it&#39;s possible to implement an engine that does something with an array (<code><code>&quot;ook&quot; =~ [ qw/ eek hlagh / ]</code></code>) or with the non-stringified form of a compiled regular expression (<code><code>&quot;ook&quot; =~ qr/eek/</code></code>). perl&#39;s own engine will always stringify everything using the snippet above but that doesn&#39;t mean other engines have to.</p>

<p>The <code><code>flags</code></code> parameter is a bitfield which indicates which of the <code><code>msixp</code></code> flags the regex was compiled with. It also contains additional info such as whether <code><code>use locale</code></code> is in effect.</p>

<p>The <code><code>eogc</code></code> flags are stripped out before being passed to the comp routine. The regex engine does not need to know whether any of these are set as those flags should only affect what perl does with the pattern and its match variables, not how it gets compiled and executed.</p>

<p>By the time the comp callback is called, some of these flags have already had effect (noted below where applicable). However most of their effect occurs after the comp callback has run in routines that read the <code><code>rx-&gt;extflags</code></code> field which it populates.</p>

<p>In general the flags should be preserved in <code><code>rx-&gt;extflags</code></code> after compilation, although the regex engine might want to add or delete some of them to invoke or disable some special behavior in perl. The flags along with any special behavior they cause are documented below:</p>

<p>The pattern modifiers:</p>

<dl>

<dt id="m---RXf_PMf_MULTILINE"><code><code>/m</code></code> - RXf_PMf_MULTILINE</dt>
<dd>

<p>If this is in <code><code>rx-&gt;extflags</code></code> it will be passed to <code><code>Perl_fbm_instr</code></code> by <code><code>pp_split</code></code> which will treat the subject string as a multi-line string.</p>

</dd>
<dt id="s---RXf_PMf_SINGLELINE"><code><code>/s</code></code> - RXf_PMf_SINGLELINE</dt>
<dd>

</dd>
<dt id="i---RXf_PMf_FOLD"><code><code>/i</code></code> - RXf_PMf_FOLD</dt>
<dd>

</dd>
<dt id="x---RXf_PMf_EXTENDED"><code><code>/x</code></code> - RXf_PMf_EXTENDED</dt>
<dd>

<p>If present on a regex <code><code><span class="comment">#</span>
</code></code> comments will be handled differently by the tokenizer in some cases.</p>

<p>TODO: Document those cases.</p>

</dd>
<dt id="p---RXf_PMf_KEEPCOPY"><code><code>/p</code></code> - RXf_PMf_KEEPCOPY</dt>
<dd>

<p>TODO: Document this</p>

</dd>
<dt id="Character-set">Character set</dt>
<dd>

<p>The character set semantics are determined by an enum that is contained in this field. This is still experimental and subject to change, but the current interface returns the rules by use of the in-line function <code><code>get_regex_charset(const U32 flags)</code></code>. The only currently documented value returned from it is REGEX_LOCALE_CHARSET, which is set if <code><code>use locale</code></code> is in effect. If present in <code><code>rx-&gt;extflags</code></code>, <code><code>split</code></code> will use the locale dependent definition of whitespace when RXf_SKIPWHITE or RXf_WHITE is in effect. ASCII whitespace is defined as per <a href="../../lib/pods/perlapi.html#isSPACE">isSPACE</a>, and by the internal macros <code><code>is_utf8_space</code></code> under UTF-8, and <code><code>isSPACE_LC</code></code> under <code><code>use locale</code></code>.</p>

</dd>
</dl>

<p>Additional flags:</p>

<dl>

<dt id="RXf_UTF8">RXf_UTF8</dt>
<dd>

<p>Set if the pattern is <a href="../../lib/pods/perlapi.html#SvUTF8">SvUTF8()</a>, set by Perl_pmruntime.</p>

<p>A regex engine may want to set or disable this flag during compilation. The perl engine for instance may upgrade non-UTF-8 strings to UTF-8 if the pattern includes constructs such as <code><code><span class="operator">\x</span><span class="operator">{</span><span class="operator">...</span><span class="operator">}</span>
</code></code> that can only match Unicode values.</p>

</dd>
<dt id="RXf_SPLIT">RXf_SPLIT</dt>
<dd>

<p>If <code><code>split</code></code> is invoked as <code><code>split &#39; &#39;</code></code> or with no arguments (which really means <code><code>split(&#39; &#39;, $_)</code></code>, see <a href="../../lib/pods/perlfunc.html#split">split</a>), perl will set this flag. The regex engine can then check for it and set the SKIPWHITE and WHITE extflags. To do this the perl engine does:</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">flags</span> <span class="operator">&amp;</span> <span class="variable">RXf_SPLIT</span> <span class="operator">&amp;&amp;</span> <span class="variable">r</span><span class="operator">-&gt;</span><span class="variable">prelen</span> <span class="operator">==</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="variable">r</span><span class="operator">-&gt;</span><span class="variable">precomp</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">==</span> <span class="string">' '</span><span class="operator">)</span>
        <span class="variable">r</span><span class="operator">-&gt;</span><span class="variable">extflags</span> <span class="operator">|=</span> <span class="operator">(</span><span class="variable">RXf_SKIPWHITE</span><span class="operator">|</span><span class="variable">RXf_WHITE</span><span class="operator">);</span>
</code></code></pre>

</dd>
</dl>

<p>These flags can be set during compilation to enable optimizations in the <code><code>split</code></code> operator.</p>

<dl>

<dt id="RXf_SKIPWHITE">RXf_SKIPWHITE</dt>
<dd>

<p>If the flag is present in <code><code>rx-&gt;extflags</code></code> <code><code>split</code></code> will delete whitespace from the start of the subject string before it&#39;s operated on. What is considered whitespace depends on whether the subject is a UTF-8 string and whether the <code><code>RXf_PMf_LOCALE</code></code> flag is set.</p>

<p>If RXf_WHITE is set in addition to this flag <code><code>split</code></code> will behave like <code><code>split &quot; &quot;</code></code> under the perl engine.</p>

</dd>
<dt id="RXf_START_ONLY">RXf_START_ONLY</dt>
<dd>

<p>Tells the split operator to split the target string on newlines (<code><code>\n</code></code>) without invoking the regex engine.</p>

<p>Perl&#39;s engine sets this if the pattern is <code><code>/^/</code></code> (<code><code>plen == 1 &amp;&amp; *exp == &#39;^&#39;</code></code>), even under <code><code>/^/s</code></code>, see <a href="../../lib/pods/perlfunc.html">split</a>. Of course a different regex engine might want to use the same optimizations with a different syntax.</p>

</dd>
<dt id="RXf_WHITE">RXf_WHITE</dt>
<dd>

<p>Tells the split operator to split the target string on whitespace without invoking the regex engine. The definition of whitespace varies depending on whether the target string is a UTF-8 string and on whether RXf_PMf_LOCALE is set.</p>

<p>Perl&#39;s engine sets this flag if the pattern is <code><code>\s+</code></code>.</p>

</dd>
<dt id="RXf_NULL">RXf_NULL</dt>
<dd>

<p>Tells the split operator to split the target string on characters. The definition of character varies depending on whether the target string is a UTF-8 string.</p>

<p>Perl&#39;s engine sets this flag on empty patterns, this optimization makes <code><code>split //</code></code> much faster than it would otherwise be. It&#39;s even faster than <code><code>unpack</code></code>.</p>

</dd>
</dl>

<h2 id="exec">exec</h2>

<pre><code><code>    <span class="variable">I32</span> <span class="keyword">exec</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span>
             <span class="variable">char</span> <span class="variable">*stringarg</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">strend</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">strbeg</span><span class="operator">,</span>
             <span class="variable">I32</span> <span class="variable">minend</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">screamer</span><span class="operator">,</span>
             <span class="variable">void</span><span class="operator">*</span> <span class="variable">data</span><span class="operator">,</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
</code></code></pre>

<p>Execute a regexp.</p>

<h2 id="intuit">intuit</h2>

<pre><code><code>    <span class="variable">char</span><span class="operator">*</span> <span class="variable">intuit</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span>
                  <span class="variable">SV</span> <span class="variable">*sv</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*strpos</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*strend</span><span class="operator">,</span>
                  <span class="variable">const</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">,</span> <span class="variable">struct</span> <span class="variable">re_scream_pos_data_s</span> <span class="variable">*data</span><span class="operator">);</span>
</code></code></pre>

<p>Find the start position where a regex match should be attempted, or possibly whether the regex engine should not be run because the pattern can&#39;t match. This is called as appropriate by the core depending on the values of the extflags member of the regexp structure.</p>

<h2 id="checkstr">checkstr</h2>

<pre><code><code>    <span class="variable">SV</span><span class="operator">*</span> <span class="variable">checkstr</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
</code></code></pre>

<p>Return a SV containing a string that must appear in the pattern. Used by <code><code>split</code></code> for optimising matches.</p>

<h2 id="free">free</h2>

<pre><code><code>    <span class="variable">void</span> <span class="variable">free</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
</code></code></pre>

<p>Called by perl when it is freeing a regexp pattern so that the engine can release any resources pointed to by the <code><code>pprivate</code></code> member of the regexp structure. This is only responsible for freeing private data; perl will handle releasing anything else contained in the regexp structure.</p>

<h2 id="Numbered-capture-callbacks">Numbered capture callbacks</h2>

<p>Called to get/set the value of <code><code>$`</code></code>, <code><code>$&#39;</code></code>, <code><code>$&amp;</code></code> and their named equivalents, ${^PREMATCH}, ${^POSTMATCH} and $^{MATCH}, as well as the numbered capture groups (<code><code>$1</code></code>, <code><code>$2</code></code>, ...).</p>

<p>The <code><code>paren</code></code> parameter will be <code><code>-2</code></code> for <code><code>$`</code></code>, <code><code>-1</code></code> for <code><code>$&#39;</code></code>, <code><code>0</code></code> for <code><code>$&amp;</code></code>, <code><code>1</code></code> for <code><code>$1</code></code> and so forth.</p>

<p>The names have been chosen by analogy with <a href="../../lib/Tie/Scalar.html">Tie::Scalar</a> methods names with an additional <b>LENGTH</b> callback for efficiency. However named capture variables are currently not tied internally but implemented via magic.</p>

<h3 id="numbered_buff_FETCH">numbered_buff_FETCH</h3>

<pre><code><code>    <span class="variable">void</span> <span class="variable">numbered_buff_FETCH</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">,</span>
                             <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">sv</span><span class="operator">);</span>
</code></code></pre>

<p>Fetch a specified numbered capture. <code><code>sv</code></code> should be set to the scalar to return, the scalar is passed as an argument rather than being returned from the function because when it&#39;s called perl already has a scalar to store the value, creating another one would be redundant. The scalar can be set with <code><code>sv_setsv</code></code>, <code><code>sv_setpvn</code></code> and friends, see <a href="../../lib/pods/perlapi.html">perlapi</a>.</p>

<p>This callback is where perl untaints its own capture variables under taint mode (see <a href="../../lib/pods/perlsec.html">perlsec</a>). See the <code><code>Perl_reg_numbered_buff_fetch</code></code> function in <i>regcomp.c</i> for how to untaint capture variables if that&#39;s something you&#39;d like your engine to do as well.</p>

<h3 id="numbered_buff_STORE">numbered_buff_STORE</h3>

<pre><code><code>    <span class="variable">void</span>    <span class="operator">(</span><span class="variable">*numbered_buff_STORE</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">,</span>
                                    <span class="variable">SV</span> <span class="variable">const</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">value</span><span class="operator">);</span>
</code></code></pre>

<p>Set the value of a numbered capture variable. <code><code>value</code></code> is the scalar that is to be used as the new value. It&#39;s up to the engine to make sure this is used as the new value (or reject it).</p>

<p>Example:</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">(</span><span class="string">"ook"</span> <span class="operator">=~</span> <span class="regex">/(o*)/</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="comment"># 'paren' will be '1' and 'value' will be 'ee'</span>
        <span class="variable">$1</span> <span class="operator">=~</span> <span class="regex">tr/o/e/</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Perl&#39;s own engine will croak on any attempt to modify the capture variables, to do this in another engine use the following callback (copied from <code><code>Perl_reg_numbered_buff_store</code></code>):</p>

<pre><code><code>    <span class="variable">void</span>
    <span class="variable">Example_reg_numbered_buff_store</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">,</span>
                                                            <span class="variable">SV</span> <span class="variable">const</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">value</span><span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">PERL_UNUSED_ARG</span><span class="operator">(</span><span class="variable">rx</span><span class="operator">);</span>
        <span class="variable">PERL_UNUSED_ARG</span><span class="operator">(</span><span class="variable">paren</span><span class="operator">);</span>
        <span class="variable">PERL_UNUSED_ARG</span><span class="operator">(</span><span class="variable">value</span><span class="operator">);</span>
    
        <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">PL_localizing</span><span class="operator">)</span>
            <span class="variable">Perl_croak</span><span class="operator">(</span><span class="variable">aTHX_</span> <span class="variable">PL_no_modify</span><span class="operator">);</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Actually perl will not <i>always</i> croak in a statement that looks like it would modify a numbered capture variable. This is because the STORE callback will not be called if perl can determine that it doesn&#39;t have to modify the value. This is exactly how tied variables behave in the same situation:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">CaptureVar</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">base</span> <span class="string">'Tie::Scalar'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> TIESCALAR </span><span class="operator">{</span> <span class="keyword">bless</span> <span class="operator">[]</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> FETCH </span><span class="operator">{</span> <span class="keyword">undef</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> STORE </span><span class="operator">{</span> <span class="keyword">die</span> <span class="string">"This doesn't get called"</span> <span class="operator">}</span>
    
    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    
    <span class="keyword">tie</span> <span class="keyword">my</span> <span class="variable">$sv</span> <span class="operator">=&gt;</span> <span class="string">"CaptureVar"</span><span class="operator">;</span>
    <span class="variable">$sv</span> <span class="operator">=~</span> <span class="regex">y/a/b/</span><span class="operator">;</span>
</code></code></pre>

<p>Because <code><code>$sv</code></code> is <code><code>undef</code></code> when the <code><code>y///</code></code> operator is applied to it the transliteration won&#39;t actually execute and the program won&#39;t <code><code>die</code></code>. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then, now they&#39;ll just die when assigned to in the default engine.</p>

<h3 id="numbered_buff_LENGTH">numbered_buff_LENGTH</h3>

<pre><code><code>    <span class="variable">I32</span> <span class="variable">numbered_buff_LENGTH</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">sv</span><span class="operator">,</span>
                              <span class="variable">const</span> <span class="variable">I32</span> <span class="variable">paren</span><span class="operator">);</span>
</code></code></pre>

<p>Get the <code><code>length</code></code> of a capture variable. There&#39;s a special callback for this so that perl doesn&#39;t have to do a FETCH and run <code><code>length</code></code> on the result, since the length is (in perl&#39;s case) known from an offset stored in <code><code>rx-&gt;offs</code></code> this is much more efficient:</p>

<pre><code><code>    <span class="variable">I32</span> <span class="variable">s1</span>  <span class="operator">=</span> <span class="variable">rx</span><span class="operator">-&gt;</span><span class="variable">offs</span><span class="operator">[</span><span class="variable">paren</span><span class="operator">]</span><span class="operator">.</span><span class="variable">start</span><span class="operator">;</span>
    <span class="variable">I32</span> <span class="variable">s2</span>  <span class="operator">=</span> <span class="variable">rx</span><span class="operator">-&gt;</span><span class="variable">offs</span><span class="operator">[</span><span class="variable">paren</span><span class="operator">]</span><span class="operator">.</span><span class="variable">end</span><span class="operator">;</span>
    <span class="variable">I32</span> <span class="variable">len</span> <span class="operator">=</span> <span class="variable">t1</span> <span class="operator">-</span> <span class="variable">s1</span><span class="operator">;</span>
</code></code></pre>

<p>This is a little bit more complex in the case of UTF-8, see what <code><code>Perl_reg_numbered_buff_length</code></code> does with <a href="../../lib/pods/perlapi.html#is_utf8_string_loclen">is_utf8_string_loclen</a>.</p>

<h2 id="Named-capture-callbacks">Named capture callbacks</h2>

<p>Called to get/set the value of <code><code>%+</code></code> and <code><code>%-</code></code> as well as by some utility functions in <a href="../../lib/re.html">re</a>.</p>

<p>There are two callbacks, <code><code>named_buff</code></code> is called in all the cases the FETCH, STORE, DELETE, CLEAR, EXISTS and SCALAR <a href="../../lib/Tie/Hash.html">Tie::Hash</a> callbacks would be on changes to <code><code>%+</code></code> and <code><code>%-</code></code> and <code><code>named_buff_iter</code></code> in the same cases as FIRSTKEY and NEXTKEY.</p>

<p>The <code><code>flags</code></code> parameter can be used to determine which of these operations the callbacks should respond to, the following flags are currently defined:</p>

<p>Which <a href="../../lib/Tie/Hash.html">Tie::Hash</a> operation is being performed from the Perl level on <code><code>%+</code></code> or <code><code>%+</code></code>, if any:</p>

<pre><code><code>    RXapif_FETCH
    RXapif_STORE
    RXapif_DELETE
    RXapif_CLEAR
    RXapif_EXISTS
    RXapif_SCALAR
    RXapif_FIRSTKEY
    RXapif_NEXTKEY</code></code></pre>

<p>Whether <code><code>%+</code></code> or <code><code>%-</code></code> is being operated on, if any.</p>

<pre><code><code>    RXapif_ONE /* %+ */
    RXapif_ALL /* %- */</code></code></pre>

<p>Whether this is being called as <code><code>re::regname</code></code>, <code><code>re::regnames</code></code> or <code><code>re::regnames_count</code></code>, if any. The first two will be combined with <code><code>RXapif_ONE</code></code> or <code><code>RXapif_ALL</code></code>.</p>

<pre><code><code>    RXapif_REGNAME
    RXapif_REGNAMES
    RXapif_REGNAMES_COUNT</code></code></pre>

<p>Internally <code><code>%+</code></code> and <code><code>%-</code></code> are implemented with a real tied interface via <a href="../../lib/Tie/Hash/NamedCapture.html">Tie::Hash::NamedCapture</a>. The methods in that package will call back into these functions. However the usage of <a href="../../lib/Tie/Hash/NamedCapture.html">Tie::Hash::NamedCapture</a> for this purpose might change in future releases. For instance this might be implemented by magic instead (would need an extension to mgvtbl).</p>

<h3 id="named_buff">named_buff</h3>

<pre><code><code>    <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*named_buff</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">key</span><span class="operator">,</span>
                           <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">value</span><span class="operator">,</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
</code></code></pre>

<h3 id="named_buff_iter">named_buff_iter</h3>

<pre><code><code>    <span class="variable">SV</span><span class="operator">*</span>     <span class="operator">(</span><span class="variable">*named_buff_iter</span><span class="operator">)</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">SV</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">lastkey</span><span class="operator">,</span>
                                <span class="variable">const</span> <span class="variable">U32</span> <span class="variable">flags</span><span class="operator">);</span>
</code></code></pre>

<h2 id="qr_package">qr_package</h2>

<pre><code><code>    <span class="variable">SV</span><span class="operator">*</span> <span class="variable">qr_package</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">);</span>
</code></code></pre>

<p>The package the qr// magic object is blessed into (as seen by <code><code>ref qr//</code></code>). It is recommended that engines change this to their package name for identification regardless of whether they implement methods on the object.</p>

<p>The package this method returns should also have the internal <code><code>Regexp</code></code> package in its <code><code>@ISA</code></code>. <code><code>qr//-&gt;isa(&quot;Regexp&quot;)</code></code> should always be true regardless of what engine is being used.</p>

<p>Example implementation might be:</p>

<pre><code><code>    <span class="variable">SV</span><span class="operator">*</span>
    <span class="variable">Example_qr_package</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">PERL_UNUSED_ARG</span><span class="operator">(</span><span class="variable">rx</span><span class="operator">);</span>
        <span class="keyword">return</span> <span class="variable">newSVpvs</span><span class="operator">(</span><span class="string">"re::engine::Example"</span><span class="operator">);</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Any method calls on an object created with <code><code>qr//</code></code> will be dispatched to the package as a normal object.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">re::engine::Example</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$re</span> <span class="operator">=</span> <span class="string">qr//</span><span class="operator">;</span>
    <span class="variable">$re</span><span class="operator">-&gt;</span><span class="variable">meth</span><span class="operator">;</span> <span class="comment"># dispatched to re::engine::Example::meth()</span>
</code></code></pre>

<p>To retrieve the <code><code>REGEXP</code></code> object from the scalar in an XS function use the <code><code>SvRX</code></code> macro, see <a href="../../lib/pods/perlapi.html#REGEXP-Functions">&quot;REGEXP Functions&quot; in perlapi</a>.</p>

<pre><code><code>    <span class="variable">void</span> <span class="variable">meth</span><span class="operator">(</span><span class="variable">SV</span> <span class="operator">*</span> <span class="variable">rv</span><span class="operator">)</span>
    <span class="variable">PPCODE</span><span class="operator">:</span>
        <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">re</span> <span class="operator">=</span> <span class="variable">SvRX</span><span class="operator">(</span><span class="variable">sv</span><span class="operator">);</span>
</code></code></pre>

<h2 id="dupe">dupe</h2>

<pre><code><code>    <span class="variable">void</span><span class="operator">*</span> <span class="variable">dupe</span><span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">REGEXP</span> <span class="operator">*</span> <span class="variable">const</span> <span class="variable">rx</span><span class="operator">,</span> <span class="variable">CLONE_PARAMS</span> <span class="variable">*param</span><span class="operator">);</span>
</code></code></pre>

<p>On threaded builds a regexp may need to be duplicated so that the pattern can be used by multiple threads. This routine is expected to handle the duplication of any private data pointed to by the <code><code>pprivate</code></code> member of the regexp structure. It will be called with the preconstructed new regexp structure as an argument, the <code><code>pprivate</code></code> member will point at the <b>old</b> private structure, and it is this routine&#39;s responsibility to construct a copy and return a pointer to it (which perl will then use to overwrite the field as passed to this routine.)</p>

<p>This allows the engine to dupe its private data but also if necessary modify the final structure if it really must.</p>

<p>On unthreaded builds this field doesn&#39;t exist.</p>

<h1 id="The-REGEXP-structure">The REGEXP structure</h1>

<p>The REGEXP struct is defined in <i>regexp.h</i>. All regex engines must be able to correctly build such a structure in their <a href="#comp">&quot;comp&quot;</a> routine.</p>

<p>The REGEXP structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</p>

<p>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the <code><code>intflags</code></code> and <code><code>pprivate</code></code> members. <code><code>pprivate</code></code> is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</p>

<pre><code><code>    <span class="variable">typedef</span> <span class="variable">struct</span> <span class="variable">regexp</span> <span class="operator">{</span>
        <span class="regex">/* what engine created this regexp? */</span>
        <span class="variable">const</span> <span class="variable">struct</span> <span class="variable">regexp_engine</span><span class="operator">*</span> <span class="variable">engine</span><span class="operator">;</span>
    
        <span class="regex">/* what re is this a lightweight copy of? */</span>
        <span class="variable">struct</span> <span class="variable">regexp</span><span class="operator">*</span> <span class="variable">mother_re</span><span class="operator">;</span>
    
        <span class="regex">/* Information about the match that the perl core uses to manage things */</span>
        <span class="variable">U32</span> <span class="variable">extflags</span><span class="operator">;</span>   <span class="regex">/* Flags used both externally and internally */</span>
        <span class="variable">I32</span> <span class="variable">minlen</span><span class="operator">;</span>     <span class="regex">/* mininum possible length of string to match */</span>
        <span class="variable">I32</span> <span class="variable">minlenret</span><span class="operator">;</span>  <span class="regex">/* mininum possible length of $&amp; */</span>
        <span class="variable">U32</span> <span class="variable">gofs</span><span class="operator">;</span>       <span class="regex">/* chars left of pos that we search from */</span>
    
        <span class="operator">/*</span> <span class="variable">substring</span> <span class="variable">data</span> <span class="variable">about</span> <span class="variable">strings</span> <span class="variable">that</span> <span class="variable">must</span> <span class="variable">appear</span>
           <span class="variable">in</span> <span class="variable">the</span> <span class="variable">final</span> <span class="variable">match</span><span class="operator">,</span> <span class="variable">used</span> <span class="keyword">for</span> <span class="variable">optimisations</span> <span class="operator">*/</span>
        <span class="variable">struct</span> <span class="variable">reg_substr_data</span> <span class="variable">*substrs</span><span class="operator">;</span>
    
        <span class="variable">U32</span> <span class="variable">nparens</span><span class="operator">;</span>  <span class="regex">/* number of capture groups */</span>
    
        <span class="operator">/*</span> <span class="variable">private</span> <span class="variable">engine</span> <span class="variable">specific</span> <span class="variable">data</span> <span class="operator">*/</span>
        <span class="variable">U32</span> <span class="variable">intflags</span><span class="operator">;</span>   <span class="regex">/* Engine Specific Internal flags */</span>
        <span class="variable">void</span> <span class="variable">*pprivate</span><span class="operator">;</span> <span class="regex">/* Data private to the regex engine which 
                           created this object. */</span>
    
        <span class="operator">/*</span> <span class="variable">Data</span> <span class="variable">about</span> <span class="variable">the</span> <span class="keyword">last</span><span class="operator">/</span><span class="variable">current</span> <span class="variable">match</span><span class="operator">.</span> <span class="variable">These</span> <span class="variable">are</span> <span class="variable">modified</span> <span class="variable">during</span> <span class="variable">matching</span><span class="operator">*/</span>
        <span class="variable">U32</span> <span class="variable">lastparen</span><span class="operator">;</span>            <span class="regex">/* last open paren matched */</span>
        <span class="variable">U32</span> <span class="variable">lastcloseparen</span><span class="operator">;</span>       <span class="regex">/* last close paren matched */</span>
        <span class="variable">regexp_paren_pair</span> <span class="variable">*swap</span><span class="operator">;</span>  <span class="regex">/* Swap copy of *offs */</span>
        <span class="variable">regexp_paren_pair</span> <span class="variable">*offs</span><span class="operator">;</span>  <span class="regex">/* Array of offsets for (@-) and (@+) */</span>
    
        <span class="variable">char</span> <span class="variable">*subbeg</span><span class="operator">;</span>  <span class="regex">/* saved or original string so \digit works forever. */</span>
        <span class="variable">SV_SAVED_COPY</span>  <span class="operator">/*</span> <span class="variable">If</span> <span class="variable">non</span><span class="operator">-</span><span class="variable">NULL</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">which</span> <span class="variable">is</span> <span class="variable">COW</span> <span class="variable">from</span> <span class="variable">original</span> <span class="operator">*/</span>
        <span class="variable">I32</span> <span class="variable">sublen</span><span class="operator">;</span>    <span class="regex">/* Length of string pointed by subbeg */</span>
    
        <span class="operator">/*</span> <span class="variable">Information</span> <span class="variable">about</span> <span class="variable">the</span> <span class="variable">match</span> <span class="variable">that</span> <span class="variable">isn't</span> <span class="variable">often</span> <span class="variable">used</span> <span class="operator">*/</span>
        <span class="variable">I32</span> <span class="variable">prelen</span><span class="operator">;</span>           <span class="regex">/* length of precomp */</span>
        <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*precomp</span><span class="operator">;</span>  <span class="regex">/* pre-compilation regular expression */</span>
    
        <span class="variable">char</span> <span class="variable">*wrapped</span><span class="operator">;</span>  <span class="regex">/* wrapped version of the pattern */</span>
        <span class="variable">I32</span> <span class="variable">wraplen</span><span class="operator">;</span>    <span class="regex">/* length of wrapped */</span>
    
        <span class="variable">I32</span> <span class="variable">seen_evals</span><span class="operator">;</span>   <span class="regex">/* number of eval groups in the pattern - for security checks */</span>
        <span class="variable">HV</span> <span class="variable">*paren_names</span><span class="operator">;</span>  <span class="regex">/* Optional hash of paren names */</span>
    
        <span class="operator">/*</span> <span class="variable">Refcount</span> <span class="variable">of</span> <span class="variable">this</span> <span class="variable">regexp</span> <span class="operator">*/</span>
        <span class="variable">I32</span> <span class="variable">refcnt</span><span class="operator">;</span>             <span class="regex">/* Refcount of this regexp */</span>
    <span class="operator">}</span> <span class="variable">regexp</span><span class="operator">;</span>
</code></code></pre>

<p>The fields are discussed in more detail below:</p>

<h2 id=""><code><code>engine</code></code></h2>

<p>This field points at a regexp_engine structure which contains pointers to the subroutines that are to be used for performing a match. It is the compiling routine&#39;s responsibility to populate this field before returning the regexp object.</p>

<p>Internally this is set to <code><code>NULL</code></code> unless a custom engine is specified in <code><code><span class="variable">$^H</span><span class="operator">{</span><span class="variable">regcomp</span><span class="operator">}</span>
</code></code>, perl&#39;s own set of callbacks can be accessed in the struct pointed to by <code><code>RE_ENGINE_PTR</code></code>.</p>

<h2 id="1"><code><code>mother_re</code></code></h2>

<p>TODO, see <a href="http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html">http://www.mail-archive.com/perl5-changes@perl.org/msg17328.html</a></p>

<h2 id="2"><code><code>extflags</code></code></h2>

<p>This will be used by perl to see what flags the regexp was compiled with, this will normally be set to the value of the flags parameter by the <a href="#comp">comp</a> callback. See the <a href="#comp">comp</a> documentation for valid flags.</p>

<h2 id="3"><code><code>minlen</code></code> <code><code>minlenret</code></code></h2>

<p>The minimum string length required for the pattern to match. This is used to prune the search space by not bothering to match any closer to the end of a string than would allow a match. For instance there is no point in even starting the regex engine if the minlen is 10 but the string is only 5 characters long. There is no way that the pattern can match.</p>

<p><code><code>minlenret</code></code> is the minimum length of the string that would be found in $&amp; after a match.</p>

<p>The difference between <code><code>minlen</code></code> and <code><code>minlenret</code></code> can be seen in the following pattern:</p>

<pre><code><code>    /ns(?=\d)/</code></code></pre>

<p>where the <code><code>minlen</code></code> would be 3 but <code><code>minlenret</code></code> would only be 2 as the \d is required to match but is not actually included in the matched content. This distinction is particularly important as the substitution logic uses the <code><code>minlenret</code></code> to tell whether it can do in-place substitution which can result in considerable speedup.</p>

<h2 id="4"><code><code>gofs</code></code></h2>

<p>Left offset from pos() to start match at.</p>

<h2 id="5"><code><code>substrs</code></code></h2>

<p>Substring data about strings that must appear in the final match. This is currently only used internally by perl&#39;s engine for but might be used in the future for all engines for optimisations.</p>

<h2 id="and"><code><code>nparens</code></code>, <code><code>lastparen</code></code>, and <code><code>lastcloseparen</code></code></h2>

<p>These fields are used to keep track of how many paren groups could be matched in the pattern, which was the last open paren to be entered, and which was the last close paren to be entered.</p>

<h2 id="6"><code><code>intflags</code></code></h2>

<p>The engine&#39;s private copy of the flags the pattern was compiled with. Usually this is the same as <code><code>extflags</code></code> unless the engine chose to modify one of them.</p>

<h2 id="7"><code><code>pprivate</code></code></h2>

<p>A void* pointing to an engine-defined data structure. The perl engine uses the <code><code>regexp_internal</code></code> structure (see <a href="../../lib/pods/perlreguts.html#Base-Structures">&quot;Base Structures&quot; in perlreguts</a>) but a custom engine should use something else.</p>

<h2 id="8"><code><code>swap</code></code></h2>

<p>Unused. Left in for compatibility with perl 5.10.0.</p>

<h2 id="9"><code><code>offs</code></code></h2>

<p>A <code><code>regexp_paren_pair</code></code> structure which defines offsets into the string being matched which correspond to the <code><code>$&amp;</code></code> and <code><code>$1</code></code>, <code><code>$2</code></code> etc. captures, the <code><code>regexp_paren_pair</code></code> struct is defined as follows:</p>

<pre><code><code>    <span class="variable">typedef</span> <span class="variable">struct</span> <span class="variable">regexp_paren_pair</span> <span class="operator">{</span>
        <span class="variable">I32</span> <span class="variable">start</span><span class="operator">;</span>
        <span class="variable">I32</span> <span class="variable">end</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="variable">regexp_paren_pair</span><span class="operator">;</span>
</code></code></pre>

<p>If <code><code>-&gt;offs[num].start</code></code> or <code><code>-&gt;offs[num].end</code></code> is <code><code>-1</code></code> then that capture group did not match. <code><code>-&gt;offs[0].start/end</code></code> represents <code><code>$&amp;</code></code> (or <code><code><span class="operator">${^</span><span class="variable">MATCH</span>
</code></code> under <code><code>//p</code></code>) and <code><code>-&gt;offs[paren].end</code></code> matches <code><code>$$paren</code></code> where <code><code>$paren </code></code>= 1&gt;.</p>

<h2 id="10"><code><code>precomp</code></code> <code><code>prelen</code></code></h2>

<p>Used for optimisations. <code><code>precomp</code></code> holds a copy of the pattern that was compiled and <code><code>prelen</code></code> its length. When a new pattern is to be compiled (such as inside a loop) the internal <code><code>regcomp</code></code> operator checks whether the last compiled <code><code>REGEXP</code></code>&#39;s <code><code>precomp</code></code> and <code><code>prelen</code></code> are equivalent to the new one, and if so uses the old pattern instead of compiling a new one.</p>

<p>The relevant snippet from <code><code>Perl_pp_regcomp</code></code>:</p>

<pre><code><code>        if (!re || !re-&gt;precomp || re-&gt;prelen != (I32)len ||
            memNE(re-&gt;precomp, t, len))
        /* Compile a new pattern */</code></code></pre>

<h2 id="11"><code><code>paren_names</code></code></h2>

<p>This is a hash used internally to track named capture groups and their offsets. The keys are the names of the buffers the values are dualvars, with the IV slot holding the number of buffers with the given name and the pv being an embedded array of I32. The values may also be contained independently in the data array in cases where named backreferences are used.</p>

<h2 id="12"><code><code>substrs</code></code></h2>

<p>Holds information on the longest string that must occur at a fixed offset from the start of the pattern, and the longest string that must occur at a floating offset from the start of the pattern. Used to do Fast-Boyer-Moore searches on the string to find out if its worth using the regex engine at all, and if so where in the string to search.</p>

<h2 id="13"><code><code>subbeg</code></code> <code><code>sublen</code></code> <code><code>saved_copy</code></code></h2>

<p>Used during execution phase for managing search and replace patterns.</p>

<h2 id="14"><code><code>wrapped</code></code> <code><code>wraplen</code></code></h2>

<p>Stores the string <code><code>qr//</code></code> stringifies to. The perl engine for example stores <code><code>(?^:eek)</code></code> in the case of <code><code>qr/eek/</code></code>.</p>

<p>When using a custom engine that doesn&#39;t support the <code><code>(?:)</code></code> construct for inline modifiers, it&#39;s probably best to have <code><code>qr//</code></code> stringify to the supplied pattern, note that this will create undesired patterns in cases such as:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="string">qr/a|b/</span><span class="operator">;</span>  <span class="comment"># "a|b"</span>
    <span class="keyword">my</span> <span class="variable">$y</span> <span class="operator">=</span> <span class="string">qr/c/i</span><span class="operator">;</span>   <span class="comment"># "c"</span>
    <span class="keyword">my</span> <span class="variable">$z</span> <span class="operator">=</span> <span class="string">qr/</span><span class="variable">$x$y</span><span class="string">/</span><span class="operator">;</span> <span class="comment"># "a|bc"</span>
</code></code></pre>

<p>There&#39;s no solution for this problem other than making the custom engine understand a construct like <code><code>(?:)</code></code>.</p>

<h2 id="15"><code><code>seen_evals</code></code></h2>

<p>This stores the number of eval groups in the pattern. This is used for security purposes when embedding compiled regexes into larger patterns with <code><code>qr//</code></code>.</p>

<h2 id="16"><code><code>refcnt</code></code></h2>

<p>The number of times the structure is referenced. When this falls to 0 the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine&#39;s <a href="#comp">&quot;comp&quot;</a> routine.</p>

<h1 id="HISTORY">HISTORY</h1>

<p>Originally part of <a href="../../lib/pods/perlreguts.html">perlreguts</a>.</p>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Originally written by Yves Orton, expanded by &AElig;var Arnfj&ouml;r&eth; Bjarmason.</p>

<h1 id="LICENSE">LICENSE</h1>

<p>Copyright 2006 Yves Orton and 2007 &AElig;var Arnfj&ouml;r&eth; Bjarmason.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


