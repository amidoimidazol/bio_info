<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#The-backslash">The backslash</a></li>
      <li><a href="#All-the-sequences-and-escapes">All the sequences and escapes</a></li>
      <li><a href="#Character-Escapes">Character Escapes</a>
        <ul>
          <li><a href="#Fixed-characters">Fixed characters</a>
            <ul>
              <li><a href="#Example">Example</a></li>
            </ul>
          </li>
          <li><a href="#Control-characters">Control characters</a>
            <ul>
              <li><a href="#Example1">Example</a></li>
            </ul>
          </li>
          <li><a href="#Named-or-numbered-characters-and-character-sequences">Named or numbered characters and character sequences</a>
            <ul>
              <li><a href="#Example2">Example</a></li>
            </ul>
          </li>
          <li><a href="#Octal-escapes">Octal escapes</a>
            <ul>
              <li><a href="#Examples-assuming-an-ASCII-platform-">Examples (assuming an ASCII platform)</a></li>
              <li><a href="#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences">Disambiguation rules between old-style octal escapes and backreferences</a></li>
            </ul>
          </li>
          <li><a href="#Hexadecimal-escapes">Hexadecimal escapes</a>
            <ul>
              <li><a href="#Examples-assuming-an-ASCII-platform-1">Examples (assuming an ASCII platform)</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Modifiers">Modifiers</a>
        <ul>
          <li>
            <ul>
              <li><a href="#Examples">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Character-classes">Character classes</a>
        <ul>
          <li><a href="#Unicode-classes">Unicode classes</a></li>
        </ul>
      </li>
      <li><a href="#Referencing">Referencing</a>
        <ul>
          <li><a href="#Absolute-referencing">Absolute referencing</a>
            <ul>
              <li><a href="#Examples1">Examples</a></li>
            </ul>
          </li>
          <li><a href="#Relative-referencing">Relative referencing</a>
            <ul>
              <li><a href="#Examples2">Examples</a></li>
            </ul>
          </li>
          <li><a href="#Named-referencing">Named referencing</a>
            <ul>
              <li><a href="#Examples3">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Assertions">Assertions</a>
        <ul>
          <li>
            <ul>
              <li><a href="#Examples4">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Misc">Misc</a>
        <ul>
          <li>
            <ul>
              <li><a href="#Examples5">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlrebackslash - Perl Regular Expression Backslash Sequences and Escapes</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The top level documentation about Perl regular expressions is found in <a href="../../lib/pods/perlre.html">perlre</a>.</p>

<p>This document describes all backslash and escape sequences. After explaining the role of the backslash, it lists all the sequences that have a special meaning in Perl regular expressions (in alphabetical order), then describes each of them.</p>

<p>Most sequences are described in detail in different documents; the primary purpose of this document is to have a quick reference guide describing all backslash and escape sequences.</p>

<h2 id="The-backslash">The backslash</h2>

<p>In a regular expression, the backslash can perform one of two tasks: it either takes away the special meaning of the character following it (for instance, <code><code>\|</code></code> matches a vertical bar, it&#39;s not an alternation), or it is the start of a backslash or escape sequence.</p>

<p>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</p>

<p>If the character following the backslash is an ASCII letter or an ASCII digit, then the sequence may be special; if so, it&#39;s listed below. A few letters have not been used yet, so escaping them with a backslash doesn&#39;t change them to be special. A future version of Perl may assign a special meaning to them, so if you have warnings turned on, Perl issues a warning if you use such a sequence. [1].</p>

<p>It is however guaranteed that backslash or escape sequences never have a punctuation character following the backslash, not now, and not in a future version of Perl 5. So it is safe to put a backslash in front of a non-word character.</p>

<p>Note that the backslash itself is special; if you want to match a backslash, you have to escape the backslash with a backslash: <code><code>/\\/</code></code> matches a single backslash.</p>

<dl>

<dt id="pod-1-">[1]</dt>
<dd>

<p>There is one exception. If you use an alphanumeric character as the delimiter of your pattern (which you probably shouldn&#39;t do for readability reasons), you have to escape the delimiter if you want to match it. Perl won&#39;t warn then. See also <a href="../../lib/pods/perlop.html#Gory-details-of-parsing-quoted-constructs">&quot;Gory details of parsing quoted constructs&quot; in perlop</a>.</p>

</dd>
</dl>

<h2 id="All-the-sequences-and-escapes">All the sequences and escapes</h2>

<p>Those not usable within a bracketed character class (like <code><code>[\da-z]</code></code>) are marked as <code><code>Not in [].</code></code></p>

<pre><code><code> <span class="operator">\</span><span class="number">000</span>              <span class="variable">Octal</span> <span class="variable">escape</span> <span class="variable">sequence</span><span class="operator">.</span>  <span class="variable">See</span> <span class="variable">also</span> <span class="operator">\</span><span class="variable">o</span><span class="operator">{}.</span>
 <span class="operator">\</span><span class="number">1</span>                <span class="variable">Absolute</span> <span class="variable">backreference</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">a</span>                <span class="variable">Alarm</span> <span class="keyword">or</span> <span class="variable">bell</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">A</span>                <span class="variable">Beginning</span> <span class="variable">of</span> <span class="variable">string</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">b</span>                <span class="variable">Word</span><span class="operator">/</span><span class="variable">non</span><span class="operator">-</span><span class="variable">word</span> <span class="variable">boundary</span><span class="operator">.</span> <span class="operator">(</span><span class="variable">Backspace</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">).</span>
 <span class="operator">\</span><span class="variable">B</span>                <span class="variable">Not</span> <span class="variable">a</span> <span class="variable">word</span><span class="operator">/</span><span class="variable">non</span><span class="operator">-</span><span class="variable">word</span> <span class="variable">boundary</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">cX</span>               <span class="variable">Control</span><span class="keyword">-X</span>
 <span class="operator">\</span><span class="variable">C</span>                <span class="variable">Single</span> <span class="variable">octet</span><span class="operator">,</span> <span class="variable">even</span> <span class="variable">under</span> <span class="variable">UTF</span><span class="operator">-</span><span class="number">8.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">d</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">digits</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">D</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">non</span><span class="operator">-</span><span class="variable">digits</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">e</span>                <span class="variable">Escape</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">E</span>                <span class="variable">Turn</span> <span class="variable">off</span> <span class="operator">\</span><span class="variable">Q</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">L</span> <span class="keyword">and</span> <span class="operator">\</span><span class="variable">U</span> <span class="variable">processing</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">f</span>                <span class="variable">Form</span> <span class="variable">feed</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">F</span>                <span class="variable">Foldcase</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">g</span><span class="operator">{},</span> <span class="operator">\</span><span class="variable">g1</span>         <span class="variable">Named</span><span class="operator">,</span> <span class="variable">absolute</span> <span class="keyword">or</span> <span class="variable">relative</span> <span class="variable">backreference</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span>
 <span class="operator">\</span><span class="variable">G</span>                <span class="variable">Pos</span> <span class="variable">assertion</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">h</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">horizontal</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">H</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">non</span> <span class="variable">horizontal</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">k</span><span class="operator">{},</span> <span class="operator">\</span><span class="variable">k</span><span class="operator">&lt;&gt;,</span> <span class="operator">\</span><span class="variable">k</span><span class="string">''</span>  <span class="variable">Named</span> <span class="variable">backreference</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">K</span>                <span class="variable">Keep</span> <span class="variable">the</span> <span class="variable">stuff</span> <span class="variable">left</span> <span class="variable">of</span> <span class="operator">\</span><span class="variable">K</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">l</span>                <span class="variable">Lowercase</span> <span class="keyword">next</span> <span class="variable">character</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">L</span>                <span class="variable">Lowercase</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">n</span>                <span class="operator">(</span><span class="variable">Logical</span><span class="operator">)</span> <span class="variable">newline</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">N</span>                <span class="variable">Any</span> <span class="variable">character</span> <span class="variable">but</span> <span class="variable">newline</span><span class="operator">.</span>  <span class="variable">Experimental</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">N</span><span class="operator">{}</span>              <span class="variable">Named</span> <span class="keyword">or</span> <span class="variable">numbered</span> <span class="operator">(</span><span class="variable">Unicode</span><span class="operator">)</span> <span class="variable">character</span> <span class="keyword">or</span> <span class="variable">sequence</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">o</span><span class="operator">{}</span>              <span class="variable">Octal</span> <span class="variable">escape</span> <span class="variable">sequence</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">p</span><span class="operator">{},</span> <span class="operator">\</span><span class="variable">pP</span>         <span class="variable">Character</span> <span class="variable">with</span> <span class="variable">the</span> <span class="keyword">given</span> <span class="variable">Unicode</span> <span class="variable">property</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">P</span><span class="operator">{},</span> <span class="operator">\</span><span class="variable">PP</span>         <span class="variable">Character</span> <span class="variable">without</span> <span class="variable">the</span> <span class="keyword">given</span> <span class="variable">Unicode</span> <span class="variable">property</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">Q</span>                <span class="variable">Quote</span> <span class="operator">(</span><span class="variable">disable</span><span class="operator">)</span> <span class="variable">pattern</span> <span class="variable">metacharacters</span> <span class="variable">till</span> <span class="operator">\</span><span class="variable">E</span><span class="operator">.</span>  <span class="variable">Not</span>
                   <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">r</span>                <span class="variable">Return</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">R</span>                <span class="variable">Generic</span> <span class="variable">new</span> <span class="variable">line</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="regex">s                Character class for whitespace.
 \S                Character class for non whitespace.
 \t                Tab character.
 \u                Titlecase next character.  Not in [].
 \U                Uppercase till \E.  Not in [].
 \v                Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">vertical</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">V</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">non</span> <span class="variable">vertical</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">w</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">word</span> <span class="variable">characters</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">W</span>                <span class="variable">Character</span> <span class="variable">class</span> <span class="keyword">for</span> <span class="variable">non</span><span class="operator">-</span><span class="variable">word</span> <span class="variable">characters</span><span class="operator">.</span>
 <span class="operator">\x</span><span class="operator">{}</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">x00</span>        <span class="variable">Hexadecimal</span> <span class="variable">escape</span> <span class="variable">sequence</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">X</span>                <span class="variable">Unicode</span> <span class="string">"extended grapheme cluster"</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">z</span>                <span class="variable">End</span> <span class="variable">of</span> <span class="variable">string</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">Z</span>                <span class="variable">End</span> <span class="variable">of</span> <span class="variable">string</span><span class="operator">.</span>  <span class="variable">Not</span> <span class="variable">in</span> <span class="operator">[]</span><span class="operator">.</span>
</code></code></pre>

<h2 id="Character-Escapes">Character Escapes</h2>

<h3 id="Fixed-characters">Fixed characters</h3>

<p>A handful of characters have a dedicated <i>character escape</i>. The following table shows them, along with their ASCII code points (in decimal and hex), their ASCII name, the control escape on ASCII platforms and a short description. (For EBCDIC platforms, see <a href="../../lib/pods/perlebcdic.html#OPERATOR-DIFFERENCES">&quot;OPERATOR DIFFERENCES&quot; in perlebcdic</a>.)</p>

<pre><code><code> Seq.  Code Point  ASCII   Cntrl   Description.
       Dec    Hex
  \a     7     07    BEL    \cG    alarm or bell
  \b     8     08     BS    \cH    backspace [1]
  \e    27     1B    ESC    \c[    escape character
  \f    12     0C     FF    \cL    form feed
  \n    10     0A     LF    \cJ    line feed [2]
  \r    13     0D     CR    \cM    carriage return
  \t     9     09    TAB    \cI    tab</code></code></pre>

<dl>

<dt id="pod-1-1">[1]</dt>
<dd>

<p><code><code>\b</code></code> is the backspace character only inside a character class. Outside a character class, <code><code>\b</code></code> is a word/non-word boundary.</p>

</dd>
<dt id="pod-2-">[2]</dt>
<dd>

<p><code><code>\n</code></code> matches a logical newline. Perl converts between <code><code>\n</code></code> and your OS&#39;s native newline character when reading from or writing to text files.</p>

</dd>
</dl>

<h4 id="Example">Example</h4>

<pre><code><code> <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\t/</span><span class="operator">;</span>   <span class="comment"># Matches if $str contains a (horizontal) tab.</span>
</code></code></pre>

<h3 id="Control-characters">Control characters</h3>

<p><code><code>\c</code></code> is used to denote a control character; the character following <code><code>\c</code></code> determines the value of the construct. For example the value of <code><code>\cA</code></code> is <code><code>chr(1)</code></code>, and the value of <code><code>\cb</code></code> is <code><code>chr(2)</code></code>, etc. The gory details are in <a href="../../lib/pods/perlop.html#Regexp-Quote-Like-Operators">&quot;Regexp Quote-Like Operators&quot; in perlop</a>. A complete list of what <code><code>chr(1)</code></code>, etc. means for ASCII and EBCDIC platforms is in <a href="../../lib/pods/perlebcdic.html#OPERATOR-DIFFERENCES">&quot;OPERATOR DIFFERENCES&quot; in perlebcdic</a>.</p>

<p>Note that <code><code>\c\</code></code> alone at the end of a regular expression (or doubled-quoted string) is not valid. The backslash must be followed by another character. That is, <code><code>\c\</code><i><code>X</code></i></code> means <code><code>chr(28) . &#39;</code><i><code>X</code></i><code>&#39;</code></code> for all characters <i>X</i>.</p>

<p>To write platform-independent code, you must use <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span>
</code><i><code>NAME</code></i><code>}</code></code> instead, like <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">ESCAPE</span><span class="operator">}</span>
</code></code> or <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span><span class="number">001</span><span class="variable">B</span><span class="operator">}</span>
</code></code>, see <a href="../../lib/charnames.html">charnames</a>.</p>

<p>Mnemonic: <i>c</i>ontrol character.</p>

<h4 id="Example1">Example</h4>

<pre><code><code> <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\cK/</span><span class="operator">;</span>  <span class="comment"># Matches if $str contains a vertical tab (control-K).</span>
</code></code></pre>

<h3 id="Named-or-numbered-characters-and-character-sequences">Named or numbered characters and character sequences</h3>

<p>Unicode characters have a Unicode name and numeric code point (ordinal) value. Use the <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{}</span>
</code></code> construct to specify a character by either of these values. Certain sequences of characters also have names.</p>

<p>To specify by name, the name of the character or character sequence goes between the curly braces.</p>

<p>To specify a character by Unicode code point, use the form <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span>
</code><i><code>code point</code></i><code>}</code></code>, where <i>code point</i> is a number in hexadecimal that gives the code point that Unicode has assigned to the desired character. It is customary but not required to use leading zeros to pad the number to 4 digits. Thus <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span><span class="number">0041</span><span class="operator">}</span>
</code></code> means <code><code>LATIN CAPITAL LETTER A</code></code>, and you will rarely see it written without the two leading zeros. <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span><span class="number">0041</span><span class="operator">}</span>
</code></code> means &quot;A&quot; even on EBCDIC machines (where the ordinal value of &quot;A&quot; is not 0x41).</p>

<p>It is even possible to give your own names to characters and character sequences. For details, see <a href="../../lib/charnames.html">charnames</a>.</p>

<p>(There is an expanded internal form that you may see in debug output: <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span>
</code><i><code>code point</code></i><code>.</code><i><code>code point</code></i><code>...}</code></code>. The <code><code>...</code></code> means any number of these <i>code point</i>s separated by dots. This represents the sequence formed by the characters. This is an internal form only, subject to change, and you should not try to use it yourself.)</p>

<p>Mnemonic: <i>N</i>amed character.</p>

<p>Note that a character or character sequence expressed as a named or numbered character is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</p>

<h4 id="Example2">Example</h4>

<pre><code><code> <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\N{THAI CHARACTER SO SO}/</span><span class="operator">;</span>  <span class="comment"># Matches the Thai SO SO character</span>
 
 <span class="keyword">use</span> <span class="variable">charnames</span> <span class="string">'Cyrillic'</span><span class="operator">;</span>            <span class="comment"># Loads Cyrillic names.</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\N{ZHE}\N{KA}/</span><span class="operator">;</span>             <span class="comment"># Match "ZHE" followed by "KA".</span>
</code></code></pre>

<h3 id="Octal-escapes">Octal escapes</h3>

<p>There are two forms of octal escapes. Each is used to specify a character by its code point specified in octal notation.</p>

<p>One form, available starting in Perl 5.14 looks like <code><code><span class="operator">\</span><span class="variable">o</span><span class="operator">{...}</span>
</code></code>, where the dots represent one or more octal digits. It can be used for any Unicode character.</p>

<p>It was introduced to avoid the potential problems with the other form, available in all Perls. That form consists of a backslash followed by three octal digits. One problem with this form is that it can look exactly like an old-style backreference (see <a href="#Disambiguation-rules-between-old-style-octal-escapes-and-backreferences">&quot;Disambiguation rules between old-style octal escapes and backreferences&quot;</a> below.) You can avoid this by making the first of the three digits always a zero, but that makes \077 the largest code point specifiable.</p>

<p>In some contexts, a backslash followed by two or even one octal digits may be interpreted as an octal escape, sometimes with a warning, and because of some bugs, sometimes with surprising results. Also, if you are creating a regex out of smaller snippets concatenated together, and you use fewer than three digits, the beginning of one snippet may be interpreted as adding digits to the ending of the snippet before it. See <a href="#Absolute-referencing">&quot;Absolute referencing&quot;</a> for more discussion and examples of the snippet problem.</p>

<p>Note that a character expressed as an octal escape is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</p>

<p>To summarize, the <code><code><span class="operator">\</span><span class="variable">o</span><span class="operator">{}</span>
</code></code> form is always safe to use, and the other form is safe to use for code points through \077 when you use exactly three digits to specify them.</p>

<p>Mnemonic: <i>0</i>ctal or <i>o</i>ctal.</p>

<h4 id="Examples-assuming-an-ASCII-platform-">Examples (assuming an ASCII platform)</h4>

<pre><code><code> <span class="variable">$str</span> <span class="operator">=</span> <span class="string">"Perl"</span><span class="operator">;</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\o{120}/</span><span class="operator">;</span>  <span class="comment"># Match, "\120" is "P".</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\120/</span><span class="operator">;</span>     <span class="comment"># Same.</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\o{120}+/</span><span class="operator">;</span> <span class="comment"># Match, "\120" is "P", it's repeated at least once</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\120+/</span><span class="operator">;</span>    <span class="comment"># Same.</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/P\053/</span><span class="operator">;</span>    <span class="comment"># No match, "\053" is "+" and taken literally.</span>
 <span class="regex">/\o{23073}/</span>         <span class="comment"># Black foreground, white background smiling face.</span>
 <span class="operator">/\</span><span class="variable">o</span><span class="operator">{</span><span class="number">4801234567</span><span class="operator">}</span><span class="regex">/    # Raises a warning, and yields chr(4)
 </span>
</code></code></pre>

<h4 id="Disambiguation-rules-between-old-style-octal-escapes-and-backreferences">Disambiguation rules between old-style octal escapes and backreferences</h4>

<p>Octal escapes of the <code><code>\000</code></code> form outside of bracketed character classes potentially clash with old-style backreferences. (see <a href="#Absolute-referencing">&quot;Absolute referencing&quot;</a> below). They both consist of a backslash followed by numbers. So Perl has to use heuristics to determine whether it is a backreference or an octal escape. Perl uses the following rules to disambiguate:</p>

<ol>

<li><p>If the backslash is followed by a single digit, it&#39;s a backreference.</p>

</li>
<li><p>If the first digit following the backslash is a 0, it&#39;s an octal escape.</p>

</li>
<li><p>If the number following the backslash is N (in decimal), and Perl already has seen N capture groups, Perl considers this a backreference. Otherwise, it considers it an octal escape. If N has more than three digits, Perl takes only the first three for the octal escape; the rest are matched as is.</p>

<pre><code><code> <span class="keyword">my</span> <span class="variable">$pat</span>  <span class="operator">=</span> <span class="string">"("</span> <span class="operator">x</span> <span class="number">999</span><span class="operator">;</span>
    <span class="variable">$pat</span> <span class="operator">.=</span> <span class="string">"a"</span><span class="operator">;</span>
    <span class="variable">$pat</span> <span class="operator">.=</span> <span class="string">")"</span> <span class="operator">x</span> <span class="number">999</span><span class="operator">;</span>
 <span class="regex">/^(</span><span class="variable">$pat</span><span class="regex">)\1000$/</span><span class="operator">;</span>   <span class="comment">#  Matches 'aa'; there are 1000 capture groups.</span>
 <span class="regex">/^</span><span class="variable">$pat</span><span class="regex">\1000$/</span><span class="operator">;</span>     <span class="comment">#  Matches 'a@0'; there are 999 capture groups</span>
                    <span class="comment">#    and \1000 is seen as \100 (a '@') and a '0'</span>
</code></code></pre>

</li>
</ol>

<p>You can force a backreference interpretation always by using the <code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{...}</span>
</code></code> form. You can the force an octal interpretation always by using the <code><code><span class="operator">\</span><span class="variable">o</span><span class="operator">{...}</span>
</code></code> form, or for numbers up through \077 (= 63 decimal), by using three digits, beginning with a &quot;0&quot;.</p>

<h3 id="Hexadecimal-escapes">Hexadecimal escapes</h3>

<p>Like octal escapes, there are two forms of hexadecimal escapes, but both start with the same thing, <code><code>\x</code></code>. This is followed by either exactly two hexadecimal digits forming a number, or a hexadecimal number of arbitrary length surrounded by curly braces. The hexadecimal number is the code point of the character you want to express.</p>

<p>Note that a character expressed as one of these escapes is considered a character without special meaning by the regex engine, and will match &quot;as is&quot;.</p>

<p>Mnemonic: he<i>x</i>adecimal.</p>

<h4 id="Examples-assuming-an-ASCII-platform-1">Examples (assuming an ASCII platform)</h4>

<pre><code><code> <span class="variable">$str</span> <span class="operator">=</span> <span class="string">"Perl"</span><span class="operator">;</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\x50/</span><span class="operator">;</span>    <span class="comment"># Match, "\x50" is "P".</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/\x50+/</span><span class="operator">;</span>   <span class="comment"># Match, "\x50" is "P", it is repeated at least once</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">/P\x2B/</span><span class="operator">;</span>   <span class="comment"># No match, "\x2B" is "+" and taken literally.</span>
 
 <span class="regex">/\x{2603}\x{2602}/</span> <span class="comment"># Snowman with an umbrella.</span>
                    <span class="comment"># The Unicode character 2603 is a snowman,</span>
                    <span class="comment"># the Unicode character 2602 is an umbrella.</span>
 <span class="operator">/\x</span><span class="operator">{</span><span class="string">263B</span><span class="operator">}</span><span class="operator">/</span>         <span class="comment"># Black smiling face.</span>
 <span class="regex">/\x{263b}/</span>         <span class="comment"># Same, the hex digits A - F are case insensitive.</span>
</code></code></pre>

<h2 id="Modifiers">Modifiers</h2>

<p>A number of backslash sequences have to do with changing the character, or characters following them. <code><code>\l</code></code> will lowercase the character following it, while <code><code>\u</code></code> will uppercase (or, more accurately, titlecase) the character following it. They provide functionality similar to the functions <code><code>lcfirst</code></code> and <code><code>ucfirst</code></code>.</p>

<p>To uppercase or lowercase several characters, one might want to use <code><code>\L</code></code> or <code><code>\U</code></code>, which will lowercase/uppercase all characters following them, until either the end of the pattern or the next occurrence of <code><code>\E</code></code>, whichever comes first. They provide functionality similar to what the functions <code><code>lc</code></code> and <code><code>uc</code></code> provide.</p>

<p><code><code>\Q</code></code> is used to quote (disable) pattern metacharacters, up to the next <code><code>\E</code></code> or the end of the pattern. <code><code>\Q</code></code> adds a backslash to any character that could have special meaning to Perl. In the ASCII range, it quotes every character that isn&#39;t a letter, digit, or underscore. See <a href="../../lib/pods/perlfunc.html#quotemeta">&quot;quotemeta&quot; in perlfunc</a> for details on what gets quoted for non-ASCII code points. Using this ensures that any character between <code><code>\Q</code></code> and <code><code>\E</code></code> will be matched literally, not interpreted as a metacharacter by the regex engine.</p>

<p><code><code>\F</code></code> can be used to casefold all characters following, up to the next <code><code>\E</code></code> or the end of the pattern. It provides the functionality similar to the <code><code>fc</code></code> function.</p>

<p>Mnemonic: <i>L</i>owercase, <i>U</i>ppercase, <i>F</i>old-case, <i>Q</i>uotemeta, <i>E</i>nd.</p>

<h4 id="Examples">Examples</h4>

<pre><code><code> <span class="variable">$sid</span>     <span class="operator">=</span> <span class="string">"sid"</span><span class="operator">;</span>
 <span class="variable">$greg</span>    <span class="operator">=</span> <span class="string">"GrEg"</span><span class="operator">;</span>
 <span class="variable">$miranda</span> <span class="operator">=</span> <span class="string">"(Miranda)"</span><span class="operator">;</span>
 <span class="variable">$str</span>     <span class="operator">=~</span> <span class="regex">/\u</span><span class="variable">$sid</span><span class="regex">/</span><span class="operator">;</span>        <span class="comment"># Matches 'Sid'</span>
 <span class="variable">$str</span>     <span class="operator">=~</span> <span class="regex">/\L</span><span class="variable">$greg</span><span class="regex">/</span><span class="operator">;</span>       <span class="comment"># Matches 'greg'</span>
 <span class="variable">$str</span>     <span class="operator">=~</span> <span class="regex">/\Q</span><span class="variable">$miranda</span><span class="regex">\E/</span><span class="operator">;</span>  <span class="comment"># Matches '(Miranda)', as if the pattern</span>
                              <span class="comment">#   had been written as /\(Miranda\)/</span>
</code></code></pre>

<h2 id="Character-classes">Character classes</h2>

<p>Perl regular expressions have a large range of character classes. Some of the character classes are written as a backslash sequence. We will briefly discuss those here; full details of character classes can be found in <a href="../../lib/pods/perlrecharclass.html">perlrecharclass</a>.</p>

<p><code><code>\w</code></code> is a character class that matches any single <i>word</i> character (letters, digits, Unicode marks, and connector punctuation (like the underscore)). <code><code>\d</code></code> is a character class that matches any decimal digit, while the character class <code><code>\s</code></code> matches any whitespace character. New in perl 5.10.0 are the classes <code><code>\h</code></code> and <code><code>\v</code></code> which match horizontal and vertical whitespace characters.</p>

<p>The exact set of characters matched by <code><code>\d</code></code>, <code><code>\s</code></code>, and <code><code>\w</code></code> varies depending on various pragma and regular expression modifiers. It is possible to restrict the match to the ASCII range by using the <code><code>/a</code></code> regular expression modifier. See <a href="../../lib/pods/perlrecharclass.html">perlrecharclass</a>.</p>

<p>The uppercase variants (<code><code>\W</code></code>, <code><code>\D</code></code>, <code><code>\S</code></code>, <code><code>\H</code></code>, and <code><code>\V</code></code>) are character classes that match, respectively, any character that isn&#39;t a word character, digit, whitespace, horizontal whitespace, or vertical whitespace.</p>

<p>Mnemonics: <i>w</i>ord, <i>d</i>igit, <i>s</i>pace, <i>h</i>orizontal, <i>v</i>ertical.</p>

<h3 id="Unicode-classes">Unicode classes</h3>

<p><code><code>\pP</code></code> (where <code><code>P</code></code> is a single letter) and <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Property</span><span class="operator">}</span>
</code></code> are used to match a character that matches the given Unicode property; properties include things like &quot;letter&quot;, or &quot;thai character&quot;. Capitalizing the sequence to <code><code>\PP</code></code> and <code><code><span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">Property</span><span class="operator">}</span>
</code></code> make the sequence match a character that doesn&#39;t match the given Unicode property. For more details, see <a href="../../lib/pods/perlrecharclass.html#Backslash-sequences">&quot;Backslash sequences&quot; in perlrecharclass</a> and <a href="../../lib/pods/perlunicode.html#Unicode-Character-Properties">&quot;Unicode Character Properties&quot; in perlunicode</a>.</p>

<p>Mnemonic: <i>p</i>roperty.</p>

<h2 id="Referencing">Referencing</h2>

<p>If capturing parenthesis are used in a regular expression, we can refer to the part of the source string that was matched, and match exactly the same thing. There are three ways of referring to such <i>backreference</i>: absolutely, relatively, and by name.</p>

<h3 id="Absolute-referencing">Absolute referencing</h3>

<p>Either <code><code>\g</code><i><code>N</code></i></code> (starting in Perl 5.10.0), or <code><code>\</code><i><code>N</code></i></code> (old-style) where <i>N</i> is a positive (unsigned) decimal number of any length is an absolute reference to a capturing group.</p>

<p><i>N</i> refers to the Nth set of parentheses, so <code><code>\g</code><i><code>N</code></i></code> refers to whatever has been matched by that set of parentheses. Thus <code><code>\g1</code></code> refers to the first capture group in the regex.</p>

<p>The <code><code>\g</code><i><code>N</code></i></code> form can be equivalently written as <code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{</span>
</code><i><code>N</code></i><code>}</code></code> which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex <code><code>qr/$a$b/</code></code>, and <code><code>$a</code></code> contained <code><code>&quot;\g1&quot;</code></code>, and <code><code>$b</code></code> contained <code><code>&quot;37&quot;</code></code>, you would get <code><code>/\g137/</code></code> which is probably not what you intended.</p>

<p>In the <code><code>\</code><i><code>N</code></i></code> form, <i>N</i> must not begin with a &quot;0&quot;, and there must be at least <i>N</i> capturing groups, or else <i>N</i> is considered an octal escape (but something like <code><code>\18</code></code> is the same as <code><code>\0018</code></code>; that is, the octal escape <code><code>&quot;\001&quot;</code></code> followed by a literal digit <code><code>&quot;8&quot;</code></code>).</p>

<p>Mnemonic: <i>g</i>roup.</p>

<h4 id="Examples1">Examples</h4>

<pre><code><code> <span class="regex">/(\w+) \g1/</span><span class="operator">;</span>    <span class="comment"># Finds a duplicated word, (e.g. "cat cat").</span>
 <span class="regex">/(\w+) \1/</span><span class="operator">;</span>     <span class="comment"># Same thing; written old-style</span>
 <span class="regex">/(.)(.)\g2\g1/</span><span class="operator">;</span>  <span class="comment"># Match a four letter palindrome (e.g. "ABBA").</span>
</code></code></pre>

<h3 id="Relative-referencing">Relative referencing</h3>

<p><code><code>\g-</code><i><code>N</code></i></code> (starting in Perl 5.10.0) is used for relative addressing. (It can be written as <code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{-</span>
</code><i><code>N</code></i></code>.) It refers to the <i>N</i>th group before the <code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{-</span>
</code><i><code>N</code></i><code>}</code></code>.</p>

<p>The big advantage of this form is that it makes it much easier to write patterns with references that can be interpolated in larger patterns, even if the larger pattern also contains capture groups.</p>

<h4 id="Examples2">Examples</h4>

<pre><code><code> <span class="regex">/(A)        # Group 1
  (          # Group 2
    (B)      # Group 3
    \g{-1}   # Refers to group 3 (B)
    \g{-3}   # Refers to group 1 (A)
  )
 /x</span><span class="operator">;</span>         <span class="comment"># Matches "ABBA".</span>
 
 <span class="keyword">my</span> <span class="variable">$qr</span> <span class="operator">=</span> <span class="string">qr /(.)(.)\g{-2}\g{-1}/</span><span class="operator">;</span>  <span class="comment"># Matches 'abab', 'cdcd', etc.</span>
 <span class="regex">/</span><span class="variable">$qr$qr</span><span class="regex">/</span>                           <span class="comment"># Matches 'ababcdcd'.</span>
</code></code></pre>

<h3 id="Named-referencing">Named referencing</h3>

<p><code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{</span>
</code><i><code>name</code></i><code>}</code></code> (starting in Perl 5.10.0) can be used to back refer to a named capture group, dispensing completely with having to think about capture buffer positions.</p>

<p>To be compatible with .Net regular expressions, <code><code><span class="operator">\</span><span class="variable">g</span><span class="operator">{</span><span class="variable">name</span><span class="operator">}</span>
</code></code> may also be written as <code><code><span class="operator">\</span><span class="variable">k</span><span class="operator">{</span><span class="variable">name</span><span class="operator">}</span>
</code></code>, <code><code>\k&lt;name&gt;</code></code> or <code><code>\k&#39;name&#39;</code></code>.</p>

<p>To prevent any ambiguity, <i>name</i> must not start with a digit nor contain a hyphen.</p>

<h4 id="Examples3">Examples</h4>

<pre><code><code> /(?&lt;word&gt;\w+) \g{word}/ # Finds duplicated word, (e.g. &quot;cat cat&quot;)
 /(?&lt;word&gt;\w+) \k{word}/ # Same.
 /(?&lt;word&gt;\w+) \k&lt;word&gt;/ # Same.
 /(?&lt;letter1&gt;.)(?&lt;letter2&gt;.)\g{letter2}\g{letter1}/
                         # Match a four letter palindrome (e.g. &quot;ABBA&quot;)</code></code></pre>

<h2 id="Assertions">Assertions</h2>

<p>Assertions are conditions that have to be true; they don&#39;t actually match parts of the substring. There are six assertions that are written as backslash sequences.</p>

<dl>

<dt id="A">\A</dt>
<dd>

<p><code><code>\A</code></code> only matches at the beginning of the string. If the <code><code>/m</code></code> modifier isn&#39;t used, then <code><code>/\A/</code></code> is equivalent to <code><code>/^/</code></code>. However, if the <code><code>/m</code></code> modifier is used, then <code><code>/^/</code></code> matches internal newlines, but the meaning of <code><code>/\A/</code></code> isn&#39;t changed by the <code><code>/m</code></code> modifier. <code><code>\A</code></code> matches at the beginning of the string regardless whether the <code><code>/m</code></code> modifier is used.</p>

</dd>
<dt id="z-Z">\z, \Z</dt>
<dd>

<p><code><code>\z</code></code> and <code><code>\Z</code></code> match at the end of the string. If the <code><code>/m</code></code> modifier isn&#39;t used, then <code><code>/\Z/</code></code> is equivalent to <code><code>/$/</code></code>; that is, it matches at the end of the string, or one before the newline at the end of the string. If the <code><code>/m</code></code> modifier is used, then <code><code>/$/</code></code> matches at internal newlines, but the meaning of <code><code>/\Z/</code></code> isn&#39;t changed by the <code><code>/m</code></code> modifier. <code><code>\Z</code></code> matches at the end of the string (or just before a trailing newline) regardless whether the <code><code>/m</code></code> modifier is used.</p>

<p><code><code>\z</code></code> is just like <code><code>\Z</code></code>, except that it does not match before a trailing newline. <code><code>\z</code></code> matches at the end of the string only, regardless of the modifiers used, and not just before a newline. It is how to anchor the match to the true end of the string under all conditions.</p>

</dd>
<dt id="G">\G</dt>
<dd>

<p><code><code>\G</code></code> is usually used only in combination with the <code><code>/g</code></code> modifier. If the <code><code>/g</code></code> modifier is used and the match is done in scalar context, Perl remembers where in the source string the last match ended, and the next time, it will start the match from where it ended the previous time.</p>

<p><code><code>\G</code></code> matches the point where the previous match on that string ended, or the beginning of that string if there was no previous match.</p>

<p>Mnemonic: <i>G</i>lobal.</p>

</dd>
<dt id="b-B">\b, \B</dt>
<dd>

<p><code><code>\b</code></code> matches at any place between a word and a non-word character; <code><code>\B</code></code> matches at any place between characters where <code><code>\b</code></code> doesn&#39;t match. <code><code>\b</code></code> and <code><code>\B</code></code> assume there&#39;s a non-word character before the beginning and after the end of the source string; so <code><code>\b</code></code> will match at the beginning (or end) of the source string if the source string begins (or ends) with a word character. Otherwise, <code><code>\B</code></code> will match.</p>

<p>Do not use something like <code><code>\b=head\d\b</code></code> and expect it to match the beginning of a line. It can&#39;t, because for there to be a boundary before the non-word &quot;=&quot;, there must be a word character immediately previous. All boundary determinations look for word characters alone, not for non-words characters nor for string ends. It may help to understand how &lt;\b&gt; and &lt;\B&gt; work by equating them as follows:</p>

<pre><code><code>    \b  really means    (?:(?&lt;=\w)(?!\w)|(?&lt;!\w)(?=\w))
    \B  really means    (?:(?&lt;=\w)(?=\w)|(?&lt;!\w)(?!\w))</code></code></pre>

<p>Mnemonic: <i>b</i>oundary.</p>

</dd>
</dl>

<h4 id="Examples4">Examples</h4>

<pre><code><code>  <span class="string">"cat"</span>   <span class="operator">=~</span> <span class="regex">/\Acat/</span><span class="operator">;</span>     <span class="comment"># Match.</span>
  <span class="string">"cat"</span>   <span class="operator">=~</span> <span class="regex">/cat\Z/</span><span class="operator">;</span>     <span class="comment"># Match.</span>
  <span class="string">"cat\n"</span> <span class="operator">=~</span> <span class="regex">/cat\Z/</span><span class="operator">;</span>     <span class="comment"># Match.</span>
  <span class="string">"cat\n"</span> <span class="operator">=~</span> <span class="regex">/cat\z/</span><span class="operator">;</span>     <span class="comment"># No match.</span>
  
  <span class="string">"cat"</span>   <span class="operator">=~</span> <span class="regex">/\bcat\b/</span><span class="operator">;</span>   <span class="comment"># Matches.</span>
  <span class="string">"cats"</span>  <span class="operator">=~</span> <span class="regex">/\bcat\b/</span><span class="operator">;</span>   <span class="comment"># No match.</span>
  <span class="string">"cat"</span>   <span class="operator">=~</span> <span class="regex">/\bcat\B/</span><span class="operator">;</span>   <span class="comment"># No match.</span>
  <span class="string">"cats"</span>  <span class="operator">=~</span> <span class="regex">/\bcat\B/</span><span class="operator">;</span>   <span class="comment"># Match.</span>
  
  <span class="keyword">while</span> <span class="operator">(</span><span class="string">"cat dog"</span> <span class="operator">=~</span> <span class="regex">/(\w+)/g</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="variable">$1</span><span class="operator">;</span>           <span class="comment"># Prints 'catdog'</span>
  <span class="operator">}</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="string">"cat dog"</span> <span class="operator">=~</span> <span class="regex">/\G(\w+)/g</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="variable">$1</span><span class="operator">;</span>           <span class="comment"># Prints 'cat'</span>
  <span class="operator">}</span>
</code></code></pre>

<h2 id="Misc">Misc</h2>

<p>Here we document the backslash sequences that don&#39;t fall in one of the categories above. These are:</p>

<dl>

<dt id="C">\C</dt>
<dd>

<p><code><code>\C</code></code> always matches a single octet, even if the source string is encoded in UTF-8 format, and the character to be matched is a multi-octet character. <code><code>\C</code></code> was introduced in perl 5.6. This is very dangerous, because it violates the logical character abstraction and can cause UTF-8 sequences to become malformed.</p>

<p>Mnemonic: o<i>C</i>tet.</p>

</dd>
<dt id="K">\K</dt>
<dd>

<p>This appeared in perl 5.10.0. Anything matched left of <code><code>\K</code></code> is not included in <code><code>$&amp;</code></code>, and will not be replaced if the pattern is used in a substitution. This lets you write <code><code>s/PAT1 \K PAT2/REPL/x</code></code> instead of <code><code>s/(PAT1) PAT2/${1}REPL/x</code></code> or <code><code>s/(?&lt;=PAT1) PAT2/REPL/x</code></code>.</p>

<p>Mnemonic: <i>K</i>eep.</p>

</dd>
<dt id="N">\N</dt>
<dd>

<p>This is an experimental feature new to perl 5.12.0. It matches any character that is <b>not</b> a newline. It is a short-hand for writing <code><code>[^\n]</code></code>, and is identical to the <code><code>.</code></code> metasymbol, except under the <code><code>/s</code></code> flag, which changes the meaning of <code><code>.</code></code>, but not <code><code>\N</code></code>.</p>

<p>Note that <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{...}</span>
</code></code> can mean a <a href="#Named-or-numbered-characters-and-character-sequences">named or numbered character </a>.</p>

<p>Mnemonic: Complement of <i>\n</i>.</p>

</dd>
<dt id="R">\R </dt>
<dd>

<p><code><code>\R</code></code> matches a <i>generic newline</i>; that is, anything considered a linebreak sequence by Unicode. This includes all characters matched by <code><code>\v</code></code> (vertical whitespace), and the multi character sequence <code><code>&quot;\x0D\x0A&quot;</code></code> (carriage return followed by a line feed, sometimes called the network newline; it&#39;s the end of line sequence used in Microsoft text files opened in binary mode). <code><code>\R</code></code> is equivalent to <code><code>(?&gt;\x0D\x0A|\v)</code></code>. (The reason it doesn&#39;t backtrack is that the sequence is considered inseparable. That means that</p>

<pre><code><code> &quot;\x0D\x0A&quot; =~ /^\R\x0A$/   # No match</code></code></pre>

<p>fails, because the <code><code>\R</code></code> matches the entire string, and won&#39;t backtrack to match just the <code><code>&quot;\x0D&quot;</code></code>.) Since <code><code>\R</code></code> can match a sequence of more than one character, it cannot be put inside a bracketed character class; <code><code>/[\R]/</code></code> is an error; use <code><code>\v</code></code> instead. <code><code>\R</code></code> was introduced in perl 5.10.0.</p>

<p>Note that this does not respect any locale that might be in effect; it matches according to the platform&#39;s native character set.</p>

<p>Mnemonic: none really. <code><code>\R</code></code> was picked because PCRE already uses <code><code>\R</code></code>, and more importantly because Unicode recommends such a regular expression metacharacter, and suggests <code><code>\R</code></code> as its notation.</p>

</dd>
<dt id="X">\X </dt>
<dd>

<p>This matches a Unicode <i>extended grapheme cluster</i>.</p>

<p><code><code>\X</code></code> matches quite well what normal (non-Unicode-programmer) usage would consider a single character. As an example, consider a G with some sort of diacritic mark, such as an arrow. There is no such single character in Unicode, but one can be composed by using a G followed by a Unicode &quot;COMBINING UPWARDS ARROW BELOW&quot;, and would be displayed by Unicode-aware software as if it were a single character.</p>

<p>Mnemonic: e<i>X</i>tended Unicode character.</p>

</dd>
</dl>

<h4 id="Examples5">Examples</h4>

<pre><code><code> <span class="string">"\x{256}"</span> <span class="operator">=~</span> <span class="regex">/^\C\C$/</span><span class="operator">;</span>    <span class="comment"># Match as chr (0x256) takes 2 octets in UTF-8.</span>
 
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">s/foo\Kbar/baz/g</span><span class="operator">;</span> <span class="comment"># Change any 'bar' following a 'foo' to 'baz'</span>
 <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">s/(.)\K\g1//g</span><span class="operator">;</span>    <span class="comment"># Delete duplicated characters.</span>
 
 <span class="string">"\n"</span>   <span class="operator">=~</span> <span class="regex">/^\R$/</span><span class="operator">;</span>         <span class="comment"># Match, \n   is a generic newline.</span>
 <span class="string">"\r"</span>   <span class="operator">=~</span> <span class="regex">/^\R$/</span><span class="operator">;</span>         <span class="comment"># Match, \r   is a generic newline.</span>
 <span class="string">"\r\n"</span> <span class="operator">=~</span> <span class="regex">/^\R$/</span><span class="operator">;</span>         <span class="comment"># Match, \r\n is a generic newline.</span>
 
 <span class="string">"P\x{307}"</span> <span class="operator">=~</span> <span class="regex">/^\X$/</span>     <span class="comment"># \X matches a P with a dot above.</span>
</code></code></pre>


</body>

</html>


