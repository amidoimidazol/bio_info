<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#OVERVIEW">OVERVIEW</a>
    <ul>
      <li><a href="#A-quick-note-on-terms">A quick note on terms</a></li>
      <li><a href="#What-is-a-regular-expression-engine-">What is a regular expression engine?</a></li>
      <li><a href="#Structure-of-a-Regexp-Program">Structure of a Regexp Program</a>
        <ul>
          <li><a href="#High-Level">High Level</a></li>
          <li><a href="#Regops">Regops</a></li>
          <li><a href="#What-regop-is-next-">What regop is next?</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#Process-Overview">Process Overview</a>
    <ul>
      <li><a href="#Compilation">Compilation</a>
        <ul>
          <li><a href="#Parsing-for-size1">Parsing for size</a></li>
          <li><a href="#Parsing-for-construction1">Parsing for construction</a></li>
          <li><a href="#Parse-Call-Graph-and-a-Grammar">Parse Call Graph and a Grammar</a></li>
          <li><a href="#Debug-Output">Debug Output</a></li>
          <li><a href="#Peep-hole-Optimisation-and-Analysis">Peep-hole Optimisation and Analysis</a></li>
        </ul>
      </li>
      <li><a href="#Execution">Execution</a>
        <ul>
          <li><a href="#Start-position-and-no-match-optimisations1">Start position and no-match optimisations</a></li>
          <li><a href="#Program-execution1">Program execution</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#MISCELLANEOUS">MISCELLANEOUS</a>
    <ul>
      <li><a href="#Unicode-and-Localisation-Support">Unicode and Localisation Support</a></li>
      <li><a href="#Base-Structures">Base Structures</a>
        <ul>
          <li><a href="#Perls-structure">Perl&#39;s  structure</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENCE">LICENCE</a></li>
  <li><a href="#REFERENCES">REFERENCES</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlreguts - Description of the Perl regular expression engine.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This document is an attempt to shine some light on the guts of the regex engine and how it works. The regex engine represents a significant chunk of the perl codebase, but is relatively poorly understood. This document is a meagre attempt at addressing this situation. It is derived from the author&#39;s experience, comments in the source code, other papers on the regex engine, feedback on the perl5-porters mail list, and no doubt other places as well.</p>

<p><b>NOTICE!</b> It should be clearly understood that the behavior and structures discussed in this represents the state of the engine as the author understood it at the time of writing. It is <b>NOT</b> an API definition, it is purely an internals guide for those who want to hack the regex engine, or understand how the regex engine works. Readers of this document are expected to understand perl&#39;s regex syntax and its usage in detail. If you want to learn about the basics of Perl&#39;s regular expressions, see <a href="../../lib/pods/perlre.html">perlre</a>. And if you want to replace the regex engine with your own, see <a href="../../lib/pods/perlreapi.html">perlreapi</a>.</p>

<h1 id="OVERVIEW">OVERVIEW</h1>

<h2 id="A-quick-note-on-terms">A quick note on terms</h2>

<p>There is some debate as to whether to say &quot;regexp&quot; or &quot;regex&quot;. In this document we will use the term &quot;regex&quot; unless there is a special reason not to, in which case we will explain why.</p>

<p>When speaking about regexes we need to distinguish between their source code form and their internal form. In this document we will use the term &quot;pattern&quot; when we speak of their textual, source code form, and the term &quot;program&quot; when we speak of their internal representation. These correspond to the terms <i>S-regex</i> and <i>B-regex</i> that Mark Jason Dominus employs in his paper on &quot;Rx&quot; ([1] in <a href="#REFERENCES">&quot;REFERENCES&quot;</a>).</p>

<h2 id="What-is-a-regular-expression-engine-">What is a regular expression engine?</h2>

<p>A regular expression engine is a program that takes a set of constraints specified in a mini-language, and then applies those constraints to a target string, and determines whether or not the string satisfies the constraints. See <a href="../../lib/pods/perlre.html">perlre</a> for a full definition of the language.</p>

<p>In less grandiose terms, the first part of the job is to turn a pattern into something the computer can efficiently use to find the matching point in the string, and the second part is performing the search itself.</p>

<p>To do this we need to produce a program by parsing the text. We then need to execute the program to find the point in the string that matches. And we need to do the whole thing efficiently.</p>

<h2 id="Structure-of-a-Regexp-Program">Structure of a Regexp Program</h2>

<h3 id="High-Level">High Level</h3>

<p>Although it is a bit confusing and some people object to the terminology, it is worth taking a look at a comment that has been in <i>regexp.h</i> for years:</p>

<p><i>This is essentially a linear encoding of a nondeterministic finite-state machine (aka syntax charts or &quot;railroad normal form&quot; in parsing technology).</i></p>

<p>The term &quot;railroad normal form&quot; is a bit esoteric, with &quot;syntax diagram/charts&quot;, or &quot;railroad diagram/charts&quot; being more common terms. Nevertheless it provides a useful mental image of a regex program: each node can be thought of as a unit of track, with a single entry and in most cases a single exit point (there are pieces of track that fork, but statistically not many), and the whole forms a layout with a single entry and single exit point. The matching process can be thought of as a car that moves along the track, with the particular route through the system being determined by the character read at each possible connector point. A car can fall off the track at any point but it may only proceed as long as it matches the track.</p>

<p>Thus the pattern <code><code>/foo(?:\w+|\d+|\s+)bar/</code></code> can be thought of as the following chart:</p>

<pre><code><code>                      [start]
                         |
                       &lt;foo&gt;
                         |
                   +-----+-----+
                   |     |     |
                 &lt;\w+&gt; &lt;\d+&gt; &lt;\s+&gt;
                   |     |     |
                   +-----+-----+
                         |
                       &lt;bar&gt;
                         |
                       [end]</code></code></pre>

<p>The truth of the matter is that perl&#39;s regular expressions these days are much more complex than this kind of structure, but visualising it this way can help when trying to get your bearings, and it matches the current implementation pretty closely.</p>

<p>To be more precise, we will say that a regex program is an encoding of a graph. Each node in the graph corresponds to part of the original regex pattern, such as a literal string or a branch, and has a pointer to the nodes representing the next component to be matched. Since &quot;node&quot; and &quot;opcode&quot; already have other meanings in the perl source, we will call the nodes in a regex program &quot;regops&quot;.</p>

<p>The program is represented by an array of <code><code>regnode</code></code> structures, one or more of which represent a single regop of the program. Struct <code><code>regnode</code></code> is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</p>

<p>The &quot;next&quot; pointers of all regops except <code><code>BRANCH</code></code> implement concatenation; a &quot;next&quot; pointer with a <code><code>BRANCH</code></code> on both ends of it is connecting two alternatives. [Here we have one of the subtle syntax dependencies: an individual <code><code>BRANCH</code></code> (as opposed to a collection of them) is never concatenated with anything because of operator precedence.]</p>

<p>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a <code><code>BRANCH</code></code> node is the first regop of the branch.</p>

<p><b>NOTE</b>: As the railroad metaphor suggests, this is <b>not</b> a tree structure: the tail of the branch connects to the thing following the set of <code><code>BRANCH</code></code>es. It is a like a single line of railway track that splits as it goes into a station or railway yard and rejoins as it comes out the other side.</p>

<h3 id="Regops">Regops</h3>

<p>The base structure of a regop is defined in <i>regexp.h</i> as follows:</p>

<pre><code><code>    <span class="variable">struct</span> <span class="variable">regnode</span> <span class="operator">{</span>
        <span class="variable">U8</span>  <span class="variable">flags</span><span class="operator">;</span>    <span class="regex">/* Various purposes, sometimes overridden */</span>
        <span class="variable">U8</span>  <span class="variable">type</span><span class="operator">;</span>     <span class="regex">/* Opcode value as specified by regnodes.h */</span>
        <span class="variable">U16</span> <span class="variable">next_off</span><span class="operator">;</span> <span class="regex">/* Offset in size regnode */</span>
    <span class="operator">};</span>
</code></code></pre>

<p>Other larger <code><code>regnode</code></code>-like structures are defined in <i>regcomp.h</i>. They are almost like subclasses in that they have the same fields as <code><code>regnode</code></code>, with possibly additional fields following in the structure, and in some cases the specific meaning (and name) of some of base fields are overridden. The following is a more complete description.</p>

<dl>

<dt id="regnode_1"><code><code>regnode_1</code></code></dt>
<dd>

</dd>
<dt id="regnode_2"><code><code>regnode_2</code></code></dt>
<dd>

<p><code><code>regnode_1</code></code> structures have the same header, followed by a single four-byte argument; <code><code>regnode_2</code></code> structures contain two two-byte arguments instead:</p>

<pre><code><code>    <span class="variable">regnode_1</span>                <span class="variable">U32</span> <span class="variable">arg1</span><span class="operator">;</span>
    <span class="variable">regnode_2</span>                <span class="variable">U16</span> <span class="variable">arg1</span><span class="operator">;</span>  <span class="variable">U16</span> <span class="variable">arg2</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="regnode_string"><code><code>regnode_string</code></code></dt>
<dd>

<p><code><code>regnode_string</code></code> structures, used for literal strings, follow the header with a one-byte length and then the string data. Strings are padded on the end with zero bytes so that the total length of the node is a multiple of four bytes:</p>

<pre><code><code>    <span class="variable">regnode_string</span>           <span class="variable">char</span> <span class="variable">string</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
                             <span class="variable">U8</span> <span class="variable">str_len</span><span class="operator">;</span> <span class="regex">/* overrides flags */</span>
</code></code></pre>

</dd>
<dt id="regnode_charclass"><code><code>regnode_charclass</code></code></dt>
<dd>

<p>Character classes are represented by <code><code>regnode_charclass</code></code> structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters are included in the class.</p>

<pre><code><code>    <span class="variable">regnode_charclass</span>        <span class="variable">U32</span> <span class="variable">arg1</span><span class="operator">;</span>
                             <span class="variable">char</span> <span class="variable">bitmap</span><span class="operator">[</span><span class="variable">ANYOF_BITMAP_SIZE</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="regnode_charclass_class"><code><code>regnode_charclass_class</code></code></dt>
<dd>

<p>There is also a larger form of a char class structure used to represent POSIX char classes called <code><code>regnode_charclass_class</code></code> which has an additional 4-byte (32-bit) bitmap indicating which POSIX char classes have been included.</p>

<pre><code><code>    <span class="variable">regnode_charclass_class</span>  <span class="variable">U32</span> <span class="variable">arg1</span><span class="operator">;</span>
                             <span class="variable">char</span> <span class="variable">bitmap</span><span class="operator">[</span><span class="variable">ANYOF_BITMAP_SIZE</span><span class="operator">]</span><span class="operator">;</span>
                             <span class="variable">char</span> <span class="variable">classflags</span><span class="operator">[</span><span class="variable">ANYOF_CLASSBITMAP_SIZE</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

</dd>
</dl>

<p><i>regnodes.h</i> defines an array called <code><code>regarglen[]</code></code> which gives the size of each opcode in units of <code><code>size regnode</code></code> (4-byte). A macro is used to calculate the size of an <code><code>EXACT</code></code> node based on its <code><code>str_len</code></code> field.</p>

<p>The regops are defined in <i>regnodes.h</i> which is generated from <i>regcomp.sym</i> by <i>regcomp.pl</i>. Currently the maximum possible number of distinct regops is restricted to 256, with about a quarter already used.</p>

<p>A set of macros makes accessing the fields easier and more consistent. These include <code><code>OP()</code></code>, which is used to determine the type of a <code><code>regnode</code></code>-like structure; <code><code>NEXT_OFF()</code></code>, which is the offset to the next node (more on this later); <code><code>ARG()</code></code>, <code><code>ARG1()</code></code>, <code><code>ARG2()</code></code>, <code><code>ARG_SET()</code></code>, and equivalents for reading and setting the arguments; and <code><code>STR_LEN()</code></code>, <code><code>STRING()</code></code> and <code><code>OPERAND()</code></code> for manipulating strings and regop bearing types.</p>

<h3 id="What-regop-is-next-">What regop is next?</h3>

<p>There are three distinct concepts of &quot;next&quot; in the regex engine, and it is important to keep them clear.</p>

<ul>

<li><p>There is the &quot;next regnode&quot; from a given regnode, a value which is rarely useful except that sometimes it matches up in terms of value with one of the others, and that sometimes the code assumes this to always be so.</p>

</li>
<li><p>There is the &quot;next regop&quot; from a given regop/regnode. This is the regop physically located after the current one, as determined by the size of the current regop. This is often useful, such as when dumping the structure we use this order to traverse. Sometimes the code assumes that the &quot;next regnode&quot; is the same as the &quot;next regop&quot;, or in other words assumes that the sizeof a given regop type is always going to be one regnode large.</p>

</li>
<li><p>There is the &quot;regnext&quot; from a given regop. This is the regop which is reached by jumping forward by the value of <code><code>NEXT_OFF()</code></code>, or in a few cases for longer jumps by the <code><code>arg1</code></code> field of the <code><code>regnode_1</code></code> structure. The subroutine <code><code>regnext()</code></code> handles this transparently. This is the logical successor of the node, which in some cases, like that of the <code><code>BRANCH</code></code> regop, has special meaning.</p>

</li>
</ul>

<h1 id="Process-Overview">Process Overview</h1>

<p>Broadly speaking, performing a match of a string against a pattern involves the following steps:</p>

<dl>

<dt id="A.-Compilation">A. Compilation</dt>
<dd>

<dl>

<dt id="Parsing-for-size">1. Parsing for size</dt>
<dd>

</dd>
<dt id="Parsing-for-construction">2. Parsing for construction</dt>
<dd>

</dd>
<dt id="Peep-hole-optimisation-and-analysis">3. Peep-hole optimisation and analysis</dt>
<dd>

</dd>
</dl>

</dd>
<dt id="B.-Execution">B. Execution</dt>
<dd>

<dl>

<dt id="Start-position-and-no-match-optimisations">4. Start position and no-match optimisations</dt>
<dd>

</dd>
<dt id="Program-execution">5. Program execution</dt>
<dd>

</dd>
</dl>

</dd>
</dl>

<p>Where these steps occur in the actual execution of a perl program is determined by whether the pattern involves interpolating any string variables. If interpolation occurs, then compilation happens at run time. If it does not, then compilation is performed at compile time. (The <code><code>/o</code></code> modifier changes this, as does <code><code>qr//</code></code> to a certain extent.) The engine doesn&#39;t really care that much.</p>

<h2 id="Compilation">Compilation</h2>

<p>This code resides primarily in <i>regcomp.c</i>, along with the header files <i>regcomp.h</i>, <i>regexp.h</i> and <i>regnodes.h</i>.</p>

<p>Compilation starts with <code><code>pregcomp()</code></code>, which is mostly an initialisation wrapper which farms work out to two other routines for the heavy lifting: the first is <code><code>reg()</code></code>, which is the start point for parsing; the second, <code><code>study_chunk()</code></code>, is responsible for optimisation.</p>

<p>Initialisation in <code><code>pregcomp()</code></code> mostly involves the creation and data-filling of a special structure, <code><code>RExC_state_t</code></code> (defined in <i>regcomp.c</i>). Almost all internally-used routines in <i>regcomp.h</i> take a pointer to one of these structures as their first argument, with the name <code><code>pRExC_state</code></code>. This structure is used to store the compilation state and contains many fields. Likewise there are many macros which operate on this variable: anything that looks like <code><code>RExC_xxxx</code></code> is a macro that operates on this pointer/structure.</p>

<h3 id="Parsing-for-size1">Parsing for size</h3>

<p>In this pass the input pattern is parsed in order to calculate how much space is needed for each regop we would need to emit. The size is also used to determine whether long jumps will be required in the program.</p>

<p>This stage is controlled by the macro <code><code>SIZE_ONLY</code></code> being set.</p>

<p>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field <code><code>RExC_size</code></code> and not do anything else.</p>

<h3 id="Parsing-for-construction1">Parsing for construction</h3>

<p>Once the size of the program has been determined, the pattern is parsed again, but this time for real. Now <code><code>SIZE_ONLY</code></code> will be false, and the actual construction can occur.</p>

<p><code><code>reg()</code></code> is the start of the parse process. It is responsible for parsing an arbitrary chunk of pattern up to either the end of the string, or the first closing parenthesis it encounters in the pattern. This means it can be used to parse the top-level regex, or any section inside of a grouping parenthesis. It also handles the &quot;special parens&quot; that perl&#39;s regexes have. For instance when parsing <code><code>/x(?:foo)y/</code></code> <code><code>reg()</code></code> will at one point be called to parse from the &quot;?&quot; symbol up to and including the &quot;)&quot;.</p>

<p>Additionally, <code><code>reg()</code></code> is responsible for parsing the one or more branches from the pattern, and for &quot;finishing them off&quot; by correctly setting their next pointers. In order to do the parsing, it repeatedly calls out to <code><code>regbranch()</code></code>, which is responsible for handling up to the first <code><code>|</code></code> symbol it sees.</p>

<p><code><code>regbranch()</code></code> in turn calls <code><code>regpiece()</code></code> which handles &quot;things&quot; followed by a quantifier. In order to parse the &quot;things&quot;, <code><code>regatom()</code></code> is called. This is the lowest level routine, which parses out constant strings, character classes, and the various special symbols like <code><code>$</code></code>. If <code><code>regatom()</code></code> encounters a &quot;(&quot; character it in turn calls <code><code>reg()</code></code>.</p>

<p>The routine <code><code>regtail()</code></code> is called by both <code><code>reg()</code></code> and <code><code>regbranch()</code></code> in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don&#39;t know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. <code><code>regtail</code></code> is used to make this easier.</p>

<p>A subtlety of the parsing process means that a regex like <code><code>/foo/</code></code> is originally parsed into an alternation with a single branch. It is only afterwards that the optimiser converts single branch alternations into the simpler form.</p>

<h3 id="Parse-Call-Graph-and-a-Grammar">Parse Call Graph and a Grammar</h3>

<p>The call graph looks like this:</p>

<pre><code><code>    reg()                        # parse a top level regex, or inside of parens
        regbranch()              # parse a single branch of an alternation
            regpiece()           # parse a pattern followed by a quantifier
                regatom()        # parse a simple pattern
                    regclass()   #   used to handle a class
                    reg()        #   used to handle a parenthesised subpattern
                    ....
            ...
            regtail()            # finish off the branch
        ...
        regtail()                # finish off the branch sequence. Tie each
                                 # branch&#39;s tail to the tail of the sequence
                                 # (NEW) In Debug mode this is
                                 # regtail_study().</code></code></pre>

<p>A grammar form might be something like this:</p>

<pre><code><code>    <span class="variable">atom</span>  <span class="operator">:</span> <span class="variable">constant</span> <span class="operator">|</span> <span class="variable">class</span>
    <span class="variable">quant</span> <span class="operator">:</span> <span class="string">'*'</span> <span class="operator">|</span> <span class="string">'+'</span> <span class="operator">|</span> <span class="string">'?'</span> <span class="operator">|</span> <span class="string">'{min,max}'</span>
    <span class="variable">_branch</span><span class="operator">:</span> <span class="variable">piece</span>
           <span class="operator">|</span> <span class="variable">piece</span> <span class="variable">_branch</span>
           <span class="operator">|</span> <span class="variable">nothing</span>
    <span class="variable">branch</span><span class="operator">:</span> <span class="variable">_branch</span>
          <span class="operator">|</span> <span class="variable">_branch</span> <span class="string">'|'</span> <span class="variable">branch</span>
    <span class="variable">group</span> <span class="operator">:</span> <span class="string">'('</span> <span class="variable">branch</span> <span class="string">')'</span>
    <span class="variable">_piece</span><span class="operator">:</span> <span class="variable">atom</span> <span class="operator">|</span> <span class="variable">group</span>
    <span class="variable">piece</span> <span class="operator">:</span> <span class="variable">_piece</span>
          <span class="operator">|</span> <span class="variable">_piece</span> <span class="variable">quant</span>
</code></code></pre>

<h3 id="Debug-Output">Debug Output</h3>

<p>In the 5.9.x development version of perl you can <code><code>use re Debug =&gt; &#39;PARSE&#39;</code></code> to see some trace information about the parse process. We will start with some simple patterns and build up to more complex patterns.</p>

<p>So when we parse <code><code>/foo/</code></code> we see something like the following table. The left shows what is being parsed, and the number indicates where the next regop would go. The stuff on the right is the trace output of the graph. The names are chosen to be short to make it less dense on the screen. &#39;tsdy&#39; is a special form of <code><code>regtail()</code></code> which does some extra analysis.</p>

<pre><code><code> &gt;foo&lt;             1    reg
                          brnc
                            piec
                              atom
 &gt;&lt;                4      tsdy~ EXACT &lt;foo&gt; (EXACT) (1)
                              ~ attach to END (3) offset to 2</code></code></pre>

<p>The resulting program then looks like:</p>

<pre><code><code>   1: EXACT &lt;foo&gt;(3)
   3: END(0)</code></code></pre>

<p>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an <code><code>EXACT</code></code> regop, followed by an <code><code>END</code></code> regop. The number in parens indicates where the <code><code>regnext</code></code> of the node goes. The <code><code>regnext</code></code> of an <code><code>END</code></code> regop is unused, as <code><code>END</code></code> regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</p>

<p>Now let&#39;s try a harder pattern. We will add a quantifier, so now we have the pattern <code><code>/foo+/</code></code>. We will see that <code><code>regbranch()</code></code> calls <code><code>regpiece()</code></code> twice.</p>

<pre><code><code> &gt;foo+&lt;            1    reg
                          brnc
                            piec
                              atom
 &gt;o+&lt;              3        piec
                              atom
 &gt;&lt;                6        tail~ EXACT &lt;fo&gt; (1)
                   7      tsdy~ EXACT &lt;fo&gt; (EXACT) (1)
                              ~ PLUS (END) (3)
                              ~ attach to END (6) offset to 3</code></code></pre>

<p>And we end up with the program:</p>

<pre><code><code>   1: EXACT &lt;fo&gt;(3)
   3: PLUS(6)
   4:   EXACT &lt;o&gt;(0)
   6: END(0)</code></code></pre>

<p>Now we have a special case. The <code><code>EXACT</code></code> regop has a <code><code>regnext</code></code> of 0. This is because if it matches it should try to match itself again. The <code><code>PLUS</code></code> regop handles the actual failure of the <code><code>EXACT</code></code> regop and acts appropriately (going to regnode 6 if the <code><code>EXACT</code></code> matched at least once, or failing if it didn&#39;t).</p>

<p>Now for something much more complex: <code><code>/x(?:foo*|b[a][rR])(foo|bar)$/</code></code></p>

<pre><code><code> &gt;x(?:foo*|b...    1    reg
                          brnc
                            piec
                              atom
 &gt;(?:foo*|b[...    3        piec
                              atom
 &gt;?:foo*|b[a...                 reg
 &gt;foo*|b[a][...                   brnc
                                    piec
                                      atom
 &gt;o*|b[a][rR...    5                piec
                                      atom
 &gt;|b[a][rR])...    8                tail~ EXACT &lt;fo&gt; (3)
 &gt;b[a][rR])(...    9              brnc
                  10                piec
                                      atom
 &gt;[a][rR])(f...   12                piec
                                      atom
 &gt;a][rR])(fo...                         clas
 &gt;[rR])(foo|...   14                tail~ EXACT &lt;b&gt; (10)
                                    piec
                                      atom
 &gt;rR])(foo|b...                         clas
 &gt;)(foo|bar)...   25                tail~ EXACT &lt;a&gt; (12)
                                  tail~ BRANCH (3)
                  26              tsdy~ BRANCH (END) (9)
                                      ~ attach to TAIL (25) offset to 16
                                  tsdy~ EXACT &lt;fo&gt; (EXACT) (4)
                                      ~ STAR (END) (6)
                                      ~ attach to TAIL (25) offset to 19
                                  tsdy~ EXACT &lt;b&gt; (EXACT) (10)
                                      ~ EXACT &lt;a&gt; (EXACT) (12)
                                      ~ ANYOF[Rr] (END) (14)
                                      ~ attach to TAIL (25) offset to 11
 &gt;(foo|bar)$&lt;               tail~ EXACT &lt;x&gt; (1)
                            piec
                              atom
 &gt;foo|bar)$&lt;                    reg
                  28              brnc
                                    piec
                                      atom
 &gt;|bar)$&lt;         31              tail~ OPEN1 (26)
 &gt;bar)$&lt;                          brnc
                  32                piec
                                      atom
 &gt;)$&lt;             34              tail~ BRANCH (28)
                  36              tsdy~ BRANCH (END) (31)
                                      ~ attach to CLOSE1 (34) offset to 3
                                  tsdy~ EXACT &lt;foo&gt; (EXACT) (29)
                                      ~ attach to CLOSE1 (34) offset to 5
                                  tsdy~ EXACT &lt;bar&gt; (EXACT) (32)
                                      ~ attach to CLOSE1 (34) offset to 2
 &gt;$&lt;                        tail~ BRANCH (3)
                                ~ BRANCH (9)
                                ~ TAIL (25)
                            piec
                              atom
 &gt;&lt;               37        tail~ OPEN1 (26)
                                ~ BRANCH (28)
                                ~ BRANCH (31)
                                ~ CLOSE1 (34)
                  38      tsdy~ EXACT &lt;x&gt; (EXACT) (1)
                              ~ BRANCH (END) (3)
                              ~ BRANCH (END) (9)
                              ~ TAIL (END) (25)
                              ~ OPEN1 (END) (26)
                              ~ BRANCH (END) (28)
                              ~ BRANCH (END) (31)
                              ~ CLOSE1 (END) (34)
                              ~ EOL (END) (36)
                              ~ attach to END (37) offset to 1</code></code></pre>

<p>Resulting in the program</p>

<pre><code><code>   1: EXACT &lt;x&gt;(3)
   3: BRANCH(9)
   4:   EXACT &lt;fo&gt;(6)
   6:   STAR(26)
   7:     EXACT &lt;o&gt;(0)
   9: BRANCH(25)
  10:   EXACT &lt;ba&gt;(14)
  12:   OPTIMIZED (2 nodes)
  14:   ANYOF[Rr](26)
  25: TAIL(26)
  26: OPEN1(28)
  28:   TRIE-EXACT(34)
        [StS:1 Wds:2 Cs:6 Uq:5 #Sts:7 Mn:3 Mx:3 Stcls:bf]
          &lt;foo&gt;
          &lt;bar&gt;
  30:   OPTIMIZED (4 nodes)
  34: CLOSE1(36)
  36: EOL(37)
  37: END(0)</code></code></pre>

<p>Here we can see a much more complex program, with various optimisations in play. At regnode 10 we see an example where a character class with only one character in it was turned into an <code><code>EXACT</code></code> node. We can also see where an entire alternation was turned into a <code><code>TRIE-EXACT</code></code> node. As a consequence, some of the regnodes have been marked as optimised away. We can see that the <code><code>$</code></code> symbol has been converted into an <code><code>EOL</code></code> regop, a special piece of code that looks for <code><code>\n</code></code> or the end of the string.</p>

<p>The next pointer for <code><code>BRANCH</code></code>es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a <code><code>regnext</code></code> that isn&#39;t a branch then the engine will know that the entire set of branches has failed.</p>

<h3 id="Peep-hole-Optimisation-and-Analysis">Peep-hole Optimisation and Analysis</h3>

<p>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</p>

<pre><code><code>   &#39;ababababababababababab&#39; =~ /(a|b)*z/</code></code></pre>

<p>The <code><code>(a|b)*</code></code> part can match at every char in the string, and then fail every time because there is no <code><code>z</code></code> in the string. So obviously we can avoid using the regex engine unless there is a <code><code>z</code></code> in the string. Likewise in a pattern like:</p>

<pre><code><code>   /foo(\w+)bar/</code></code></pre>

<p>In this case we know that the string must contain a <code><code>foo</code></code> which must be followed by <code><code>bar</code></code>. We can use Fast Boyer-Moore matching as implemented in <code><code>fbm_instr()</code></code> to find the location of these strings. If they don&#39;t exist then we don&#39;t need to resort to the much more expensive regex engine. Even better, if they do exist then we can use their positions to reduce the search space that the regex engine needs to cover to determine if the entire pattern matches.</p>

<p>There are various aspects of the pattern that can be used to facilitate optimisations along these lines:</p>

<ul>

<li><p>anchored fixed strings</p>

</li>
<li><p>floating fixed strings</p>

</li>
<li><p>minimum and maximum length requirements</p>

</li>
<li><p>start class</p>

</li>
<li><p>Beginning/End of line positions</p>

</li>
</ul>

<p>Another form of optimisation that can occur is the post-parse &quot;peep-hole&quot; optimisation, where inefficient constructs are replaced by more efficient constructs. The <code><code>TAIL</code></code> regops which are used during parsing to mark the end of branches and the end of groups are examples of this. These regops are used as place-holders during construction and &quot;always match&quot; so they can be &quot;optimised away&quot; by making the things that point to the <code><code>TAIL</code></code> point to the thing that <code><code>TAIL</code></code> points to, thus &quot;skipping&quot; the node.</p>

<p>Another optimisation that can occur is that of &quot;<code><code>EXACT</code></code> merging&quot; which is where two consecutive <code><code>EXACT</code></code> nodes are merged into a single regop. An even more aggressive form of this is that a branch sequence of the form <code><code>EXACT BRANCH ... EXACT</code></code> can be converted into a <code><code>TRIE-EXACT</code></code> regop.</p>

<p>All of this occurs in the routine <code><code>study_chunk()</code></code> which uses a special structure <code><code>scan_data_t</code></code> to store the analysis that it has performed, and does the &quot;peep-hole&quot; optimisations as it goes.</p>

<p>The code involved in <code><code>study_chunk()</code></code> is extremely cryptic. Be careful. :-)</p>

<h2 id="Execution">Execution</h2>

<p>Execution of a regex generally involves two phases, the first being finding the start point in the string where we should match from, and the second being running the regop interpreter.</p>

<p>If we can tell that there is no valid start point then we don&#39;t bother running interpreter at all. Likewise, if we know from the analysis phase that we cannot detect a short-cut to the start position, we go straight to the interpreter.</p>

<p>The two entry points are <code><code>re_intuit_start()</code></code> and <code><code>pregexec()</code></code>. These routines have a somewhat incestuous relationship with overlap between their functions, and <code><code>pregexec()</code></code> may even call <code><code>re_intuit_start()</code></code> on its own. Nevertheless other parts of the perl source code may call into either, or both.</p>

<p>Execution of the interpreter itself used to be recursive, but thanks to the efforts of Dave Mitchell in the 5.9.x development track, that has changed: now an internal stack is maintained on the heap and the routine is fully iterative. This can make it tricky as the code is quite conservative about what state it stores, with the result that two consecutive lines in the code can actually be running in totally different contexts due to the simulated recursion.</p>

<h3 id="Start-position-and-no-match-optimisations1">Start position and no-match optimisations</h3>

<p><code><code>re_intuit_start()</code></code> is responsible for handling start points and no-match optimisations as determined by the results of the analysis done by <code><code>study_chunk()</code></code> (and described in <a href="#Peep-hole-Optimisation-and-Analysis">&quot;Peep-hole Optimisation and Analysis&quot;</a>).</p>

<p>The basic structure of this routine is to try to find the start- and/or end-points of where the pattern could match, and to ensure that the string is long enough to match the pattern. It tries to use more efficient methods over less efficient methods and may involve considerable cross-checking of constraints to find the place in the string that matches. For instance it may try to determine that a given fixed string must be not only present but a certain number of chars before the end of the string, or whatever.</p>

<p>It calls several other routines, such as <code><code>fbm_instr()</code></code> which does Fast Boyer Moore matching and <code><code>find_byclass()</code></code> which is responsible for finding the start using the first mandatory regop in the program.</p>

<p>When the optimisation criteria have been satisfied, <code><code>reg_try()</code></code> is called to perform the match.</p>

<h3 id="Program-execution1">Program execution</h3>

<p><code><code>pregexec()</code></code> is the main entry point for running a regex. It contains support for initialising the regex interpreter&#39;s state, running <code><code>re_intuit_start()</code></code> if needed, and running the interpreter on the string from various start positions as needed. When it is necessary to use the regex interpreter <code><code>pregexec()</code></code> calls <code><code>regtry()</code></code>.</p>

<p><code><code>regtry()</code></code> is the entry point into the regex interpreter. It expects as arguments a pointer to a <code><code>regmatch_info</code></code> structure and a pointer to a string. It returns an integer 1 for success and a 0 for failure. It is basically a set-up wrapper around <code><code>regmatch()</code></code>.</p>

<p><code><code>regmatch</code></code> is the main &quot;recursive loop&quot; of the interpreter. It is basically a giant switch statement that implements a state machine, where the possible states are the regops themselves, plus a number of additional intermediate and failure states. A few of the states are implemented as subroutines but the bulk are inline code.</p>

<h1 id="MISCELLANEOUS">MISCELLANEOUS</h1>

<h2 id="Unicode-and-Localisation-Support">Unicode and Localisation Support</h2>

<p>When dealing with strings containing characters that cannot be represented using an eight-bit character set, perl uses an internal representation that is a permissive version of Unicode&#39;s UTF-8 encoding[2]. This uses single bytes to represent characters from the ASCII character set, and sequences of two or more bytes for all other characters. (See <a href="../../lib/pods/perlunitut.html">perlunitut</a> for more information about the relationship between UTF-8 and perl&#39;s encoding, utf8. The difference isn&#39;t important for this discussion.)</p>

<p>No matter how you look at it, Unicode support is going to be a pain in a regex engine. Tricks that might be fine when you have 256 possible characters often won&#39;t scale to handle the size of the UTF-8 character set. Things you can take for granted with ASCII may not be true with Unicode. For instance, in ASCII, it is safe to assume that <code><code>sizeof(char1) == sizeof(char2)</code></code>, but in UTF-8 it isn&#39;t. Unicode case folding is vastly more complex than the simple rules of ASCII, and even when not using Unicode but only localised single byte encodings, things can get tricky (for example, <b>LATIN SMALL LETTER SHARP S</b> (U+00DF, &szlig;) should match &#39;SS&#39; in localised case-insensitive matching).</p>

<p>Making things worse is that UTF-8 support was a later addition to the regex engine (as it was to perl) and this necessarily made things a lot more complicated. Obviously it is easier to design a regex engine with Unicode support in mind from the beginning than it is to retrofit it to one that wasn&#39;t.</p>

<p>Nearly all regops that involve looking at the input string have two cases, one for UTF-8, and one not. In fact, it&#39;s often more complex than that, as the pattern may be UTF-8 as well.</p>

<p>Care must be taken when making changes to make sure that you handle UTF-8 properly, both at compile time and at execution time, including when the string and pattern are mismatched.</p>

<p>The following comment in <i>regcomp.h</i> gives an example of exactly how tricky this can be:</p>

<pre><code><code>    Two problematic code points in Unicode casefolding of EXACT nodes:

    U+0390 - GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS
    U+03B0 - GREEK SMALL LETTER UPSILON WITH DIALYTIKA AND TONOS

    which casefold to

    Unicode                      UTF-8

    U+03B9 U+0308 U+0301         0xCE 0xB9 0xCC 0x88 0xCC 0x81
    U+03C5 U+0308 U+0301         0xCF 0x85 0xCC 0x88 0xCC 0x81

    This means that in case-insensitive matching (or &quot;loose matching&quot;,
    as Unicode calls it), an EXACTF of length six (the UTF-8 encoded
    byte length of the above casefolded versions) can match a target
    string of length two (the byte length of UTF-8 encoded U+0390 or
    U+03B0). This would rather mess up the minimum length computation.

    What we&#39;ll do is to look for the tail four bytes, and then peek
    at the preceding two bytes to see whether we need to decrease
    the minimum length by four (six minus two).

    Thanks to the design of UTF-8, there cannot be false matches:
    A sequence of valid UTF-8 bytes cannot be a subsequence of
    another valid sequence of UTF-8 bytes.</code></code></pre>

<h2 id="Base-Structures">Base Structures</h2>

<p>The <code><code>regexp</code></code> structure described in <a href="../../lib/pods/perlreapi.html">perlreapi</a> is common to all regex engines. Two of its fields that are intended for the private use of the regex engine that compiled the pattern. These are the <code><code>intflags</code></code> and pprivate members. The <code><code>pprivate</code></code> is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by <code><code>pprivate</code></code> is called <code><code>regexp_internal</code></code>.</p>

<p>Its <code><code>pprivate</code></code> and <code><code>intflags</code></code> fields contain data specific to each engine.</p>

<p>There are two structures used to store a compiled regular expression. One, the <code><code>regexp</code></code> structure described in <a href="../../lib/pods/perlreapi.html">perlreapi</a> is populated by the engine currently being. used and some of its fields read by perl to implement things such as the stringification of <code><code>qr//</code></code>.</p>

<p>The other structure is pointed to be the <code><code>regexp</code></code> struct&#39;s <code><code>pprivate</code></code> and is in addition to <code><code>intflags</code></code> in the same struct considered to be the property of the regex engine which compiled the regular expression;</p>

<p>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</p>

<p>In addition it contains two fields that are intended for the private use of the regex engine that compiled the pattern. These are the <code><code>intflags</code></code> and pprivate members. The <code><code>pprivate</code></code> is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values.</p>

<p>As mentioned earlier, in the case of the default engines, the <code><code>pprivate</code></code> will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</p>

<h3 id="Perls-structure">Perl&#39;s <code><code>pprivate</code></code> structure</h3>

<p>The following structure is used as the <code><code>pprivate</code></code> struct by perl&#39;s regex engine. Since it is specific to perl it is only of curiosity value to other engine implementations.</p>

<pre><code><code>    <span class="variable">typedef</span> <span class="variable">struct</span> <span class="variable">regexp_internal</span> <span class="operator">{</span>
            <span class="variable">regexp_paren_ofs</span> <span class="variable">*swap</span><span class="operator">;</span> <span class="regex">/* Swap copy of *startp /</span> <span class="variable">*endp</span> <span class="operator">*/</span>
            <span class="variable">U32</span> <span class="variable">*offsets</span><span class="operator">;</span>           <span class="regex">/* offset annotations 20001228 MJD 
                                       data about mapping the program to the 
                                       string*/</span>
            <span class="variable">regnode</span> <span class="variable">*regstclass</span><span class="operator">;</span>    <span class="regex">/* Optional startclass as identified or constructed
                                       by the optimiser */</span>
            <span class="variable">struct</span> <span class="variable">reg_data</span> <span class="variable">*data</span><span class="operator">;</span>  <span class="regex">/* Additional miscellaneous data used by the program.
                                       Used to make it easier to clone and free arbitrary
                                       data that the regops need. Often the ARG field of
                                       a regop is an index into this structure */</span>
            <span class="variable">regnode</span> <span class="variable">program</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>     <span class="regex">/* Unwarranted chumminess with compiler. */</span>
    <span class="operator">}</span> <span class="variable">regexp_internal</span><span class="operator">;</span>
</code></code></pre>

<dl>

<dt id="swap"><code><code>swap</code></code></dt>
<dd>

<p><code><code>swap</code></code> formerly was an extra set of startp/endp stored in a <code><code>regexp_paren_ofs</code></code> struct. This was used when the last successful match was from the same pattern as the current pattern, so that a partial match didn&#39;t overwrite the previous match&#39;s results, but it caused a problem with re-entrant code such as trying to build the UTF-8 swashes. Currently unused and left for backward compatibility with 5.10.0.</p>

</dd>
<dt id="offsets"><code><code>offsets</code></code></dt>
<dd>

<p>Offsets holds a mapping of offset in the <code><code>program</code></code> to offset in the <code><code>precomp</code></code> string. This is only used by ActiveState&#39;s visual regex debugger.</p>

</dd>
<dt id="regstclass"><code><code>regstclass</code></code></dt>
<dd>

<p>Special regop that is used by <code><code>re_intuit_start()</code></code> to check if a pattern can match at a certain position. For instance if the regex engine knows that the pattern must start with a &#39;Z&#39; then it can scan the string until it finds one and then launch the regex engine from there. The routine that handles this is called <code><code>find_by_class()</code></code>. Sometimes this field points at a regop embedded in the program, and sometimes it points at an independent synthetic regop that has been constructed by the optimiser.</p>

</dd>
<dt id="data"><code><code>data</code></code></dt>
<dd>

<p>This field points at a reg_data structure, which is defined as follows</p>

<pre><code><code>    <span class="variable">struct</span> <span class="variable">reg_data</span> <span class="operator">{</span>
        <span class="variable">U32</span> <span class="variable">count</span><span class="operator">;</span>
        <span class="variable">U8</span> <span class="variable">*what</span><span class="operator">;</span>
        <span class="variable">void</span><span class="operator">*</span> <span class="variable">data</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">;</span>
    <span class="operator">};</span>
</code></code></pre>

<p>This structure is used for handling data structures that the regex engine needs to handle specially during a clone or free operation on the compiled product. Each element in the data array has a corresponding element in the what array. During compilation regops that need special structures stored will add an element to each array using the add_data() routine and then store the index in the regop.</p>

</dd>
<dt id="program"><code><code>program</code></code></dt>
<dd>

<p>Compiled program. Inlined into the structure so the entire struct can be treated as a single blob.</p>

</dd>
</dl>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../lib/pods/perlreapi.html">perlreapi</a></p>

<p><a href="../../lib/pods/perlre.html">perlre</a></p>

<p><a href="../../lib/pods/perlunitut.html">perlunitut</a></p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>by Yves Orton, 2006.</p>

<p>With excerpts from Perl, and contributions and suggestions from Ronald J. Kimball, Dave Mitchell, Dominic Dunlop, Mark Jason Dominus, Stephen McCamant, and David Landgren.</p>

<h1 id="LICENCE">LICENCE</h1>

<p>Same terms as Perl.</p>

<h1 id="REFERENCES">REFERENCES</h1>

<p>[1] <a href="http://perl.plover.com/Rx/paper/">http://perl.plover.com/Rx/paper/</a></p>

<p>[2] <a href="http://www.unicode.org">http://www.unicode.org</a></p>


</body>

</html>


