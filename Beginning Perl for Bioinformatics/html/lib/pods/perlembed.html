<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#PREAMBLE">PREAMBLE</a></li>
      <li><a href="#ROADMAP">ROADMAP</a></li>
      <li><a href="#Compiling-your-C-program">Compiling your C program</a></li>
      <li><a href="#Adding-a-Perl-interpreter-to-your-C-program">Adding a Perl interpreter to your C program</a></li>
      <li><a href="#Calling-a-Perl-subroutine-from-your-C-program">Calling a Perl subroutine from your C program</a></li>
      <li><a href="#Evaluating-a-Perl-statement-from-your-C-program">Evaluating a Perl statement from your C program</a></li>
      <li><a href="#Performing-Perl-pattern-matches-and-substitutions-from-your-C-program">Performing Perl pattern matches and substitutions from your C program</a></li>
      <li><a href="#Fiddling-with-the-Perl-stack-from-your-C-program">Fiddling with the Perl stack from your C program</a></li>
      <li><a href="#Maintaining-a-persistent-interpreter">Maintaining a persistent interpreter</a></li>
      <li><a href="#Execution-of-END-blocks">Execution of END blocks</a></li>
      <li><a href="#assignments">$0 assignments</a></li>
      <li><a href="#Maintaining-multiple-interpreter-instances">Maintaining multiple interpreter instances</a></li>
      <li><a href="#Using-Perl-modules-which-themselves-use-C-libraries-from-your-C-program">Using Perl modules, which themselves use C libraries, from your C program</a></li>
    </ul>
  </li>
  <li><a href="#Hiding-Perl_">Hiding Perl_</a></li>
  <li><a href="#MORAL">MORAL</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlembed - how to embed perl in your C program</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<h2 id="PREAMBLE">PREAMBLE</h2>

<p>Do you want to:</p>

<dl>

<dt id="Use-C-from-Perl-"><b>Use C from Perl?</b></dt>
<dd>

<p>Read <a href="../../lib/pods/perlxstut.html">perlxstut</a>, <a href="../../lib/pods/perlxs.html">perlxs</a>, <a href="../../bin/h2xs.html">h2xs</a>, <a href="../../lib/pods/perlguts.html">perlguts</a>, and <a href="../../lib/pods/perlapi.html">perlapi</a>.</p>

</dd>
<dt id="Use-a-Unix-program-from-Perl-"><b>Use a Unix program from Perl?</b></dt>
<dd>

<p>Read about back-quotes and about <code><code>system</code></code> and <code><code>exec</code></code> in <a href="../../lib/pods/perlfunc.html">perlfunc</a>.</p>

</dd>
<dt id="Use-Perl-from-Perl-"><b>Use Perl from Perl?</b></dt>
<dd>

<p>Read about <a href="../../lib/pods/perlfunc.html#do">&quot;do&quot; in perlfunc</a> and <a href="../../lib/pods/perlfunc.html#eval">&quot;eval&quot; in perlfunc</a> and <a href="../../lib/pods/perlfunc.html#require">&quot;require&quot; in perlfunc</a> and <a href="../../lib/pods/perlfunc.html#use">&quot;use&quot; in perlfunc</a>.</p>

</dd>
<dt id="Use-C-from-C-"><b>Use C from C?</b></dt>
<dd>

<p>Rethink your design.</p>

</dd>
<dt id="Use-Perl-from-C-"><b>Use Perl from C?</b></dt>
<dd>

<p>Read on...</p>

</dd>
</dl>

<h2 id="ROADMAP">ROADMAP</h2>

<ul>

<li><p>Compiling your C program</p>

</li>
<li><p>Adding a Perl interpreter to your C program</p>

</li>
<li><p>Calling a Perl subroutine from your C program</p>

</li>
<li><p>Evaluating a Perl statement from your C program</p>

</li>
<li><p>Performing Perl pattern matches and substitutions from your C program</p>

</li>
<li><p>Fiddling with the Perl stack from your C program</p>

</li>
<li><p>Maintaining a persistent interpreter</p>

</li>
<li><p>Maintaining multiple interpreter instances</p>

</li>
<li><p>Using Perl modules, which themselves use C libraries, from your C program</p>

</li>
<li><p>Embedding Perl under Win32</p>

</li>
</ul>

<h2 id="Compiling-your-C-program">Compiling your C program</h2>

<p>If you have trouble compiling the scripts in this documentation, you&#39;re not alone. The cardinal rule: COMPILE THE PROGRAMS IN EXACTLY THE SAME WAY THAT YOUR PERL WAS COMPILED. (Sorry for yelling.)</p>

<p>Also, every C program that uses Perl must link in the <i>perl library</i>. What&#39;s that, you ask? Perl is itself written in C; the perl library is the collection of compiled C programs that were used to create your perl executable (<i>/usr/bin/perl</i> or equivalent). (Corollary: you can&#39;t use Perl from your C program unless Perl has been compiled on your machine, or installed properly--that&#39;s why you shouldn&#39;t blithely copy Perl executables from machine to machine without also copying the <i>lib</i> directory.)</p>

<p>When you use Perl from C, your C program will--usually--allocate, &quot;run&quot;, and deallocate a <i>PerlInterpreter</i> object, which is defined by the perl library.</p>

<p>If your copy of Perl is recent enough to contain this documentation (version 5.002 or later), then the perl library (and <i>EXTERN.h</i> and <i>perl.h</i>, which you&#39;ll also need) will reside in a directory that looks like this:</p>

<pre><code><code>    /usr/local/lib/perl5/your_architecture_here/CORE</code></code></pre>

<p>or perhaps just</p>

<pre><code><code>    /usr/local/lib/perl5/CORE</code></code></pre>

<p>or maybe something like</p>

<pre><code><code>    /usr/opt/perl5/CORE</code></code></pre>

<p>Execute this statement for a hint about where to find CORE:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MConfig</span> <span class="keyword">-e</span> <span class="string">'print $Config{archlib}'</span>
</code></code></pre>

<p>Here&#39;s how you&#39;d compile the example in the next section, <a href="#Adding-a-Perl-interpreter-to-your-C-program">&quot;Adding a Perl interpreter to your C program&quot;</a>, on my Linux box:</p>

<pre><code><code>    % gcc -O2 -Dbool=char -DHAS_BOOL -I/usr/local/include
    -I/usr/local/lib/perl5/i586-linux/5.003/CORE
    -L/usr/local/lib/perl5/i586-linux/5.003/CORE
    -o interp interp.c -lperl -lm</code></code></pre>

<p>(That&#39;s all one line.) On my DEC Alpha running old 5.003_05, the incantation is a bit different:</p>

<pre><code><code>    % cc -O2 -Olimit 2900 -DSTANDARD_C -I/usr/local/include
    -I/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE
    -L/usr/local/lib/perl5/alpha-dec_osf/5.00305/CORE -L/usr/local/lib
    -D__LANGUAGE_C__ -D_NO_PROTO -o interp interp.c -lperl -lm</code></code></pre>

<p>How can you figure out what to add? Assuming your Perl is post-5.001, execute a <code><code>perl -V</code></code> command and pay special attention to the &quot;cc&quot; and &quot;ccflags&quot; information.</p>

<p>You&#39;ll have to choose the appropriate compiler (<i>cc</i>, <i>gcc</i>, et al.) for your machine: <code><code><span class="variable">perl</span> <span class="operator">-</span><span class="variable">MConfig</span> <span class="keyword">-e</span> <span class="string">'print $Config{cc}'</span>
</code></code> will tell you what to use.</p>

<p>You&#39;ll also have to choose the appropriate library directory (<i>/usr/local/lib/...</i>) for your machine. If your compiler complains that certain functions are undefined, or that it can&#39;t locate <i>-lperl</i>, then you need to change the path following the <code><code>-L</code></code>. If it complains that it can&#39;t find <i>EXTERN.h</i> and <i>perl.h</i>, you need to change the path following the <code><code>-I</code></code>.</p>

<p>You may have to add extra libraries as well. Which ones? Perhaps those printed by</p>

<pre><code><code>   <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MConfig</span> <span class="keyword">-e</span> <span class="string">'print $Config{libs}'</span>
</code></code></pre>

<p>Provided your perl binary was properly configured and installed the <b>ExtUtils::Embed</b> module will determine all of this information for you:</p>

<pre><code><code>   % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`</code></code></pre>

<p>If the <b>ExtUtils::Embed</b> module isn&#39;t part of your Perl distribution, you can retrieve it from http://www.perl.com/perl/CPAN/modules/by-module/ExtUtils/ (If this documentation came from your Perl distribution, then you&#39;re running 5.004 or better and you already have it.)</p>

<p>The <b>ExtUtils::Embed</b> kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</p>

<h2 id="Adding-a-Perl-interpreter-to-your-C-program">Adding a Perl interpreter to your C program</h2>

<p>In a sense, perl (the C program) is a good example of embedding Perl (the language), so I&#39;ll demonstrate embedding with <i>miniperlmain.c</i>, included in the source distribution. Here&#39;s a bastardized, non-portable version of <i>miniperlmain.c</i> containing the essentials of embedding:</p>

<pre><code><code>    <span class="comment">#include &lt;EXTERN.h&gt;               /* from the Perl distribution     */</span>
    <span class="comment">#include &lt;perl.h&gt;                 /* from the Perl distribution     */</span>
    
    <span class="variable">static</span> <span class="variable">PerlInterpreter</span> <span class="variable">*my_perl</span><span class="operator">;</span>  <span class="regex">/***    The Perl interpreter    ***/</span>
    
    <span class="keyword">int</span> <span class="variable">main</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
        <span class="variable">my_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
        <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">PL_exit_flags</span> <span class="operator">|=</span> <span class="variable">PERL_EXIT_DESTRUCT_END</span><span class="operator">;</span>
        <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">argv</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">char</span> <span class="operator">**)</span><span class="variable">NULL</span><span class="operator">);</span>
        <span class="variable">perl_run</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">PERL_SYS_TERM</span><span class="operator">();</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Notice that we don&#39;t use the <code><code>env</code></code> pointer. Normally handed to <code><code>perl_parse</code></code> as its final argument, <code><code>env</code></code> here is replaced by <code><code>NULL</code></code>, which means that the current environment will be used.</p>

<p>The macros PERL_SYS_INIT3() and PERL_SYS_TERM() provide system-specific tune up of the C runtime environment necessary to run Perl interpreters; they should only be called once regardless of how many interpreters you create or destroy. Call PERL_SYS_INIT3() before you create your first interpreter, and PERL_SYS_TERM() after you free your last interpreter.</p>

<p>Since PERL_SYS_INIT3() may change <code><code>env</code></code>, it may be more appropriate to provide <code><code>env</code></code> as an argument to perl_parse().</p>

<p>Also notice that no matter what arguments you pass to perl_parse(), PERL_SYS_INIT3() must be invoked on the C main() argc, argv and env and only once.</p>

<p>Now compile this program (I&#39;ll call it <i>interp.c</i>) into an executable:</p>

<pre><code><code>    % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`</code></code></pre>

<p>After a successful compilation, you&#39;ll be able to use <i>interp</i> just like perl itself:</p>

<pre><code><code>    <span class="operator">% </span><span class="variable">interp</span>
    <span class="keyword">print</span> <span class="string">"Pretty Good Perl \n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"10890 - 9801 is "</span><span class="operator">,</span> <span class="number">10890</span> <span class="operator">-</span> <span class="number">9801</span><span class="operator">;</span>
    <span class="operator">&lt;</span><span class="variable">CTRL</span><span class="operator">-</span><span class="variable">D</span><span class="operator">&gt;</span>
    <span class="variable">Pretty</span> <span class="variable">Good</span> <span class="variable">Perl</span>
    <span class="number">10890</span> <span class="operator">-</span> <span class="number">9801</span> <span class="variable">is</span> <span class="number">1089</span>
</code></code></pre>

<p>or</p>

<pre><code><code>    % interp -e &#39;printf(&quot;%x&quot;, 3735928559)&#39;
    deadbeef</code></code></pre>

<p>You can also read and execute Perl statements from a file while in the midst of your C program, by placing the filename in <i>argv[1]</i> before calling <i>perl_run</i>.</p>

<h2 id="Calling-a-Perl-subroutine-from-your-C-program">Calling a Perl subroutine from your C program</h2>

<p>To call individual Perl subroutines, you can use any of the <b>call_*</b> functions documented in <a href="../../lib/pods/perlcall.html">perlcall</a>. In this example we&#39;ll use <code><code>call_argv</code></code>.</p>

<p>That&#39;s shown below, in a program I&#39;ll call <i>showtime.c</i>.</p>

<pre><code><code>    <span class="comment">#include &lt;EXTERN.h&gt;</span>
    <span class="comment">#include &lt;perl.h&gt;</span>
    
    <span class="variable">static</span> <span class="variable">PerlInterpreter</span> <span class="variable">*my_perl</span><span class="operator">;</span>
    
    <span class="keyword">int</span> <span class="variable">main</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">char</span> <span class="variable">*args</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">NULL</span> <span class="operator">}</span><span class="operator">;</span>
        <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
        <span class="variable">my_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
        <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
    
        <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">argv</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
        <span class="variable">PL_exit_flags</span> <span class="operator">|=</span> <span class="variable">PERL_EXIT_DESTRUCT_END</span><span class="operator">;</span>
    
        <span class="regex">/*** skipping perl_run() ***/</span>
    
        <span class="variable">call_argv</span><span class="operator">(</span><span class="string">"showtime"</span><span class="operator">,</span> <span class="variable">G_DISCARD</span> <span class="operator">|</span> <span class="variable">G_NOARGS</span><span class="operator">,</span> <span class="variable">args</span><span class="operator">);</span>
    
        <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
        <span class="variable">PERL_SYS_TERM</span><span class="operator">();</span>
    <span class="operator">}</span>
</code></code></pre>

<p>where <i>showtime</i> is a Perl subroutine that takes no arguments (that&#39;s the <i>G_NOARGS</i>) and for which I&#39;ll ignore the return value (that&#39;s the <i>G_DISCARD</i>). Those flags, and others, are discussed in <a href="../../lib/pods/perlcall.html">perlcall</a>.</p>

<p>I&#39;ll define the <i>showtime</i> subroutine in a file called <i>showtime.pl</i>:</p>

<pre><code><code>    <span class="keyword">print</span> <span class="string">"I shan't be printed."</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> showtime </span><span class="operator">{</span>
        <span class="keyword">print</span> <span class="keyword">time</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Simple enough. Now compile and run:</p>

<pre><code><code>    % cc -o showtime showtime.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

    % showtime showtime.pl
    818284590</code></code></pre>

<p>yielding the number of seconds that elapsed between January 1, 1970 (the beginning of the Unix epoch), and the moment I began writing this sentence.</p>

<p>In this particular case we don&#39;t have to call <i>perl_run</i>, as we set the PL_exit_flag PERL_EXIT_DESTRUCT_END which executes END blocks in perl_destruct.</p>

<p>If you want to pass arguments to the Perl subroutine, you can add strings to the <code><code>NULL</code></code>-terminated <code><code>args</code></code> list passed to <i>call_argv</i>. For other data types, or to examine return values, you&#39;ll need to manipulate the Perl stack. That&#39;s demonstrated in <a href="#Fiddling-with-the-Perl-stack-from-your-C-program">&quot;Fiddling with the Perl stack from your C program&quot;</a>.</p>

<h2 id="Evaluating-a-Perl-statement-from-your-C-program">Evaluating a Perl statement from your C program</h2>

<p>Perl provides two API functions to evaluate pieces of Perl code. These are <a href="../../lib/pods/perlapi.html#eval_sv">&quot;eval_sv&quot; in perlapi</a> and <a href="../../lib/pods/perlapi.html#eval_pv">&quot;eval_pv&quot; in perlapi</a>.</p>

<p>Arguably, these are the only routines you&#39;ll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ <a href="../../lib/pods/perlfunc.html#use">&quot;use&quot; in perlfunc</a>, <a href="../../lib/pods/perlfunc.html#require">&quot;require&quot; in perlfunc</a>, and <a href="../../lib/pods/perlfunc.html#do">&quot;do&quot; in perlfunc</a> to include external Perl files.</p>

<p><i>eval_pv</i> lets us evaluate individual Perl strings, and then extract variables for coercion into C types. The following program, <i>string.c</i>, executes three Perl strings, extracting an <code><code>int</code></code> from the first, a <code><code>float</code></code> from the second, and a <code><code>char *</code></code> from the third.</p>

<pre><code><code>   <span class="comment">#include &lt;EXTERN.h&gt;</span>
   <span class="comment">#include &lt;perl.h&gt;</span>
   
   <span class="variable">static</span> <span class="variable">PerlInterpreter</span> <span class="variable">*my_perl</span><span class="operator">;</span>
   
   <span class="variable">main</span> <span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
   <span class="operator">{</span>
       <span class="variable">char</span> <span class="variable">*embedding</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"-e"</span><span class="operator">,</span> <span class="string">"0"</span> <span class="operator">}</span><span class="operator">;</span>
   
       <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
       <span class="variable">my_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
       <span class="variable">perl_construct</span><span class="operator">(</span> <span class="variable">my_perl</span> <span class="operator">);</span>
   
       <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">embedding</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
       <span class="variable">PL_exit_flags</span> <span class="operator">|=</span> <span class="variable">PERL_EXIT_DESTRUCT_END</span><span class="operator">;</span>
       <span class="variable">perl_run</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
   
       <span class="regex">/** Treat </span><span class="variable">$a</span><span class="regex"> as an integer **/</span>
       <span class="variable">eval_pv</span><span class="operator">(</span><span class="string">"</span><span class="variable">$a</span><span class="string"> = 3; </span><span class="variable">$a</span><span class="string"> **= 2"</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
       <span class="keyword">printf</span><span class="operator">(</span><span class="string">"a = %d\n"</span><span class="operator">,</span> <span class="variable">SvIV</span><span class="operator">(</span><span class="variable">get_sv</span><span class="operator">(</span><span class="string">"a"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">)));</span>
   
       <span class="regex">/** Treat </span><span class="variable">$a</span><span class="regex"> as a float **/</span>
       <span class="variable">eval_pv</span><span class="operator">(</span><span class="string">"</span><span class="variable">$a</span><span class="string"> = 3.14; </span><span class="variable">$a</span><span class="string"> **= 2"</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
       <span class="keyword">printf</span><span class="operator">(</span><span class="string">"a = %f\n"</span><span class="operator">,</span> <span class="variable">SvNV</span><span class="operator">(</span><span class="variable">get_sv</span><span class="operator">(</span><span class="string">"a"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">)));</span>
   
       <span class="regex">/** Treat </span><span class="variable">$a</span><span class="regex"> as a string **/</span>
       <span class="variable">eval_pv</span><span class="operator">(</span><span class="string">"</span><span class="variable">$a</span><span class="string"> = 'rekcaH lreP rehtonA tsuJ'; </span><span class="variable">$a</span><span class="string"> = reverse(</span><span class="variable">$a</span><span class="string">);"</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
       <span class="keyword">printf</span><span class="operator">(</span><span class="string">"a = %s\n"</span><span class="operator">,</span> <span class="variable">SvPV_nolen</span><span class="operator">(</span><span class="variable">get_sv</span><span class="operator">(</span><span class="string">"a"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">)));</span>
   
       <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
       <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
       <span class="variable">PERL_SYS_TERM</span><span class="operator">();</span>
   <span class="operator">}</span>
</code></code></pre>

<p>All of those strange functions with <i>sv</i> in their names help convert Perl scalars to C types. They&#39;re described in <a href="../../lib/pods/perlguts.html">perlguts</a> and <a href="../../lib/pods/perlapi.html">perlapi</a>.</p>

<p>If you compile and run <i>string.c</i>, you&#39;ll see the results of using <i>SvIV()</i> to create an <code><code>int</code></code>, <i>SvNV()</i> to create a <code><code>float</code></code>, and <i>SvPV()</i> to create a string:</p>

<pre><code><code>   a = 9
   a = 9.859600
   a = Just Another Perl Hacker</code></code></pre>

<p>In the example above, we&#39;ve created a global variable to temporarily store the computed value of our eval&#39;ed expression. It is also possible and in most cases a better strategy to fetch the return value from <i>eval_pv()</i> instead. Example:</p>

<pre><code><code>   <span class="operator">...</span>
   <span class="variable">SV</span> <span class="variable">*val</span> <span class="operator">=</span> <span class="variable">eval_pv</span><span class="operator">(</span><span class="string">"reverse 'rekcaH lreP rehtonA tsuJ'"</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
   <span class="keyword">printf</span><span class="operator">(</span><span class="string">"%s\n"</span><span class="operator">,</span> <span class="variable">SvPV_nolen</span><span class="operator">(</span><span class="variable">val</span><span class="operator">));</span>
   <span class="operator">...</span>
</code></code></pre>

<p>This way, we avoid namespace pollution by not creating global variables and we&#39;ve simplified our code as well.</p>

<h2 id="Performing-Perl-pattern-matches-and-substitutions-from-your-C-program">Performing Perl pattern matches and substitutions from your C program</h2>

<p>The <i>eval_sv()</i> function lets us evaluate strings of Perl code, so we can define some functions that use it to &quot;specialize&quot; in matches and substitutions: <i>match()</i>, <i>substitute()</i>, and <i>matches()</i>.</p>

<pre><code><code>   <span class="variable">I32</span> <span class="variable">match</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*string</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*pattern</span><span class="operator">);</span>
</code></code></pre>

<p>Given a string and a pattern (e.g., <code><code>m/clasp/</code></code> or <code><code>/\b\w*\b/</code></code>, which in your C program might appear as &quot;/\\b\\w*\\b/&quot;), match() returns 1 if the string matches the pattern and 0 otherwise.</p>

<pre><code><code>   <span class="keyword">int</span> <span class="variable">substitute</span><span class="operator">(</span><span class="variable">SV</span> <span class="operator">**</span><span class="variable">string</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*pattern</span><span class="operator">);</span>
</code></code></pre>

<p>Given a pointer to an <code><code>SV</code></code> and an <code><code>=~</code></code> operation (e.g., <code><code>s/bob/robert/g</code></code> or <code><code>tr[A-Z][a-z]</code></code>), substitute() modifies the string within the <code><code>SV</code></code> as according to the operation, returning the number of substitutions made.</p>

<pre><code><code>   <span class="keyword">int</span> <span class="variable">matches</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*string</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*pattern</span><span class="operator">,</span> <span class="variable">AV</span> <span class="operator">**</span><span class="variable">matches</span><span class="operator">);</span>
</code></code></pre>

<p>Given an <code><code>SV</code></code>, a pattern, and a pointer to an empty <code><code>AV</code></code>, matches() evaluates <code><code>$string =~ $pattern</code></code> in a list context, and fills in <i>matches</i> with the array elements, returning the number of matches found.</p>

<p>Here&#39;s a sample program, <i>match.c</i>, that uses all three (long lines have been wrapped here):</p>

<pre><code><code> <span class="comment">#include &lt;EXTERN.h&gt;</span>
 <span class="comment">#include &lt;perl.h&gt;</span>
 
 <span class="variable">static</span> <span class="variable">PerlInterpreter</span> <span class="variable">*my_perl</span><span class="operator">;</span>
 
 <span class="regex">/** my_eval_sv(code, error_check)
 ** kinda like eval_sv(), 
 ** but we pop the return value off the stack 
 **/</span>
 <span class="variable">SV</span><span class="operator">*</span> <span class="variable">my_eval_sv</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*sv</span><span class="operator">,</span> <span class="variable">I32</span> <span class="variable">croak_on_error</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">dSP</span><span class="operator">;</span>
     <span class="variable">SV</span><span class="operator">*</span> <span class="variable">retval</span><span class="operator">;</span>
 
 
     <span class="variable">PUSHMARK</span><span class="operator">(</span><span class="variable">SP</span><span class="operator">);</span>
     <span class="variable">eval_sv</span><span class="operator">(</span><span class="variable">sv</span><span class="operator">,</span> <span class="variable">G_SCALAR</span><span class="operator">);</span>
 
     <span class="variable">SPAGAIN</span><span class="operator">;</span>
     <span class="variable">retval</span> <span class="operator">=</span> <span class="variable">POPs</span><span class="operator">;</span>
     <span class="variable">PUTBACK</span><span class="operator">;</span>
 
     <span class="keyword">if</span> <span class="operator">(</span><span class="variable">croak_on_error</span> <span class="operator">&amp;&amp;</span> <span class="variable">SvTRUE</span><span class="operator">(</span><span class="variable">ERRSV</span><span class="operator">))</span>
        <span class="variable">croak</span><span class="operator">(</span><span class="variable">SvPVx_nolen</span><span class="operator">(</span><span class="variable">ERRSV</span><span class="operator">));</span>
 
     <span class="keyword">return</span> <span class="variable">retval</span><span class="operator">;</span>
 <span class="operator">}</span>
 
 <span class="regex">/** match(string, pattern)
 **
 ** Used for matches in a scalar context.
 **
 ** Returns 1 if the match was successful; 0 otherwise.
 **/</span>
 
 <span class="variable">I32</span> <span class="variable">match</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*string</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*pattern</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">SV</span> <span class="variable">*command</span> <span class="operator">=</span> <span class="variable">newSV</span><span class="operator">(</span><span class="number">0</span><span class="operator">),</span> <span class="variable">*retval</span><span class="operator">;</span>
 
     <span class="variable">sv_setpvf</span><span class="operator">(</span><span class="variable">command</span><span class="operator">,</span> <span class="string">"my </span><span class="variable">$string</span><span class="string"> = '%s'; </span><span class="variable">$string</span><span class="string"> =~ %s"</span><span class="operator">,</span>
              <span class="variable">SvPV_nolen</span><span class="operator">(</span><span class="variable">string</span><span class="operator">),</span> <span class="variable">pattern</span><span class="operator">);</span>
 
     <span class="variable">retval</span> <span class="operator">=</span> <span class="variable">my_eval_sv</span><span class="operator">(</span><span class="variable">command</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
     <span class="variable">SvREFCNT_dec</span><span class="operator">(</span><span class="variable">command</span><span class="operator">);</span>
 
     <span class="keyword">return</span> <span class="variable">SvIV</span><span class="operator">(</span><span class="variable">retval</span><span class="operator">);</span>
 <span class="operator">}</span>
 
 <span class="regex">/** substitute(string, pattern)
 **
 ** Used for =~ operations that modify their left-hand side (s/</span><span class="operator">//</span> <span class="keyword">and</span> <span class="regex">tr///</span><span class="operator">)</span>
 <span class="operator">**</span>
 <span class="operator">**</span> <span class="variable">Returns</span> <span class="variable">the</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">successful</span> <span class="variable">matches</span><span class="operator">,</span> <span class="keyword">and</span>
 <span class="operator">**</span> <span class="variable">modifies</span> <span class="variable">the</span> <span class="variable">input</span> <span class="variable">string</span> <span class="keyword">if</span> <span class="variable">there</span> <span class="variable">were</span> <span class="variable">any</span><span class="operator">.</span>
 <span class="operator">**</span><span class="regex">/
 
 I32 substitute(SV **string, char *pattern)
 {
     SV *command = newSV(0), *retval;
 
     sv_setpvf(command, "</span><span class="variable">$string</span><span class="regex"> = '%s'; (</span><span class="variable">$string</span><span class="regex"> =~ %s)",
              SvPV_nolen(*string), pattern);
 
     retval = my_eval_sv(command, TRUE);
     SvREFCNT_dec(command);
 
     *string = get_sv("string", 0);
     return SvIV(retval);
 }
 
 /</span><span class="operator">**</span> <span class="variable">matches</span><span class="operator">(</span><span class="variable">string</span><span class="operator">,</span> <span class="variable">pattern</span><span class="operator">,</span> <span class="variable">matches</span><span class="operator">)</span>
 <span class="operator">**</span>
 <span class="operator">**</span> <span class="variable">Used</span> <span class="keyword">for</span> <span class="variable">matches</span> <span class="variable">in</span> <span class="variable">a</span> <span class="variable">list</span> <span class="variable">context</span><span class="operator">.</span>
 <span class="operator">**</span>
 <span class="operator">**</span> <span class="variable">Returns</span> <span class="variable">the</span> <span class="variable">number</span> <span class="variable">of</span> <span class="variable">matches</span><span class="operator">,</span>
 <span class="operator">**</span> <span class="keyword">and</span> <span class="variable">fills</span> <span class="variable">in</span> <span class="operator">**</span><span class="variable">matches</span> <span class="variable">with</span> <span class="variable">the</span> <span class="variable">matching</span> <span class="variable">substrings</span>
 <span class="operator">**/</span>
 
 <span class="variable">I32</span> <span class="variable">matches</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*string</span><span class="operator">,</span> <span class="variable">char</span> <span class="variable">*pattern</span><span class="operator">,</span> <span class="variable">AV</span> <span class="operator">**</span><span class="variable">match_list</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">SV</span> <span class="variable">*command</span> <span class="operator">=</span> <span class="variable">newSV</span><span class="operator">(</span><span class="number">0</span><span class="operator">);</span>
     <span class="variable">I32</span> <span class="variable">num_matches</span><span class="operator">;</span>
 
     <span class="variable">sv_setpvf</span><span class="operator">(</span><span class="variable">command</span><span class="operator">,</span> <span class="string">"my </span><span class="variable">$string</span><span class="string"> = '%s'; </span><span class="variable">@array</span><span class="string"> = (</span><span class="variable">$string</span><span class="string"> =~ %s)"</span><span class="operator">,</span>
              <span class="variable">SvPV_nolen</span><span class="operator">(</span><span class="variable">string</span><span class="operator">),</span> <span class="variable">pattern</span><span class="operator">);</span>
 
     <span class="variable">my_eval_sv</span><span class="operator">(</span><span class="variable">command</span><span class="operator">,</span> <span class="variable">TRUE</span><span class="operator">);</span>
     <span class="variable">SvREFCNT_dec</span><span class="operator">(</span><span class="variable">command</span><span class="operator">);</span>
 
     <span class="variable">*match_list</span> <span class="operator">=</span> <span class="variable">get_av</span><span class="operator">(</span><span class="string">"array"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
     <span class="variable">num_matches</span> <span class="operator">=</span> <span class="variable">av_len</span><span class="operator">(</span><span class="variable">*match_list</span><span class="operator">)</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
 
     <span class="keyword">return</span> <span class="variable">num_matches</span><span class="operator">;</span>
 <span class="operator">}</span>
 
 <span class="variable">main</span> <span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">char</span> <span class="variable">*embedding</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"-e"</span><span class="operator">,</span> <span class="string">"0"</span> <span class="operator">}</span><span class="operator">;</span>
     <span class="variable">AV</span> <span class="variable">*match_list</span><span class="operator">;</span>
     <span class="variable">I32</span> <span class="variable">num_matches</span><span class="operator">,</span> <span class="variable">i</span><span class="operator">;</span>
     <span class="variable">SV</span> <span class="variable">*text</span><span class="operator">;</span>
 
     <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
     <span class="variable">my_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
     <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
     <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">embedding</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
     <span class="variable">PL_exit_flags</span> <span class="operator">|=</span> <span class="variable">PERL_EXIT_DESTRUCT_END</span><span class="operator">;</span>
 
     <span class="variable">text</span> <span class="operator">=</span> <span class="variable">newSV</span><span class="operator">(</span><span class="number">0</span><span class="operator">);</span>
     <span class="variable">sv_setpv</span><span class="operator">(</span><span class="variable">text</span><span class="operator">,</span> <span class="string">"When he is at a convenience store and the "</span>
        <span class="string">"bill comes to some amount like 76 cents, Maynard is "</span>
        <span class="string">"aware that there is something he *should* do, something "</span>
        <span class="string">"that will enable him to get back a quarter, but he has "</span>
        <span class="string">"no idea *what*.  He fumbles through his red squeezey "</span>
        <span class="string">"changepurse and gives the boy three extra pennies with "</span>
        <span class="string">"his dollar, hoping that he might luck into the correct "</span>
        <span class="string">"amount.  The boy gives him back two of his own pennies "</span>
        <span class="string">"and then the big shiny quarter that is his prize. "</span>
        <span class="string">"-RICHH"</span><span class="operator">);</span>
 
     <span class="keyword">if</span> <span class="operator">(</span><span class="variable">match</span><span class="operator">(</span><span class="variable">text</span><span class="operator">,</span> <span class="string">"m/quarter/"</span><span class="operator">))</span> <span class="operator">/**</span> <span class="variable">Does</span> <span class="variable">text</span> <span class="variable">contain</span> <span class="string">'quarter'</span><span class="operator">?</span> <span class="operator">**</span><span class="regex">/
        printf("match: Text contains the word 'quarter'.\n\n");
     else
        printf("match: Text doesn't contain the word 'quarter'.\n\n");
 
     if (match(text, "m/eighth</span><span class="operator">/</span><span class="string">")) /** Does text contain 'eighth'? **/
        printf("</span><span class="variable">match</span><span class="operator">:</span> <span class="variable">Text</span> <span class="variable">contains</span> <span class="variable">the</span> <span class="variable">word</span> <span class="string">'eighth'</span><span class="operator">.\</span><span class="variable">n</span><span class="operator">\</span><span class="variable">n</span><span class="string">");
     else
        printf("</span><span class="variable">match</span><span class="operator">:</span> <span class="variable">Text</span> <span class="variable">doesn't</span> <span class="variable">contain</span> <span class="variable">the</span> <span class="variable">word</span> <span class="string">'eighth'</span><span class="operator">.\</span><span class="variable">n</span><span class="operator">\</span><span class="variable">n</span><span class="string">");
 
     /** Match all occurrences of /wi../ **/
     num_matches = matches(text, "</span><span class="regex">m/(wi..)/g</span><span class="string">", &amp;match_list);
     printf("</span><span class="variable">matches</span><span class="operator">:</span> <span class="regex">m/(wi..)/g</span> <span class="variable">found</span> <span class="variable">%d</span> <span class="variable">matches</span><span class="operator">...\</span><span class="variable">n</span><span class="string">", num_matches);
 
     for (i = 0; i &lt; num_matches; i++)
        printf("</span><span class="variable">match</span><span class="operator">:</span> <span class="variable">%s</span><span class="operator">\</span><span class="variable">n</span><span class="string">", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
     printf("</span><span class="operator">\</span><span class="variable">n</span><span class="string">");
 
     /** Remove all vowels from text **/
     num_matches = substitute(&amp;text, "</span><span class="regex">s/[aeiou]//gi</span><span class="string">");
     if (num_matches) {
        printf("</span><span class="variable">substitute</span><span class="operator">:</span> <span class="regex">s/[aeiou]//gi</span><span class="operator">...</span><span class="variable">%d</span> <span class="variable">substitutions</span> <span class="variable">made</span><span class="operator">.\</span><span class="variable">n</span><span class="string">",
               num_matches);
        printf("</span><span class="variable">Now</span> <span class="variable">text</span> <span class="variable">is</span><span class="operator">:</span> <span class="variable">%s</span><span class="operator">\</span><span class="variable">n</span><span class="operator">\</span><span class="variable">n</span><span class="string">", SvPV_nolen(text));
     }
 
     /** Attempt a substitution **/
     if (!substitute(&amp;text, "</span><span class="regex">s/Perl/C/</span><span class="string">")) {
        printf("</span><span class="variable">substitute</span><span class="operator">:</span> <span class="regex">s/Perl/C...No substitution made.\n\n");
     }
 
     SvREFCNT_dec(text);
     PL_perl_destruct_level = 1;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
 }
 </span>
</code></code></pre>

<p>which produces the output (again, long lines have been wrapped here)</p>

<pre><code><code>   match: Text contains the word &#39;quarter&#39;.

   match: Text doesn&#39;t contain the word &#39;eighth&#39;.

   matches: m/(wi..)/g found 2 matches...
   match: will
   match: with

   substitute: s/[aeiou]//gi...139 substitutions made.
   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. -RCHH

   substitute: s/Perl/C...No substitution made.</code></code></pre>

<h2 id="Fiddling-with-the-Perl-stack-from-your-C-program">Fiddling with the Perl stack from your C program</h2>

<p>When trying to explain stacks, most computer science textbooks mumble something about spring-loaded columns of cafeteria plates: the last thing you pushed on the stack is the first thing you pop off. That&#39;ll do for our purposes: your C program will push some arguments onto &quot;the Perl stack&quot;, shut its eyes while some magic happens, and then pop the results--the return value of your Perl subroutine--off the stack.</p>

<p>First you&#39;ll need to know how to convert between C types and Perl types, with newSViv() and sv_setnv() and newAV() and all their friends. They&#39;re described in <a href="../../lib/pods/perlguts.html">perlguts</a> and <a href="../../lib/pods/perlapi.html">perlapi</a>.</p>

<p>Then you&#39;ll need to know how to manipulate the Perl stack. That&#39;s described in <a href="../../lib/pods/perlcall.html">perlcall</a>.</p>

<p>Once you&#39;ve understood those, embedding Perl in C is easy.</p>

<p>Because C has no builtin function for integer exponentiation, let&#39;s make Perl&#39;s ** operator available to it (this is less useful than it sounds, because Perl implements ** with C&#39;s <i>pow()</i> function). First I&#39;ll create a stub exponentiation function in <i>power.pl</i>:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> expo </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="variable">$a</span> <span class="operator">**</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Now I&#39;ll create a C program, <i>power.c</i>, with a function <i>PerlPower()</i> that contains all the perlguts necessary to push the two arguments into <i>expo()</i> and to pop the return value out. Take a deep breath...</p>

<pre><code><code>    <span class="comment">#include &lt;EXTERN.h&gt;</span>
    <span class="comment">#include &lt;perl.h&gt;</span>
    
    <span class="variable">static</span> <span class="variable">PerlInterpreter</span> <span class="variable">*my_perl</span><span class="operator">;</span>
    
    <span class="variable">static</span> <span class="variable">void</span>
    <span class="variable">PerlPower</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">a</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">b</span><span class="operator">)</span>
    <span class="operator">{</span>
      <span class="variable">dSP</span><span class="operator">;</span>                            <span class="regex">/* initialize stack pointer      */</span>
      <span class="variable">ENTER</span><span class="operator">;</span>                          <span class="regex">/* everything created after here */</span>
      <span class="variable">SAVETMPS</span><span class="operator">;</span>                       <span class="regex">/* ...is a temporary variable.   */</span>
      <span class="variable">PUSHMARK</span><span class="operator">(</span><span class="variable">SP</span><span class="operator">);</span>                   <span class="regex">/* remember the stack pointer    */</span>
      <span class="variable">XPUSHs</span><span class="operator">(</span><span class="variable">sv_2mortal</span><span class="operator">(</span><span class="variable">newSViv</span><span class="operator">(</span><span class="variable">a</span><span class="operator">)));</span> <span class="regex">/* push the base onto the stack  */</span>
      <span class="variable">XPUSHs</span><span class="operator">(</span><span class="variable">sv_2mortal</span><span class="operator">(</span><span class="variable">newSViv</span><span class="operator">(</span><span class="variable">b</span><span class="operator">)));</span> <span class="regex">/* push the exponent onto stack  */</span>
      <span class="variable">PUTBACK</span><span class="operator">;</span>                      <span class="regex">/* make local stack pointer global */</span>
      <span class="variable">call_pv</span><span class="operator">(</span><span class="string">"expo"</span><span class="operator">,</span> <span class="variable">G_SCALAR</span><span class="operator">);</span>      <span class="regex">/* call the function             */</span>
      <span class="variable">SPAGAIN</span><span class="operator">;</span>                        <span class="regex">/* refresh stack pointer         */</span>
                                    <span class="operator">/*</span> <span class="keyword">pop</span> <span class="variable">the</span> <span class="keyword">return</span> <span class="variable">value</span> <span class="variable">from</span> <span class="variable">stack</span> <span class="operator">*/</span>
      <span class="keyword">printf</span> <span class="operator">(</span><span class="string">"%d to the %dth power is %d.\n"</span><span class="operator">,</span> <span class="variable">a</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">POPi</span><span class="operator">);</span>
      <span class="variable">PUTBACK</span><span class="operator">;</span>
      <span class="variable">FREETMPS</span><span class="operator">;</span>                       <span class="regex">/* free that return value        */</span>
      <span class="variable">LEAVE</span><span class="operator">;</span>                       <span class="regex">/* ...and the XPUSHed "mortal" args.*/</span>
    <span class="operator">}</span>
    
    <span class="keyword">int</span> <span class="variable">main</span> <span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
    <span class="operator">{</span>
      <span class="variable">char</span> <span class="variable">*my_argv</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"power.pl"</span> <span class="operator">}</span><span class="operator">;</span>
    
      <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
      <span class="variable">my_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
      <span class="variable">perl_construct</span><span class="operator">(</span> <span class="variable">my_perl</span> <span class="operator">);</span>
    
      <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">my_argv</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">char</span> <span class="operator">**)</span><span class="variable">NULL</span><span class="operator">);</span>
      <span class="variable">PL_exit_flags</span> <span class="operator">|=</span> <span class="variable">PERL_EXIT_DESTRUCT_END</span><span class="operator">;</span>
      <span class="variable">perl_run</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
    
      <span class="variable">PerlPower</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span> <span class="number">4</span><span class="operator">);</span>                      <span class="regex">/*** Compute 3 ** 4 ***/</span>
    
      <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
      <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
      <span class="variable">PERL_SYS_TERM</span><span class="operator">();</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Compile and run:</p>

<pre><code><code>    % cc -o power power.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

    % power
    3 to the 4th power is 81.</code></code></pre>

<h2 id="Maintaining-a-persistent-interpreter">Maintaining a persistent interpreter</h2>

<p>When developing interactive and/or potentially long-running applications, it&#39;s a good idea to maintain a persistent interpreter rather than allocating and constructing a new interpreter multiple times. The major reason is speed: since Perl will only be loaded into memory once.</p>

<p>However, you have to be more cautious with namespace and variable scoping when using a persistent interpreter. In previous examples we&#39;ve been using global variables in the default package <code><code>main</code></code>. We knew exactly what code would be run, and assumed we could avoid variable collisions and outrageous symbol table growth.</p>

<p>Let&#39;s say your application is a server that will occasionally run Perl code from some arbitrary file. Your server has no way of knowing what code it&#39;s going to run. Very dangerous.</p>

<p>If the file is pulled in by <code><code>perl_parse()</code></code>, compiled into a newly constructed interpreter, and subsequently cleaned out with <code><code>perl_destruct()</code></code> afterwards, you&#39;re shielded from most namespace troubles.</p>

<p>One way to avoid namespace collisions in this scenario is to translate the filename into a guaranteed-unique package name, and then compile the code into that package using <a href="../../lib/pods/perlfunc.html#eval">&quot;eval&quot; in perlfunc</a>. In the example below, each file will only be compiled once. Or, the application might choose to clean out the symbol table associated with the file after it&#39;s no longer needed. Using <a href="../../lib/pods/perlapi.html#call_argv">&quot;call_argv&quot; in perlapi</a>, We&#39;ll call the subroutine <code><code>Embed::Persistent::eval_file</code></code> which lives in the file <code><code>persistent.pl</code></code> and pass the filename and boolean cleanup/cache flag as arguments.</p>

<p>Note that the process will continue to grow for each file that it uses. In addition, there might be <code><code>AUTOLOAD</code></code>ed subroutines and other conditions that cause Perl&#39;s symbol table to grow. You might want to add some logic that keeps track of the process size, or restarts itself after a certain number of requests, to ensure that memory consumption is minimized. You&#39;ll also want to scope your variables with <a href="../../lib/pods/perlfunc.html#my">&quot;my&quot; in perlfunc</a> whenever possible.</p>

<pre><code><code> <span class="keyword">package</span> <span class="variable">Embed::Persistent</span><span class="operator">;</span>
 <span class="comment">#persistent.pl</span>
 
 <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
 <span class="keyword">our</span> <span class="variable">%Cache</span><span class="operator">;</span>
 <span class="keyword">use</span> <span class="variable">Symbol</span> <span class="string">qw(delete_package)</span><span class="operator">;</span>
 
 <span class="keyword">sub</span><span class="variable"> valid_package_name </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$string</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">s/([^A-Za-z0-9\/])/sprintf("_%2x",unpack("C",$1))/eg</span><span class="operator">;</span>
     <span class="comment"># second pass only for words starting with a digit</span>
     <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">s|/(\d)|sprintf("/_%2x",unpack("C",$1))|eg</span><span class="operator">;</span>
 
     <span class="comment"># Dress it up as a real package name</span>
     <span class="variable">$string</span> <span class="operator">=~</span> <span class="regex">s|/|::|g</span><span class="operator">;</span>
     <span class="keyword">return</span> <span class="string">"Embed"</span> <span class="operator">.</span> <span class="variable">$string</span><span class="operator">;</span>
 <span class="operator">}</span>
 
 <span class="keyword">sub</span><span class="variable"> eval_file </span><span class="operator">{</span>
     <span class="keyword">my</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">,</span> <span class="variable">$delete</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
     <span class="keyword">my</span> <span class="variable">$package</span> <span class="operator">=</span> <span class="variable">valid_package_name</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span>
     <span class="keyword">my</span> <span class="variable">$mtime</span> <span class="operator">=</span> <span class="keyword">-M</span> <span class="variable">$filename</span><span class="operator">;</span>
     <span class="keyword">if</span><span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$Cache</span><span class="operator">{</span><span class="variable">$package</span><span class="operator">}{</span><span class="string">mtime</span><span class="operator">}</span>
        <span class="operator">&amp;&amp;</span>
        <span class="variable">$Cache</span><span class="operator">{</span><span class="variable">$package</span><span class="operator">}{</span><span class="string">mtime</span><span class="operator">}</span> <span class="operator">&lt;=</span> <span class="variable">$mtime</span><span class="operator">)</span>
     <span class="operator">{</span>
        <span class="comment"># we have compiled this subroutine already,</span>
        <span class="comment"># it has not been updated on disk, nothing left to do</span>
        <span class="keyword">print</span> <span class="variable">STDERR</span> <span class="string">"already compiled </span><span class="variable">$package</span><span class="string">-&gt;handler\n"</span><span class="operator">;</span>
     <span class="operator">}</span>
     <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">*FH</span><span class="operator">;</span>
        <span class="keyword">open</span> <span class="variable">FH</span><span class="operator">,</span> <span class="variable">$filename</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"open '</span><span class="variable">$filename</span><span class="string">' $!"</span><span class="operator">;</span>
        <span class="keyword">local</span><span class="operator">(</span><span class="variable">$/</span><span class="operator">)</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$sub</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">FH</span><span class="operator">&gt;;</span>
        <span class="keyword">close</span> <span class="variable">FH</span><span class="operator">;</span>
 
        <span class="comment">#wrap the code into a subroutine inside our unique package</span>
        <span class="keyword">my</span> <span class="variable">$eval</span> <span class="operator">=</span> <span class="string">qq{package </span><span class="variable">$package</span><span class="string">; sub handler { </span><span class="variable">$sub</span><span class="string">; }}</span><span class="operator">;</span>
        <span class="operator">{</span>
            <span class="comment"># hide our variables within this block</span>
            <span class="keyword">my</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">,</span><span class="variable">$mtime</span><span class="operator">,</span><span class="variable">$package</span><span class="operator">,</span><span class="variable">$sub</span><span class="operator">);</span>
            <span class="keyword">eval</span> <span class="variable">$eval</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">die</span> <span class="variable">$@</span> <span class="keyword">if</span> <span class="variable">$@</span><span class="operator">;</span>
 
        <span class="comment">#cache it unless we're cleaning out each time</span>
        <span class="variable">$Cache</span><span class="operator">{</span><span class="variable">$package</span><span class="operator">}{</span><span class="string">mtime</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$mtime</span> <span class="keyword">unless</span> <span class="variable">$delete</span><span class="operator">;</span>
     <span class="operator">}</span>
 
     <span class="keyword">eval</span> <span class="operator">{</span><span class="variable">$package</span><span class="operator">-&gt;</span><span class="variable">handler</span><span class="operator">;};</span>
     <span class="keyword">die</span> <span class="variable">$@</span> <span class="keyword">if</span> <span class="variable">$@</span><span class="operator">;</span>
 
     <span class="variable">delete_package</span><span class="operator">(</span><span class="variable">$package</span><span class="operator">)</span> <span class="keyword">if</span> <span class="variable">$delete</span><span class="operator">;</span>
 
     <span class="comment">#take a look if you want</span>
     <span class="comment">#print Devel::Symdump-&gt;rnew($package)-&gt;as_string, $/;</span>
 <span class="operator">}</span>
 
 <span class="number">1</span><span class="operator">;</span>
 
 <span class="comment">__END__
 
 /* persistent.c */
 #include &lt;EXTERN.h&gt;
 #include &lt;perl.h&gt;
 
 /* 1 = clean out filename's symbol table after each request, 0 = don't */
 #ifndef DO_CLEAN
 #define DO_CLEAN 0
 #endif
 
 #define BUFFER_SIZE 1024
 
 static PerlInterpreter *my_perl = NULL;
 
 int
 main(int argc, char **argv, char **env)
 {
     char *embedding[] = { "", "persistent.pl" };
     char *args[] = { "", DO_CLEAN, NULL };
     char filename[BUFFER_SIZE];
     int exitstatus = 0;
 
     PERL_SYS_INIT3(&amp;argc,&amp;argv,&amp;env);
     if((my_perl = perl_alloc()) == NULL) {
        fprintf(stderr, "no memory!");
        exit(1);
     }
     perl_construct(my_perl);
 
     PL_origalen = 1; /* don't let $0 assignment update the proctitle or embedding[0] */
     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
     if(!exitstatus) {
        exitstatus = perl_run(my_perl);
 
        while(printf("Enter file name: ") &amp;&amp;
              fgets(filename, BUFFER_SIZE, stdin)) {
 
            filename[strlen(filename)-1] = '\0'; /* strip \n */
            /* call the subroutine, passing it the filename as an argument */
            args[0] = filename;
            call_argv("Embed::Persistent::eval_file",
                           G_DISCARD | G_EVAL, args);
 
            /* check $@ */
            if(SvTRUE(ERRSV))
                fprintf(stderr, "eval error: %s\n", SvPV_nolen(ERRSV));
        }
     }
 
     PL_perl_destruct_level = 0;
     perl_destruct(my_perl);
     perl_free(my_perl);
     PERL_SYS_TERM();
     exit(exitstatus);
 }
 </span>
</code></code></pre>

<p>Now compile:</p>

<pre><code><code> % cc -o persistent persistent.c `perl -MExtUtils::Embed -e ccopts -e ldopts`</code></code></pre>

<p>Here&#39;s an example script file:</p>

<pre><code><code> <span class="comment">#test.pl</span>
 <span class="keyword">my</span> <span class="variable">$string</span> <span class="operator">=</span> <span class="string">"hello"</span><span class="operator">;</span>
 <span class="variable">foo</span><span class="operator">(</span><span class="variable">$string</span><span class="operator">);</span>
 
 <span class="keyword">sub</span><span class="variable"> foo </span><span class="operator">{</span>
     <span class="keyword">print</span> <span class="string">"foo says: </span><span class="variable">@_</span><span class="string">\n"</span><span class="operator">;</span>
 <span class="operator">}</span>
</code></code></pre>

<p>Now run:</p>

<pre><code><code> % persistent
 Enter file name: test.pl
 foo says: hello
 Enter file name: test.pl
 already compiled Embed::test_2epl-&gt;handler
 foo says: hello
 Enter file name: ^C</code></code></pre>

<h2 id="Execution-of-END-blocks">Execution of END blocks</h2>

<p>Traditionally END blocks have been executed at the end of the perl_run. This causes problems for applications that never call perl_run. Since perl 5.7.2 you can specify <code><code>PL_exit_flags |= PERL_EXIT_DESTRUCT_END</code></code> to get the new behaviour. This also enables the running of END blocks if the perl_parse fails and <code><code>perl_destruct</code></code> will return the exit value.</p>

<h2 id="assignments">$0 assignments</h2>

<p>When a perl script assigns a value to $0 then the perl runtime will try to make this value show up as the program name reported by &quot;ps&quot; by updating the memory pointed to by the argv passed to perl_parse() and also calling API functions like setproctitle() where available. This behaviour might not be appropriate when embedding perl and can be disabled by assigning the value <code><code>1</code></code> to the variable <code><code>PL_origalen</code></code> before perl_parse() is called.</p>

<p>The <i>persistent.c</i> example above is for instance likely to segfault when $0 is assigned to if the <code><code><span class="variable">PL_origalen</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</code></code> assignment is removed. This because perl will try to write to the read only memory of the <code><code>embedding[]</code></code> strings.</p>

<h2 id="Maintaining-multiple-interpreter-instances">Maintaining multiple interpreter instances</h2>

<p>Some rare applications will need to create more than one interpreter during a session. Such an application might sporadically decide to release any resources associated with the interpreter.</p>

<p>The program must take care to ensure that this takes place <i>before</i> the next interpreter is constructed. By default, when perl is not built with any special options, the global variable <code><code>PL_perl_destruct_level</code></code> is set to <code><code>0</code></code>, since extra cleaning isn&#39;t usually needed when a program only ever creates a single interpreter in its entire lifetime.</p>

<p>Setting <code><code>PL_perl_destruct_level</code></code> to <code><code>1</code></code> makes everything squeaky clean:</p>

<pre><code><code> <span class="keyword">while</span><span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
     <span class="operator">...</span>
     <span class="regex">/* reset global variables here with PL_perl_destruct_level = 1 */</span>
     <span class="variable">PL_perl_destruct_level</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
     <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
     <span class="operator">...</span>
     <span class="regex">/* clean and reset _everything_ during perl_destruct */</span>
     <span class="variable">PL_perl_destruct_level</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
     <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
     <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">);</span>
     <span class="operator">...</span>
     <span class="regex">/* let's go do it again! */</span>
 <span class="operator">}</span>
</code></code></pre>

<p>When <i>perl_destruct()</i> is called, the interpreter&#39;s syntax parse tree and symbol tables are cleaned up, and global variables are reset. The second assignment to <code><code>PL_perl_destruct_level</code></code> is needed because perl_construct resets it to <code><code>0</code></code>.</p>

<p>Now suppose we have more than one interpreter instance running at the same time. This is feasible, but only if you used the Configure option <code><code>-Dusemultiplicity</code></code> or the options <code><code>-Dusethreads -Duseithreads</code></code> when building perl. By default, enabling one of these Configure options sets the per-interpreter global variable <code><code>PL_perl_destruct_level</code></code> to <code><code>1</code></code>, so that thorough cleaning is automatic and interpreter variables are initialized correctly. Even if you don&#39;t intend to run two or more interpreters at the same time, but to run them sequentially, like in the above example, it is recommended to build perl with the <code><code>-Dusemultiplicity</code></code> option otherwise some interpreter variables may not be initialized correctly between consecutive runs and your application may crash.</p>

<p>See also <a href="../../lib/pods/perlxs.html#Thread-aware-system-interfaces">&quot;Thread-aware system interfaces&quot; in perlxs</a>.</p>

<p>Using <code><code>-Dusethreads -Duseithreads</code></code> rather than <code><code>-Dusemultiplicity</code></code> is more appropriate if you intend to run multiple interpreters concurrently in different threads, because it enables support for linking in the thread libraries of your system with the interpreter.</p>

<p>Let&#39;s give it a try:</p>

<pre><code><code> <span class="comment">#include &lt;EXTERN.h&gt;</span>
 <span class="comment">#include &lt;perl.h&gt;</span>
 
 <span class="regex">/* we're going to embed two interpreters */</span>
 
 <span class="comment">#define SAY_HELLO "-e", "print qq(Hi, I'm $^X\n)"</span>
 
 <span class="keyword">int</span> <span class="variable">main</span><span class="operator">(</span><span class="keyword">int</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">argv</span><span class="operator">,</span> <span class="variable">char</span> <span class="operator">**</span><span class="variable">env</span><span class="operator">)</span>
 <span class="operator">{</span>
     <span class="variable">PerlInterpreter</span> <span class="variable">*one_perl</span><span class="operator">,</span> <span class="variable">*two_perl</span><span class="operator">;</span>
     <span class="variable">char</span> <span class="variable">*one_args</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">"one_perl"</span><span class="operator">,</span> <span class="variable">SAY_HELLO</span> <span class="operator">}</span><span class="operator">;</span>
     <span class="variable">char</span> <span class="variable">*two_args</span><span class="operator">[]</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">"two_perl"</span><span class="operator">,</span> <span class="variable">SAY_HELLO</span> <span class="operator">}</span><span class="operator">;</span>
 
     <span class="variable">PERL_SYS_INIT3</span><span class="operator">(&amp;</span><span class="variable">argc</span><span class="operator">,&amp;</span><span class="variable">argv</span><span class="operator">,&amp;</span><span class="variable">env</span><span class="operator">);</span>
     <span class="variable">one_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
     <span class="variable">two_perl</span> <span class="operator">=</span> <span class="variable">perl_alloc</span><span class="operator">();</span>
 
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">perl_construct</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
 
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">one_args</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">char</span> <span class="operator">**)</span><span class="variable">NULL</span><span class="operator">);</span>
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="number">3</span><span class="operator">,</span> <span class="variable">two_args</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">char</span> <span class="operator">**)</span><span class="variable">NULL</span><span class="operator">);</span>
 
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">perl_run</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">perl_run</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
 
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">perl_destruct</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
 
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">one_perl</span><span class="operator">);</span>
     <span class="variable">PERL_SET_CONTEXT</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">perl_free</span><span class="operator">(</span><span class="variable">two_perl</span><span class="operator">);</span>
     <span class="variable">PERL_SYS_TERM</span><span class="operator">();</span>
 <span class="operator">}</span>
</code></code></pre>

<p>Note the calls to PERL_SET_CONTEXT(). These are necessary to initialize the global state that tracks which interpreter is the &quot;current&quot; one on the particular process or thread that may be running it. It should always be used if you have more than one interpreter and are making perl API calls on both interpreters in an interleaved fashion.</p>

<p>PERL_SET_CONTEXT(interp) should also be called whenever <code><code>interp</code></code> is used by a thread that did not create it (using either perl_alloc(), or the more esoteric perl_clone()).</p>

<p>Compile as usual:</p>

<pre><code><code> % cc -o multiplicity multiplicity.c `perl -MExtUtils::Embed -e ccopts -e ldopts`</code></code></pre>

<p>Run it, Run it:</p>

<pre><code><code> % multiplicity
 Hi, I&#39;m one_perl
 Hi, I&#39;m two_perl</code></code></pre>

<h2 id="Using-Perl-modules-which-themselves-use-C-libraries-from-your-C-program">Using Perl modules, which themselves use C libraries, from your C program</h2>

<p>If you&#39;ve played with the examples above and tried to embed a script that <i>use()</i>s a Perl module (such as <i>Socket</i>) which itself uses a C or C++ library, this probably happened:</p>

<pre><code><code> Can&#39;t load module Socket, dynamic loading not available in this perl.
  (You may need to build a new perl executable which either supports
  dynamic loading or has the Socket module statically linked into it.)</code></code></pre>

<p>What&#39;s wrong?</p>

<p>Your interpreter doesn&#39;t know how to communicate with these extensions on its own. A little glue will help. Up until now you&#39;ve been calling <i>perl_parse()</i>, handing it NULL for the second argument:</p>

<pre><code><code> <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">,</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">my_argv</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
</code></code></pre>

<p>That&#39;s where the glue code can be inserted to create the initial contact between Perl and linked C/C++ routines. Let&#39;s take a look some pieces of <i>perlmain.c</i> to see how Perl does this:</p>

<pre><code><code> <span class="variable">static</span> <span class="variable">void</span> <span class="variable">xs_init</span> <span class="operator">(</span><span class="variable">pTHX</span><span class="operator">);</span>
 
 <span class="variable">EXTERN_C</span> <span class="variable">void</span> <span class="variable">boot_DynaLoader</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">CV</span><span class="operator">*</span> <span class="variable">cv</span><span class="operator">);</span>
 <span class="variable">EXTERN_C</span> <span class="variable">void</span> <span class="variable">boot_Socket</span> <span class="operator">(</span><span class="variable">pTHX_</span> <span class="variable">CV</span><span class="operator">*</span> <span class="variable">cv</span><span class="operator">);</span>
 
 
 <span class="variable">EXTERN_C</span> <span class="variable">void</span>
 <span class="variable">xs_init</span><span class="operator">(</span><span class="variable">pTHX</span><span class="operator">)</span>
 <span class="operator">{</span>
        <span class="variable">char</span> <span class="variable">*file</span> <span class="operator">=</span> <span class="keyword">__FILE__</span><span class="operator">;</span>
        <span class="regex">/* DynaLoader is a special case */</span>
        <span class="variable">newXS</span><span class="operator">(</span><span class="string">"DynaLoader::boot_DynaLoader"</span><span class="operator">,</span> <span class="variable">boot_DynaLoader</span><span class="operator">,</span> <span class="variable">file</span><span class="operator">);</span>
        <span class="variable">newXS</span><span class="operator">(</span><span class="string">"Socket::bootstrap"</span><span class="operator">,</span> <span class="variable">boot_Socket</span><span class="operator">,</span> <span class="variable">file</span><span class="operator">);</span>
 <span class="operator">}</span>
</code></code></pre>

<p>Simply put: for each extension linked with your Perl executable (determined during its initial configuration on your computer or when adding a new extension), a Perl subroutine is created to incorporate the extension&#39;s routines. Normally, that subroutine is named <i>Module::bootstrap()</i> and is invoked when you say <i>use Module</i>. In turn, this hooks into an XSUB, <i>boot_Module</i>, which creates a Perl counterpart for each of the extension&#39;s XSUBs. Don&#39;t worry about this part; leave that to the <i>xsubpp</i> and extension authors. If your extension is dynamically loaded, DynaLoader creates <i>Module::bootstrap()</i> for you on the fly. In fact, if you have a working DynaLoader then there is rarely any need to link in any other extensions statically.</p>

<p>Once you have this code, slap it into the second argument of <i>perl_parse()</i>:</p>

<pre><code><code> <span class="variable">perl_parse</span><span class="operator">(</span><span class="variable">my_perl</span><span class="operator">,</span> <span class="variable">xs_init</span><span class="operator">,</span> <span class="variable">argc</span><span class="operator">,</span> <span class="variable">my_argv</span><span class="operator">,</span> <span class="variable">NULL</span><span class="operator">);</span>
</code></code></pre>

<p>Then compile:</p>

<pre><code><code> % cc -o interp interp.c `perl -MExtUtils::Embed -e ccopts -e ldopts`

 % interp
   use Socket;
   use SomeDynamicallyLoadedModule;

   print &quot;Now I can use extensions!\n&quot;&#39;</code></code></pre>

<p><b>ExtUtils::Embed</b> can also automate writing the <i>xs_init</i> glue code.</p>

<pre><code><code> % perl -MExtUtils::Embed -e xsinit -- -o perlxsi.c
 % cc -c perlxsi.c `perl -MExtUtils::Embed -e ccopts`
 % cc -c interp.c  `perl -MExtUtils::Embed -e ccopts`
 % cc -o interp perlxsi.o interp.o `perl -MExtUtils::Embed -e ldopts`</code></code></pre>

<p>Consult <a href="../../lib/pods/perlxs.html">perlxs</a>, <a href="../../lib/pods/perlguts.html">perlguts</a>, and <a href="../../lib/pods/perlapi.html">perlapi</a> for more details.</p>

<h1 id="Hiding-Perl_">Hiding Perl_</h1>

<p>If you completely hide the short forms of the Perl public API, add -DPERL_NO_SHORT_NAMES to the compilation flags. This means that for example instead of writing</p>

<pre><code><code>    <span class="keyword">warn</span><span class="operator">(</span><span class="string">"%d bottles of beer on the wall"</span><span class="operator">,</span> <span class="variable">bottlecount</span><span class="operator">);</span>
</code></code></pre>

<p>you will have to write the explicit full form</p>

<pre><code><code>    <span class="variable">Perl_warn</span><span class="operator">(</span><span class="variable">aTHX_</span> <span class="string">"%d bottles of beer on the wall"</span><span class="operator">,</span> <span class="variable">bottlecount</span><span class="operator">);</span>
</code></code></pre>

<p>(See <a href="../../lib/pods/perlguts.html#Background-and-PERL_IMPLICIT_CONTEXT">&quot;Background and PERL_IMPLICIT_CONTEXT&quot; in perlguts</a> for the explanation of the <code><code>aTHX_</code></code>. ) Hiding the short forms is very useful for avoiding all sorts of nasty (C preprocessor or otherwise) conflicts with other software packages (Perl defines about 2400 APIs with these short names, take or leave few hundred, so there certainly is room for conflict.)</p>

<h1 id="MORAL">MORAL</h1>

<p>You can sometimes <i>write faster code</i> in C, but you can always <i>write code faster</i> in Perl. Because you can use each from the other, combine them as you wish.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Jon Orwant &lt;<i>orwant@media.mit.edu</i>&gt; and Doug MacEachern &lt;<i>dougm@covalent.net</i>&gt;, with small contributions from Tim Bunce, Tom Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya Zakharevich.</p>

<p>Doug MacEachern has an article on embedding in Volume 1, Issue 4 of The Perl Journal ( http://www.tpj.com/ ). Doug is also the developer of the most widely-used Perl embedding: the mod_perl system (perl.apache.org), which embeds Perl in the Apache web server. Oracle, Binary Evolution, ActiveState, and Ben Sugars&#39;s nsapi_perl have used this model for Oracle, Netscape and Internet Information Server Perl plugins.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant. All Rights Reserved.</p>

<p>This document may be distributed under the same terms as Perl itself.</p>


</body>

</html>


