<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#How-do-I-flush-unbuffer-an-output-filehandle-Why-must-I-do-this-">How do I flush/unbuffer an output filehandle? Why must I do this?    </a></li>
      <li><a href="#How-do-I-change-delete-or-insert-a-line-in-a-file-or-append-to-the-beginning-of-a-file-">How do I change, delete, or insert a line in a file, or append to the beginning of a file? </a></li>
      <li><a href="#How-do-I-count-the-number-of-lines-in-a-file-">How do I count the number of lines in a file?   </a></li>
      <li><a href="#How-do-I-delete-the-last-N-lines-from-a-file-">How do I delete the last N lines from a file?  </a></li>
      <li><a href="#How-can-I-use-Perls-option-from-within-a-program-">How can I use Perl&#39;s  option from within a program?  </a></li>
      <li><a href="#How-can-I-copy-a-file-">How can I copy a file?   </a></li>
      <li><a href="#How-do-I-make-a-temporary-file-name-">How do I make a temporary file name? </a></li>
      <li><a href="#How-can-I-manipulate-fixed-record-length-files-">How can I manipulate fixed-record-length files?  </a></li>
      <li><a href="#How-can-I-make-a-filehandle-local-to-a-subroutine-How-do-I-pass-filehandles-between-subroutines-How-do-I-make-an-array-of-filehandles-">How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?   </a></li>
      <li><a href="#How-can-I-use-a-filehandle-indirectly-">How can I use a filehandle indirectly? </a></li>
      <li><a href="#How-can-I-set-up-a-footer-format-to-be-used-with-write-">How can I set up a footer format to be used with write()? </a></li>
      <li><a href="#How-can-I-write-into-a-string-">How can I write() into a string? </a></li>
      <li><a href="#How-can-I-open-a-filehandle-to-a-string-">How can I open a filehandle to a string?    </a></li>
      <li><a href="#How-can-I-output-my-numbers-with-commas-added-">How can I output my numbers with commas added? </a></li>
      <li><a href="#How-can-I-translate-tildes-in-a-filename-">How can I translate tildes (~) in a filename?  </a></li>
      <li><a href="#How-come-when-I-open-a-file-read-write-it-wipes-it-out-">How come when I open a file read-write it wipes it out?     </a></li>
      <li><a href="#Why-do-I-sometimes-get-an-Argument-list-too-long-when-I-use-">Why do I sometimes get an &quot;Argument list too long&quot; when I use &lt;*&gt;? </a></li>
      <li><a href="#How-can-I-open-a-file-with-a-leading-or-trailing-blanks-">How can I open a file with a leading &quot;&gt;&quot; or trailing blanks? </a></li>
      <li><a href="#How-can-I-reliably-rename-a-file-">How can I reliably rename a file?    </a></li>
      <li><a href="#How-can-I-lock-a-file-">How can I lock a file?   </a></li>
      <li><a href="#Why-cant-I-just-open-FH-file.lock-">Why can&#39;t I just open(FH, &quot;&gt;file.lock&quot;)? </a></li>
      <li><a href="#I-still-dont-get-locking.-I-just-want-to-increment-the-number-in-the-file.-How-can-I-do-this-">I still don&#39;t get locking. I just want to increment the number in the file. How can I do this?  </a></li>
      <li><a href="#All-I-want-to-do-is-append-a-small-amount-of-text-to-the-end-of-a-file.-Do-I-still-have-to-use-locking-">All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?  </a></li>
      <li><a href="#How-do-I-randomly-update-a-binary-file-">How do I randomly update a binary file? </a></li>
      <li><a href="#How-do-I-get-a-files-timestamp-in-perl-">How do I get a file&#39;s timestamp in perl?  </a></li>
      <li><a href="#How-do-I-set-a-files-timestamp-in-perl-">How do I set a file&#39;s timestamp in perl?  </a></li>
      <li><a href="#How-do-I-print-to-more-than-one-file-at-once-">How do I print to more than one file at once? </a></li>
      <li><a href="#How-can-I-read-in-an-entire-file-all-at-once-">How can I read in an entire file all at once?  </a></li>
      <li><a href="#How-can-I-read-in-a-file-by-paragraphs-">How can I read in a file by paragraphs? </a></li>
      <li><a href="#How-can-I-read-a-single-character-from-a-file-From-the-keyboard-">How can I read a single character from a file? From the keyboard?  </a></li>
      <li><a href="#How-can-I-tell-whether-theres-a-character-waiting-on-a-filehandle-">How can I tell whether there&#39;s a character waiting on a filehandle?</a></li>
      <li><a href="#How-do-I-do-a-in-perl-">How do I do a  in perl?    </a></li>
      <li><a href="#How-do-I-dup-a-filehandle-in-Perl-">How do I dup() a filehandle in Perl? </a></li>
      <li><a href="#How-do-I-close-a-file-descriptor-by-number-">How do I close a file descriptor by number?   </a></li>
      <li><a href="#Why-cant-I-use-C:-temp-foo-in-DOS-paths-Why-doesnt-C:-temp-foo.exe-work-">Why can&#39;t I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn&#39;t `C:\temp\foo.exe` work? </a></li>
      <li><a href="#Why-doesnt-glob-.-get-all-the-files-">Why doesn&#39;t glob(&quot;*.*&quot;) get all the files? </a></li>
      <li><a href="#Why-does-Perl-let-me-delete-read-only-files-Why-does-clobber-protected-files-Isnt-this-a-bug-in-Perl-">Why does Perl let me delete read-only files? Why does  clobber protected files? Isn&#39;t this a bug in Perl?</a></li>
      <li><a href="#How-do-I-select-a-random-line-from-a-file-">How do I select a random line from a file? </a></li>
      <li><a href="#Why-do-I-get-weird-spaces-when-I-print-an-array-of-lines-">Why do I get weird spaces when I print an array of lines?</a></li>
      <li><a href="#How-do-I-traverse-a-directory-tree-">How do I traverse a directory tree?</a></li>
      <li><a href="#How-do-I-delete-a-directory-tree-">How do I delete a directory tree?</a></li>
      <li><a href="#How-do-I-copy-an-entire-directory-">How do I copy an entire directory?</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perlfaq5 - Files and Formats</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This section deals with I/O and the &quot;f&quot; issues: filehandles, flushing, formats, and footers.</p>

<h2 id="How-do-I-flush-unbuffer-an-output-filehandle-Why-must-I-do-this-">How do I flush/unbuffer an output filehandle? Why must I do this?    </h2>

<p>(contributed by brian d foy)</p>

<p>You might like to read Mark Jason Dominus&#39;s &quot;Suffering From Buffering&quot; at <a href="http://perl.plover.com/FAQs/Buffering.html">http://perl.plover.com/FAQs/Buffering.html</a> .</p>

<p>Perl normally buffers output so it doesn&#39;t make a system call for every bit of output. By saving up output, it makes fewer expensive system calls. For instance, in this little bit of code, you want to print a dot to the screen for every line you process to watch the progress of your program. Instead of seeing a dot for every line, Perl buffers the output and you have a long wait before you see a row of 50 dots all at once:</p>

<pre><code><code>    <span class="comment"># long wait, then row of dots all at once</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"."</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"\n"</span> <span class="keyword">unless</span> <span class="operator">++</span><span class="variable">$count</span> <span class="operator">% </span><span class="number">50</span><span class="operator">;</span>
    
        <span class="comment">#... expensive line processing operations</span>
    <span class="operator">}</span>
</code></code></pre>

<p>To get around this, you have to unbuffer the output filehandle, in this case, <code><code>STDOUT</code></code>. You can set the special variable <code><code>$|</code></code> to a true value (mnemonic: making your filehandles &quot;piping hot&quot;):</p>

<pre><code><code>    <span class="variable">$|</span><span class="operator">++;</span>
    
    <span class="comment"># dot shown immediately</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"."</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"\n"</span> <span class="keyword">unless</span> <span class="operator">++</span><span class="variable">$count</span> <span class="operator">% </span><span class="number">50</span><span class="operator">;</span>
    
        <span class="comment">#... expensive line processing operations</span>
    <span class="operator">}</span>
</code></code></pre>

<p>The <code><code>$|</code></code> is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$previous_default</span> <span class="operator">=</span> <span class="keyword">select</span><span class="operator">(</span><span class="variable">STDOUT</span><span class="operator">);</span>  <span class="comment"># save previous default</span>
        <span class="variable">$|</span><span class="operator">++;</span>                                   <span class="comment"># autoflush STDOUT</span>
        <span class="keyword">select</span><span class="operator">(</span><span class="variable">STDERR</span><span class="operator">);</span>
        <span class="variable">$|</span><span class="operator">++;</span>                                   <span class="comment"># autoflush STDERR, to be sure</span>
        <span class="keyword">select</span><span class="operator">(</span><span class="variable">$previous_default</span><span class="operator">);</span>              <span class="comment"># restore previous default</span>
    <span class="operator">}</span>
    
    <span class="comment"># now should alternate . and +</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="number">1</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">STDOUT</span> <span class="string">"."</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">STDERR</span> <span class="string">"+"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">STDOUT</span> <span class="string">"\n"</span> <span class="keyword">unless</span> <span class="operator">++</span><span class="variable">$count</span> <span class="operator">% </span><span class="number">25</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Besides the <code><code>$|</code></code> special variable, you can use <code><code>binmode</code></code> to give your filehandle a <code><code>:unix</code></code> layer, which is unbuffered:</p>

<pre><code><code>    <span class="keyword">binmode</span><span class="operator">(</span> <span class="variable">STDOUT</span><span class="operator">,</span> <span class="string">":unix"</span> <span class="operator">);</span>
    
    <span class="keyword">while</span><span class="operator">(</span> <span class="number">1</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"."</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"\n"</span> <span class="keyword">unless</span> <span class="operator">++</span><span class="variable">$count</span> <span class="operator">% </span><span class="number">50</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>For more information on output layers, see the entries for <code><code>binmode</code></code> and <a href="../../lib/open.html">open</a> in <a href="../../lib/pods/perlfunc.html">perlfunc</a>, and the <a href="../../lib/PerlIO.html">PerlIO</a> module documentation.</p>

<p>If you are using <a href="../../lib/IO/Handle.html">IO::Handle</a> or one of its subclasses, you can call the <code><code>autoflush</code></code> method to change the settings of the filehandle:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">IO::Handle</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span><span class="operator">(</span> <span class="variable">$io_fh</span> <span class="operator">),</span> <span class="string">"&gt;"</span><span class="operator">,</span> <span class="string">"output.txt"</span><span class="operator">;</span>
    <span class="variable">$io_fh</span><span class="operator">-&gt;</span><span class="variable">autoflush</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
</code></code></pre>

<p>The <a href="../../lib/IO/Handle.html">IO::Handle</a> objects also have a <code><code>flush</code></code> method. You can flush the buffer any time you want without auto-buffering</p>

<pre><code><code>    <span class="variable">$io_fh</span><span class="operator">-&gt;</span><span class="variable">flush</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-do-I-change-delete-or-insert-a-line-in-a-file-or-append-to-the-beginning-of-a-file-">How do I change, delete, or insert a line in a file, or append to the beginning of a file? </h2>

<p>(contributed by brian d foy)</p>

<p>The basic idea of inserting, changing, or deleting a line from a text file involves reading and printing the file to the point you want to make the change, making the change, then reading and printing the rest of the file. Perl doesn&#39;t provide random access to lines (especially since the record input separator, <code><code>$/</code></code>, is mutable), although modules such as <a href="../../lib/Tie/File.html">Tie::File</a> can fake it.</p>

<p>A Perl program to do these tasks takes the basic form of opening a file, printing its lines, then closing the file:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$in</span><span class="operator">,</span>  <span class="string">'&lt;'</span><span class="operator">,</span>  <span class="variable">$file</span>      <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't read old file: $!"</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$out</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="string">"</span><span class="variable">$file</span><span class="string">.new"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't write new file: $!"</span><span class="operator">;</span>
    
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">close</span> <span class="variable">$out</span><span class="operator">;</span>
</code></code></pre>

<p>Within that basic form, add the parts that you need to insert, change, or delete lines.</p>

<p>To prepend lines to the beginning, print those lines before you enter the loop that prints the existing lines.</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$in</span><span class="operator">,</span>  <span class="string">'&lt;'</span><span class="operator">,</span>  <span class="variable">$file</span>      <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't read old file: $!"</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$out</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="string">"</span><span class="variable">$file</span><span class="string">.new"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't write new file: $!"</span><span class="operator">;</span>
    
    <span class="keyword">print</span> <span class="variable">$out</span> <span class="string">"# Add this line to the top\n"</span><span class="operator">;</span> <span class="comment"># &lt;--- HERE'S THE MAGIC</span>
    
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">close</span> <span class="variable">$out</span><span class="operator">;</span>
</code></code></pre>

<p>To change existing lines, insert the code to modify the lines inside the <code><code>while</code></code> loop. In this case, the code finds all lowercased versions of &quot;perl&quot; and uppercases them. The happens for every line, so be sure that you&#39;re supposed to do that on every line!</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$in</span><span class="operator">,</span>  <span class="string">'&lt;'</span><span class="operator">,</span>  <span class="variable">$file</span>      <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't read old file: $!"</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$out</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="string">"</span><span class="variable">$file</span><span class="string">.new"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't write new file: $!"</span><span class="operator">;</span>
    
    <span class="keyword">print</span> <span class="variable">$out</span> <span class="string">"# Add this line to the top\n"</span><span class="operator">;</span>
    
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="regex">s/\b(perl)\b/Perl/g</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">close</span> <span class="variable">$out</span><span class="operator">;</span>
</code></code></pre>

<p>To change only a particular line, the input line number, <code><code>$.</code></code>, is useful. First read and print the lines up to the one you want to change. Next, read the single line you want to change, change it, and print it. After that, read the rest of the lines and print those:</p>

<pre><code><code>    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span> <span class="comment"># print the lines before the change</span>
        <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
        <span class="keyword">last</span> <span class="keyword">if</span> <span class="variable">$.</span> <span class="operator">==</span> <span class="number">4</span><span class="operator">;</span> <span class="comment"># line number before change</span>
    <span class="operator">}</span>
    
    <span class="keyword">my</span> <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;;</span>
    <span class="variable">$line</span> <span class="operator">=~</span> <span class="regex">s/\b(perl)\b/Perl/g</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$line</span><span class="operator">;</span>
    
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span> <span class="comment"># print the rest of the lines</span>
        <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>To skip lines, use the looping controls. The <code><code>next</code></code> in this example skips comment lines, and the <code><code>last</code></code> stops all processing once it encounters either <code><code>__END__</code></code> or <code><code>__DATA__</code></code>.</p>

<pre><code><code>    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">next</span> <span class="keyword">if</span> <span class="regex">/^\s+#/</span><span class="operator">;</span>             <span class="comment"># skip comment lines</span>
        <span class="keyword">last</span> <span class="keyword">if</span> <span class="regex">/^__(END|DATA)__$/</span><span class="operator">;</span>  <span class="comment"># stop at end of code marker</span>
        <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Do the same sort of thing to delete a particular line by using <code><code>next</code></code> to skip the lines you don&#39;t want to show up in the output. This example skips every fifth line:</p>

<pre><code><code>    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">next</span> <span class="keyword">unless</span> <span class="variable">$.</span> <span class="operator">% </span><span class="number">5</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>If, for some odd reason, you really want to see the whole file at once rather than processing line-by-line, you can slurp it in (as long as you can fit the whole thing in memory!):</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$in</span><span class="operator">,</span>  <span class="string">'&lt;'</span><span class="operator">,</span>  <span class="variable">$file</span>      <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't read old file: $!"</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$out</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="string">"</span><span class="variable">$file</span><span class="string">.new"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't write new file: $!"</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">@lines</span> <span class="operator">=</span> <span class="keyword">do</span> <span class="operator">{</span> <span class="keyword">local</span> <span class="variable">$/</span><span class="operator">;</span> <span class="operator">&lt;</span><span class="variable">$in</span><span class="operator">&gt;</span> <span class="operator">};</span> <span class="comment"># slurp!</span>
    
        <span class="comment"># do your magic here</span>
    
    <span class="keyword">print</span> <span class="variable">$out</span> <span class="variable">@lines</span><span class="operator">;</span>
</code></code></pre>

<p>Modules such as <a>File::Slurp</a> and <a href="../../lib/Tie/File.html">Tie::File</a> can help with that too. If you can, however, avoid reading the entire file at once. Perl won&#39;t give that memory back to the operating system until the process finishes.</p>

<p>You can also use Perl one-liners to modify a file in-place. The following changes all &#39;Fred&#39; to &#39;Barney&#39; in <i>inFile.txt</i>, overwriting the file with the new contents. With the <code><code>-p</code></code> switch, Perl wraps a <code><code>while</code></code> loop around the code you specify with <code><code>-e</code></code>, and <code><code>-i</code></code> turns on in-place editing. The current line is in <code><code>$_</code></code>. With <code><code>-p</code></code>, Perl automatically prints the value of <code><code>$_</code></code> at the end of the loop. See <a href="../../lib/pods/perlrun.html">perlrun</a> for more details.</p>

<pre><code><code>    perl -pi -e &#39;s/Fred/Barney/&#39; inFile.txt</code></code></pre>

<p>To make a backup of <code><code>inFile.txt</code></code>, give <code><code>-i</code></code> a file extension to add:</p>

<pre><code><code>    perl -pi.bak -e &#39;s/Fred/Barney/&#39; inFile.txt</code></code></pre>

<p>To change only the fifth line, you can add a test checking <code><code>$.</code></code>, the input line number, then only perform the operation when the test passes:</p>

<pre><code><code>    perl -pi -e &#39;s/Fred/Barney/ if $. == 5&#39; inFile.txt</code></code></pre>

<p>To add lines before a certain line, you can add a line (or lines!) before Perl prints <code><code>$_</code></code>:</p>

<pre><code><code>    perl -pi -e &#39;print &quot;Put before third line\n&quot; if $. == 3&#39; inFile.txt</code></code></pre>

<p>You can even add a line to the beginning of a file, since the current line prints at the end of the loop:</p>

<pre><code><code>    perl -pi -e &#39;print &quot;Put before first line\n&quot; if $. == 1&#39; inFile.txt</code></code></pre>

<p>To insert a line after one already in the file, use the <code><code>-n</code></code> switch. It&#39;s just like <code><code>-p</code></code> except that it doesn&#39;t print <code><code>$_</code></code> at the end of the loop, so you have to do that yourself. In this case, print <code><code>$_</code></code> first, then print the line that you want to add.</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">ni</span> <span class="keyword">-e</span> <span class="string">'print; print "Put after fifth line\n" if $. == 5'</span> <span class="variable">inFile</span><span class="operator">.</span><span class="variable">txt</span>
</code></code></pre>

<p>To delete lines, only print the ones that you want.</p>

<pre><code><code>    perl -ni -e &#39;print if /d/&#39; inFile.txt</code></code></pre>

<h2 id="How-do-I-count-the-number-of-lines-in-a-file-">How do I count the number of lines in a file?   </h2>

<p>(contributed by brian d foy)</p>

<p>Conceptually, the easiest way to count the lines in a file is to simply read them and count them:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;</span> <span class="operator">)</span> <span class="operator">{</span> <span class="variable">$count</span><span class="operator">++;</span> <span class="operator">}</span>
</code></code></pre>

<p>You don&#39;t really have to count them yourself, though, since Perl already does that with the <code><code>$.</code></code> variable, which is the current line number from the last filehandle read:</p>

<pre><code><code>    <span class="number">1</span> <span class="keyword">while</span><span class="operator">(</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$.</span><span class="operator">;</span>
</code></code></pre>

<p>If you want to use <code><code>$.</code></code>, you can reduce it to a simple one-liner, like one of these:</p>

<pre><code><code>    <span class="operator">% </span><span class="variable">perl</span> <span class="operator">-</span><span class="variable">lne</span> <span class="string">'} print $.; {'</span>    <span class="variable">file</span>
    
    <span class="operator">% </span><span class="variable">perl</span> <span class="operator">-</span><span class="variable">lne</span> <span class="string">'END { print $. }'</span> <span class="variable">file</span>
</code></code></pre>

<p>Those can be rather inefficient though. If they aren&#39;t fast enough for you, you might just read chunks of data and count the number of newlines:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$lines</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">),</span> <span class="string">'&lt;:raw'</span><span class="operator">,</span> <span class="variable">$filename</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't open </span><span class="variable">$filename</span><span class="string">: $!"</span><span class="operator">;</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="keyword">sysread</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="number">4096</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$lines</span> <span class="operator">+=</span> <span class="operator">(</span> <span class="variable">$buffer</span> <span class="operator">=~</span> <span class="regex">tr/\n//</span> <span class="operator">);</span>
    <span class="operator">}</span>
    <span class="keyword">close</span> <span class="variable">FILE</span><span class="operator">;</span>
</code></code></pre>

<p>However, that doesn&#39;t work if the line ending isn&#39;t a newline. You might change that <code><code>tr///</code></code> to a <code><code>s///</code></code> so you can count the number of times the input record separator, <code><code>$/</code></code>, shows up:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$lines</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">),</span> <span class="string">'&lt;:raw'</span><span class="operator">,</span> <span class="variable">$filename</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Can't open </span><span class="variable">$filename</span><span class="string">: $!"</span><span class="operator">;</span>
    <span class="keyword">while</span><span class="operator">(</span> <span class="keyword">sysread</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="number">4096</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$lines</span> <span class="operator">+=</span> <span class="operator">(</span> <span class="variable">$buffer</span> <span class="operator">=~</span> <span class="regex">s|$/||g</span><span class="operator">;</span> <span class="operator">);</span>
    <span class="operator">}</span>
    <span class="keyword">close</span> <span class="variable">FILE</span><span class="operator">;</span>
</code></code></pre>

<p>If you don&#39;t mind shelling out, the <code><code>wc</code></code> command is usually the fastest, even with the extra interprocess overhead. Ensure that you have an untainted filename though:</p>

<pre><code><code>    <span class="comment">#!perl -T</span>
    
    <span class="variable">$ENV</span><span class="operator">{</span><span class="string">PATH</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$lines</span><span class="operator">;</span>
    <span class="keyword">if</span><span class="operator">(</span> <span class="variable">$filename</span> <span class="operator">=~</span> <span class="regex">/^([0-9a-z_.]+)\z/</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$lines</span> <span class="operator">=</span> <span class="string">`/usr/bin/wc -l </span><span class="variable">$1</span><span class="string">`</span>
        <span class="keyword">chomp</span> <span class="variable">$lines</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="How-do-I-delete-the-last-N-lines-from-a-file-">How do I delete the last N lines from a file?  </h2>

<p>(contributed by brian d foy)</p>

<p>The easiest conceptual solution is to count the lines in the file then start at the beginning and print the number of lines (minus the last N) to a new file.</p>

<p>Most often, the real question is how you can delete the last N lines without making more than one pass over the file, or how to do it without a lot of copying. The easy concept is the hard reality when you might have millions of lines in your file.</p>

<p>One trick is to use <a>File::ReadBackwards</a>, which starts at the end of the file. That module provides an object that wraps the real filehandle to make it easy for you to move around the file. Once you get to the spot you need, you can get the actual filehandle and work with it as normal. In this case, you get the file position at the end of the last line you want to keep and truncate the file to that point:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::ReadBackwards</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$filename</span> <span class="operator">=</span> <span class="string">'test.txt'</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$Lines_to_truncate</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$bw</span> <span class="operator">=</span> <span class="variable">File::ReadBackwards</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="variable">$filename</span> <span class="operator">)</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Could not read backwards in [</span><span class="variable">$filename</span><span class="string">]: $!"</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$lines_from_end</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">until</span><span class="operator">(</span> <span class="variable">$bw</span><span class="operator">-&gt;</span><span class="variable">eof</span> <span class="keyword">or</span> <span class="variable">$lines_from_end</span> <span class="operator">==</span> <span class="variable">$Lines_to_truncate</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"Got: "</span><span class="operator">,</span> <span class="variable">$bw</span><span class="operator">-&gt;</span><span class="variable">readline</span><span class="operator">;</span>
        <span class="variable">$lines_from_end</span><span class="operator">++;</span>
    <span class="operator">}</span>
    
    <span class="keyword">truncate</span><span class="operator">(</span> <span class="variable">$filename</span><span class="operator">,</span> <span class="variable">$bw</span><span class="operator">-&gt;</span><span class="variable">tell</span> <span class="operator">);</span>
</code></code></pre>

<p>The <a>File::ReadBackwards</a> module also has the advantage of setting the input record separator to a regular expression.</p>

<p>You can also use the <a href="../../lib/Tie/File.html">Tie::File</a> module which lets you access the lines through a tied array. You can use normal array operations to modify your file, including setting the last index and using <code><code>splice</code></code>.</p>

<h2 id="How-can-I-use-Perls-option-from-within-a-program-">How can I use Perl&#39;s <code><code>-i</code></code> option from within a program?  </h2>

<p><code><code>-i</code></code> sets the value of Perl&#39;s <code><code>$^I</code></code> variable, which in turn affects the behavior of <code><code>&lt;&gt;</code></code>; see <a href="../../lib/pods/perlrun.html">perlrun</a> for more details. By modifying the appropriate variables directly, you can get the same behavior within a larger program. For example:</p>

<pre><code><code>    <span class="comment"># ...</span>
    <span class="operator">{</span>
        <span class="keyword">local</span><span class="operator">(</span><span class="variable">$^I</span><span class="operator">,</span> <span class="variable">@ARGV</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">'.orig'</span><span class="operator">,</span> <span class="keyword">glob</span><span class="operator">(</span><span class="string">"*.c"</span><span class="operator">));</span>
        <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span> <span class="operator">{</span>
            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$.</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
                <span class="keyword">print</span> <span class="string">"This line should appear at the top of each file\n"</span><span class="operator">;</span>
            <span class="operator">}</span>
            <span class="regex">s/\b(p)earl\b/${1}erl/i</span><span class="operator">;</span>        <span class="comment"># Correct typos, preserving case</span>
            <span class="keyword">print</span><span class="operator">;</span>
            <span class="keyword">close</span> <span class="variable">ARGV</span> <span class="keyword">if</span> <span class="keyword">eof</span><span class="operator">;</span>              <span class="comment"># Reset $.</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="comment"># $^I and @ARGV return to their old values here</span>
</code></code></pre>

<p>This block modifies all the <code><code>.c</code></code> files in the current directory, leaving a backup of the original data from each file in a new <code><code>.c.orig</code></code> file.</p>

<h2 id="How-can-I-copy-a-file-">How can I copy a file?   </h2>

<p>(contributed by brian d foy)</p>

<p>Use the <a href="../../lib/File/Copy.html">File::Copy</a> module. It comes with Perl and can do a true copy across file systems, and it does its magic in a portable fashion.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Copy</span><span class="operator">;</span>
    
    <span class="variable">copy</span><span class="operator">(</span> <span class="variable">$original</span><span class="operator">,</span> <span class="variable">$new_copy</span> <span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Copy failed: $!"</span><span class="operator">;</span>
</code></code></pre>

<p>If you can&#39;t use <a href="../../lib/File/Copy.html">File::Copy</a>, you&#39;ll have to do the work yourself: open the original file, open the destination file, then print to the destination file as you read the original. You also have to remember to copy the permissions, owner, and group to the new file.</p>

<h2 id="How-do-I-make-a-temporary-file-name-">How do I make a temporary file name? </h2>

<p>If you don&#39;t need to know the name of the file, you can use <code><code>open()</code></code> with <code><code>undef</code></code> in place of the file name. In Perl 5.8 or later, the <code><code>open()</code></code> function creates an anonymous temporary file:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$tmp</span><span class="operator">,</span> <span class="string">'+&gt;'</span><span class="operator">,</span> <span class="keyword">undef</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>Otherwise, you can use the File::Temp module.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Temp</span> <span class="string">qw/ tempfile tempdir /</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$dir</span> <span class="operator">=</span> <span class="variable">tempdir</span><span class="operator">(</span> <span class="string">CLEANUP</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">);</span>
    <span class="operator">(</span><span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$filename</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">tempfile</span><span class="operator">(</span> <span class="string">DIR</span> <span class="operator">=&gt;</span> <span class="variable">$dir</span> <span class="operator">);</span>
    
    <span class="comment"># or if you don't need to know the filename</span>
    
    <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="variable">tempfile</span><span class="operator">(</span> <span class="string">DIR</span> <span class="operator">=&gt;</span> <span class="variable">$dir</span> <span class="operator">);</span>
</code></code></pre>

<p>The File::Temp has been a standard module since Perl 5.6.1. If you don&#39;t have a modern enough Perl installed, use the <code><code>new_tmpfile</code></code> class method from the IO::File module to get a filehandle opened for reading and writing. Use it if you don&#39;t need to know the file&#39;s name:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">IO::File</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="variable">IO::File</span><span class="operator">-&gt;</span><span class="variable">new_tmpfile</span><span class="operator">()</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Unable to make new temporary file: $!"</span><span class="operator">;</span>
</code></code></pre>

<p>If you&#39;re committed to creating a temporary file by hand, use the process ID and/or the current time-value. If you need to have many temporary files in one process, use a counter:</p>

<pre><code><code>    <span class="keyword">BEGIN</span> <span class="operator">{</span>
        <span class="keyword">use</span> <span class="variable">Fcntl</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$temp_dir</span> <span class="operator">=</span> <span class="keyword">-d</span> <span class="string">'/tmp'</span> <span class="operator">?</span> <span class="string">'/tmp'</span> <span class="operator">:</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TMPDIR</span><span class="operator">}</span> <span class="operator">||</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TEMP</span><span class="operator">}</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$base_name</span> <span class="operator">=</span> <span class="keyword">sprintf</span> <span class="string">"%s/%d-%d-0000"</span><span class="operator">,</span> <span class="variable">$temp_dir</span><span class="operator">,</span> <span class="variable">$$</span><span class="operator">,</span> <span class="keyword">time</span><span class="operator">;</span>
    
        <span class="keyword">sub</span><span class="variable"> temp_file </span><span class="operator">{</span>
            <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">;</span>
            <span class="keyword">my</span> <span class="variable">$count</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
            <span class="keyword">until</span><span class="operator">(</span> <span class="keyword">defined</span><span class="operator">(</span><span class="keyword">fileno</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">))</span> <span class="operator">||</span> <span class="variable">$count</span><span class="operator">++</span> <span class="operator">&gt;</span> <span class="number">100</span> <span class="operator">)</span> <span class="operator">{</span>
                <span class="variable">$base_name</span> <span class="operator">=~</span> <span class="regex">s/-(\d+)$/"-" . (1 + $1)/e</span><span class="operator">;</span>
                <span class="comment"># O_EXCL is required for security reasons.</span>
                <span class="keyword">sysopen</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$base_name</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">;</span>
            <span class="operator">}</span>
    
            <span class="keyword">if</span><span class="operator">(</span> <span class="keyword">defined</span> <span class="keyword">fileno</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
                <span class="keyword">return</span> <span class="operator">(</span><span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$base_name</span><span class="operator">);</span>
            <span class="operator">}</span>
            <span class="keyword">else</span> <span class="operator">{</span>
                <span class="keyword">return</span> <span class="operator">();</span>
            <span class="operator">}</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="How-can-I-manipulate-fixed-record-length-files-">How can I manipulate fixed-record-length files?  </h2>

<p>The most efficient way is using <a href="../../lib/pods/perlfunc.html#pack">pack()</a> and <a href="../../lib/pods/perlfunc.html#unpack">unpack()</a>. This is faster than using <a href="../../lib/pods/perlfunc.html#substr">substr()</a> when taking many, many strings. It is slower for just a few.</p>

<p>Here is a sample chunk of code to break up and put back together again some fixed-format input lines, in this case from the output of a normal, Berkeley-style ps:</p>

<pre><code><code>    <span class="comment"># sample input line:</span>
    <span class="comment">#   15158 p5  T      0:00 perl /home/tchrist/scripts/now-what</span>
    <span class="keyword">my</span> <span class="variable">$PS_T</span> <span class="operator">=</span> <span class="string">'A6 A4 A7 A5 A*'</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$ps</span><span class="operator">,</span> <span class="string">'-|'</span><span class="operator">,</span> <span class="string">'ps'</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="keyword">scalar</span> <span class="operator">&lt;</span><span class="variable">$ps</span><span class="operator">&gt;;</span>
    <span class="keyword">my</span> <span class="variable">@fields</span> <span class="operator">=</span> <span class="string">qw( pid tt stat time command )</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(&lt;</span><span class="variable">$ps</span><span class="operator">&gt;)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">%process</span><span class="operator">;</span>
        <span class="variable">@process</span><span class="operator">{</span><span class="variable">@fields</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">unpack</span><span class="operator">(</span><span class="variable">$PS_T</span><span class="operator">,</span> <span class="variable">$_</span><span class="operator">);</span>
        <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$field</span> <span class="operator">(</span> <span class="variable">@fields</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="string">"</span><span class="variable">$field</span><span class="string">: &lt;</span><span class="variable">$process</span><span class="string">{</span><span class="variable">$field</span><span class="string">}&gt;\n"</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">print</span> <span class="string">'line='</span><span class="operator">,</span> <span class="keyword">pack</span><span class="operator">(</span><span class="variable">$PS_T</span><span class="operator">,</span> <span class="variable">@process</span><span class="operator">{</span><span class="variable">@fields</span><span class="operator">}</span> <span class="operator">),</span> <span class="string">"\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>We&#39;ve used a hash slice in order to easily handle the fields of each row. Storing the keys in an array makes it easy to operate on them as a group or loop over them with <code><code>for</code></code>. It also avoids polluting the program with global variables and using symbolic references.</p>

<h2 id="How-can-I-make-a-filehandle-local-to-a-subroutine-How-do-I-pass-filehandles-between-subroutines-How-do-I-make-an-array-of-filehandles-">How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?   </h2>

<p>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span>    <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$file_name</span><span class="operator">;</span>
    
    <span class="keyword">open</span> <span class="keyword">local</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$file_name</span><span class="operator">;</span>
    
    <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"Hello World!\n"</span><span class="operator">;</span>
    
    <span class="variable">process_file</span><span class="operator">(</span> <span class="variable">$fh</span> <span class="operator">);</span>
</code></code></pre>

<p>If you like, you can store these filehandles in an array or a hash. If you access them directly, they aren&#39;t simple scalars and you need to give <code><code>print</code></code> a little help by placing the filehandle reference in braces. Perl can only figure it out on its own when the filehandle reference is a simple scalar.</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@fhs</span> <span class="operator">=</span> <span class="operator">(</span> <span class="variable">$fh1</span><span class="operator">,</span> <span class="variable">$fh2</span><span class="operator">,</span> <span class="variable">$fh3</span> <span class="operator">);</span>
    
    <span class="keyword">for</span><span class="operator">(</span> <span class="variable">$i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">$i</span> <span class="operator">&lt;=</span> <span class="variable">$#fhs</span><span class="operator">;</span> <span class="variable">$i</span><span class="operator">++</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="operator">{</span><span class="variable">$fhs</span><span class="operator">[</span><span class="variable">$i</span><span class="operator">]</span><span class="operator">}</span> <span class="string">"just another Perl answer, \n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</p>

<pre><code><code>    <span class="keyword">open</span> <span class="variable">FILE</span><span class="operator">,</span> <span class="string">"&gt; </span><span class="variable">$filename</span><span class="string">"</span><span class="operator">;</span>
    <span class="variable">process_typeglob</span><span class="operator">(</span>   <span class="variable">*FILE</span> <span class="operator">);</span>
    <span class="variable">process_reference</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">*FILE</span> <span class="operator">);</span>
    
    <span class="keyword">sub</span><span class="variable"> process_typeglob  </span><span class="operator">{</span> <span class="keyword">local</span> <span class="variable">*FH</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">print</span> <span class="variable">FH</span>  <span class="string">"Typeglob!"</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> process_reference </span><span class="operator">{</span> <span class="keyword">local</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"Reference!"</span> <span class="operator">}</span>
</code></code></pre>

<p>If you want to create many anonymous handles, you should check out the Symbol or IO::Handle modules.</p>

<h2 id="How-can-I-use-a-filehandle-indirectly-">How can I use a filehandle indirectly? </h2>

<p>An indirect filehandle is the use of something other than a symbol in a place that a filehandle is expected. Here are ways to get indirect filehandles:</p>

<pre><code><code>    <span class="variable">$fh</span> <span class="operator">=</span>   <span class="variable">SOME_FH</span><span class="operator">;</span>       <span class="comment"># bareword is strict-subs hostile</span>
    <span class="variable">$fh</span> <span class="operator">=</span>  <span class="string">"SOME_FH"</span><span class="operator">;</span>      <span class="comment"># strict-refs hostile; same package only</span>
    <span class="variable">$fh</span> <span class="operator">=</span>  <span class="variable">*SOME_FH</span><span class="operator">;</span>       <span class="comment"># typeglob</span>
    <span class="variable">$fh</span> <span class="operator">=</span> <span class="operator">\</span><span class="variable">*SOME_FH</span><span class="operator">;</span>       <span class="comment"># ref to typeglob (bless-able)</span>
    <span class="variable">$fh</span> <span class="operator">=</span>  <span class="variable">*SOME_FH</span><span class="operator">{</span><span class="string">IO</span><span class="operator">}</span><span class="operator">;</span>   <span class="comment"># blessed IO::Handle from *SOME_FH typeglob</span>
</code></code></pre>

<p>Or, you can use the <code><code>new</code></code> method from one of the IO::* modules to create an anonymous filehandle and store that in a scalar variable.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">IO::Handle</span><span class="operator">;</span>                     <span class="comment"># 5.004 or higher</span>
    <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="variable">IO::Handle</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
</code></code></pre>

<p>Then use any of those as you would a normal filehandle. Anywhere that Perl is expecting a filehandle, an indirect filehandle may be used instead. An indirect filehandle is just a scalar variable that contains a filehandle. Functions like <code><code>print</code></code>, <code><code>open</code></code>, <code><code>seek</code></code>, or the <code><code>&lt;FH&gt;</code></code> diamond operator will accept either a named filehandle or a scalar variable containing one:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">$ifh</span><span class="operator">,</span> <span class="variable">$ofh</span><span class="operator">,</span> <span class="variable">$efh</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">*STDIN</span><span class="operator">,</span> <span class="variable">*STDOUT</span><span class="operator">,</span> <span class="variable">*STDERR</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="variable">$ofh</span> <span class="string">"Type it: "</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$got</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$ifh</span><span class="operator">&gt;</span>
    <span class="keyword">print</span> <span class="variable">$efh</span> <span class="string">"What was that: </span><span class="variable">$got</span><span class="string">"</span><span class="operator">;</span>
</code></code></pre>

<p>If you&#39;re passing a filehandle to a function, you can write the function in two ways:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> accept_fh </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"Sending to indirect filehandle\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Or it can localize a typeglob and use the filehandle directly:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> accept_fh </span><span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">*FH</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span>  <span class="variable">FH</span> <span class="string">"Sending to localized filehandle\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</p>

<pre><code><code>    <span class="variable">accept_fh</span><span class="operator">(</span><span class="variable">*STDOUT</span><span class="operator">);</span>
    <span class="variable">accept_fh</span><span class="operator">(</span><span class="variable">$handle</span><span class="operator">);</span>
</code></code></pre>

<p>In the examples above, we assigned the filehandle to a scalar variable before using it. That is because only simple scalar variables, not expressions or subscripts of hashes or arrays, can be used with built-ins like <code><code>print</code></code>, <code><code>printf</code></code>, or the diamond operator. Using something other than a simple scalar variable as a filehandle is illegal and won&#39;t even compile:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@fd</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">*STDIN</span><span class="operator">,</span> <span class="variable">*STDOUT</span><span class="operator">,</span> <span class="variable">*STDERR</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="string">"Type it: "</span><span class="operator">;</span>                           <span class="comment"># WRONG</span>
    <span class="keyword">my</span> <span class="variable">$got</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$fd</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">&gt;</span>                                  <span class="comment"># WRONG</span>
    <span class="keyword">print</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="string">"What was that: </span><span class="variable">$got</span><span class="string">"</span><span class="operator">;</span>                 <span class="comment"># WRONG</span>
</code></code></pre>

<p>With <code><code>print</code></code> and <code><code>printf</code></code>, you get around this by using a block and an expression where you would place the filehandle:</p>

<pre><code><code>    <span class="keyword">print</span>  <span class="operator">{</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">}</span> <span class="string">"funny stuff\n"</span><span class="operator">;</span>
    <span class="keyword">printf</span> <span class="operator">{</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">}</span> <span class="string">"Pity the poor %x.\n"</span><span class="operator">,</span> <span class="number">3_735_928_559</span><span class="operator">;</span>
    <span class="comment"># Pity the poor deadbeef.</span>
</code></code></pre>

<p>That block is a proper block like any other, so you can put more complicated code there. This sends the message out to one of two places:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$ok</span> <span class="operator">=</span> <span class="keyword">-x</span> <span class="string">"/bin/cat"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="operator">{</span> <span class="variable">$ok</span> <span class="operator">?</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">:</span> <span class="variable">$fd</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">}</span> <span class="string">"cat stat </span><span class="variable">$ok</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="operator">{</span> <span class="variable">$fd</span><span class="operator">[</span> <span class="number">1</span><span class="operator">+</span> <span class="operator">(</span><span class="variable">$ok</span> <span class="operator">||</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">]</span>  <span class="operator">}</span> <span class="string">"cat stat </span><span class="variable">$ok</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>This approach of treating <code><code>print</code></code> and <code><code>printf</code></code> like object methods calls doesn&#39;t work for the diamond operator. That&#39;s because it&#39;s a real operator, not just a function with a comma-less argument. Assuming you&#39;ve been storing typeglobs in your structure as we did above, you can use the built-in function named <code><code>readline</code></code> to read a record just as <code><code>&lt;&gt;</code></code> does. Given the initialization shown above for @fd, this would work, but only because readline() requires a typeglob. It doesn&#39;t work with objects or strings, which might be a bug we haven&#39;t fixed yet.</p>

<pre><code><code>    <span class="variable">$got</span> <span class="operator">=</span> <span class="keyword">readline</span><span class="operator">(</span><span class="variable">$fd</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">);</span>
</code></code></pre>

<p>Let it be noted that the flakiness of indirect filehandles is not related to whether they&#39;re strings, typeglobs, objects, or anything else. It&#39;s the syntax of the fundamental operators. Playing the object game doesn&#39;t help you at all here.</p>

<h2 id="How-can-I-set-up-a-footer-format-to-be-used-with-write-">How can I set up a footer format to be used with write()? </h2>

<p>There&#39;s no builtin way to do this, but <a href="../../lib/pods/perlform.html">perlform</a> has a couple of techniques to make it possible for the intrepid hacker.</p>

<h2 id="How-can-I-write-into-a-string-">How can I write() into a string? </h2>

<p>(contributed by brian d foy)</p>

<p>If you want to <code><code>write</code></code> into a string, you just have to &lt;open&gt; a filehandle to a string, which Perl has been able to do since Perl 5.6:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="variable">FH</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$string</span><span class="operator">;</span>
    <span class="keyword">write</span><span class="operator">(</span> <span class="variable">FH</span> <span class="operator">);</span>
</code></code></pre>

<p>Since you want to be a good programmer, you probably want to use a lexical filehandle, even though formats are designed to work with bareword filehandles since the default format names take the filehandle name. However, you can control this with some Perl special per-filehandle variables: <code><code>$^</code></code>, which names the top-of-page format, and <code><code>$~</code></code> which shows the line format. You have to change the default filehandle to set these variables:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">),</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$string</span><span class="operator">;</span>
    
    <span class="operator">{</span> <span class="comment"># set per-filehandle variables</span>
        <span class="keyword">my</span> <span class="variable">$old_fh</span> <span class="operator">=</span> <span class="keyword">select</span><span class="operator">(</span> <span class="variable">$fh</span> <span class="operator">);</span>
        <span class="variable">$~</span> <span class="operator">=</span> <span class="string">'ANIMAL'</span><span class="operator">;</span>
        <span class="variable">$^</span> <span class="operator">=</span> <span class="string">'ANIMAL_TOP'</span><span class="operator">;</span>
        <span class="keyword">select</span><span class="operator">(</span> <span class="variable">$old_fh</span> <span class="operator">);</span>
    <span class="operator">}</span>
    
    <span class="keyword">format</span> <span class="variable">ANIMAL_TOP</span> <span class="operator">=</span><span class="default">
     ID  Type    Name
    .</span>
    
    <span class="keyword">format</span> <span class="variable">ANIMAL</span> <span class="operator">=</span><span class="default">
    @##   @&lt;&lt;&lt;    @&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;
    $id,  $type,  $name
    .</span>
</code></code></pre>

<p>Although write can work with lexical or package variables, whatever variables you use have to scope in the format. That most likely means you&#39;ll want to localize some package variables:</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">local</span><span class="operator">(</span> <span class="variable">$id</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">,</span> <span class="variable">$name</span> <span class="operator">)</span> <span class="operator">=</span> <span class="string">qw( 12 cat Buster )</span><span class="operator">;</span>
        <span class="keyword">write</span><span class="operator">(</span> <span class="variable">$fh</span> <span class="operator">);</span>
    <span class="operator">}</span>
    
    <span class="keyword">print</span> <span class="variable">$string</span><span class="operator">;</span>
</code></code></pre>

<p>There are also some tricks that you can play with <code><code>formline</code></code> and the accumulator variable <code><code>$^A</code></code>, but you lose a lot of the value of formats since <code><code>formline</code></code> won&#39;t handle paging and so on. You end up reimplementing formats when you use them.</p>

<h2 id="How-can-I-open-a-filehandle-to-a-string-">How can I open a filehandle to a string?    </h2>

<p>(contributed by Peter J. Holzer, hjp-usenet2@hjp.at)</p>

<p>Since Perl 5.8.0 a file handle referring to a string can be created by calling open with a reference to that string instead of the filename. This file handle can then be used to read from or write to the string:</p>

<pre><code><code>    <span class="keyword">open</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$string</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Could not open string for writing"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"foo\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"bar\n"</span><span class="operator">;</span>    <span class="comment"># $string now contains "foo\nbar\n"</span>
    
    <span class="keyword">open</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&lt;'</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$string</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Could not open string for reading"</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;;</span>    <span class="comment"># $x now contains "foo\n"</span>
</code></code></pre>

<p>With older versions of Perl, the <a href="../../lib/IO/String.html">IO::String</a> module provides similar functionality.</p>

<h2 id="How-can-I-output-my-numbers-with-commas-added-">How can I output my numbers with commas added? </h2>

<p>(contributed by brian d foy and Benjamin Goldberg)</p>

<p>You can use <a>Number::Format</a> to separate places in a number. It handles locale information for those of you who want to insert full stops instead (or anything else that they want to use, really).</p>

<p>This subroutine will add commas to your number:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> commify </span><span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">$_</span>  <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="number">1</span> <span class="keyword">while</span> <span class="regex">s/^([-+]?\d+)(\d{3})/$1,$2/</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="variable">$_</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>This regex from Benjamin Goldberg will add commas to numbers:</p>

<pre><code><code>    <span class="regex">s/(^[-+]?\d+?(?=(?&gt;(?:\d{3})+)(?!\d))|\G\d{3}(?=\d))/$1,/g</span><span class="operator">;</span>
</code></code></pre>

<p>It is easier to see with comments:</p>

<pre><code><code>    <span class="regex">s/(
        ^[-+]?             # beginning of number.
        \d+?               # first digits before first comma
        (?=                # followed by, (but not included in the match) :
            (?&gt;(?:\d{3})+) # some positive multiple of three digits.
            (?!\d)         # an *exact* multiple, not x * 3 + 1 or whatever.
        )
        |                  # or:
        \G\d{3}            # after the last group, get three digits
        (?=\d)             # but they have to have more digits after them.
    )/$1,/xg</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-can-I-translate-tildes-in-a-filename-">How can I translate tildes (~) in a filename?  </h2>

<p>Use the &lt;&gt; (<code><code>glob()</code></code>) operator, documented in <a href="../../lib/pods/perlfunc.html">perlfunc</a>. Versions of Perl older than 5.6 require that you have a shell installed that groks tildes. Later versions of Perl have this feature built in. The <a>File::KGlob</a> module (available from CPAN) gives more portable glob functionality.</p>

<p>Within Perl, you may use this directly:</p>

<pre><code><code>    <span class="variable">$filename</span> <span class="operator">=~</span> <span class="regex">s{
      ^ ~             # find a leading tilde
      (               # save this in $1
          [^/]        # a non-slash character
                *     # repeated 0 or more times (0 means me)
      )
    }{
      $1
          ? (getpwnam($1))[7]
          : ( $ENV{HOME} || $ENV{LOGDIR} )
    }ex</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-come-when-I-open-a-file-read-write-it-wipes-it-out-">How come when I open a file read-write it wipes it out?     </h2>

<p>Because you&#39;re using something like this, which truncates the file <i>then</i> gives you read-write access:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'+&gt;'</span><span class="operator">,</span> <span class="string">'/path/name'</span><span class="operator">;</span> <span class="comment"># WRONG (almost always)</span>
</code></code></pre>

<p>Whoops. You should instead use this, which will fail if the file doesn&#39;t exist:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'+&lt;'</span><span class="operator">,</span> <span class="string">'/path/name'</span><span class="operator">;</span> <span class="comment"># open for update</span>
</code></code></pre>

<p>Using &quot;&gt;&quot; always clobbers or creates. Using &quot;&lt;&quot; never does either. The &quot;+&quot; doesn&#39;t change this.</p>

<p>Here are examples of many kinds of file opens. Those using <code><code>sysopen</code></code> all assume that you&#39;ve pulled in the constants from <a href="../../lib/Fcntl.html">Fcntl</a>:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Fcntl</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for reading:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&lt;'</span><span class="operator">,</span> <span class="variable">$path</span>                               <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDONLY</span>                       <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for writing, create new file if needed or else truncate old file:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="variable">$path</span>                               <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_TRUNC</span><span class="operator">|</span><span class="variable">O_CREAT</span>       <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_TRUNC</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">,</span> <span class="number">0666</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for writing, create new file, file must not exist:</p>

<pre><code><code>    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span>        <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">,</span> <span class="number">0666</span>  <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for appending, create if necessary:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&gt;&gt;'</span> <span class="variable">$path</span>                               <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_APPEND</span><span class="operator">|</span><span class="variable">O_CREAT</span>      <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_APPEND</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">,</span> <span class="number">0666</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for appending, file must exist:</p>

<pre><code><code>    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_APPEND</span>              <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for update, file must exist:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'+&lt;'</span><span class="operator">,</span> <span class="variable">$path</span>                              <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDWR</span>                         <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for update, create file if necessary:</p>

<pre><code><code>    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDWR</span><span class="operator">|</span><span class="variable">O_CREAT</span>                 <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDWR</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">,</span> <span class="number">0666</span>           <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open file for update, file must not exist:</p>

<pre><code><code>    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDWR</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span>          <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">,</span> <span class="variable">O_RDWR</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span><span class="operator">,</span> <span class="number">0666</span>    <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$!</span><span class="operator">;</span>
</code></code></pre>

<p>To open a file without blocking, creating if necessary:</p>

<pre><code><code>    sysopen my $fh, &#39;/foo/somefile&#39;, O_WRONLY|O_NDELAY|O_CREAT
        or die &quot;can&#39;t open /foo/somefile: $!&quot;:</code></code></pre>

<p>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn&#39;t as exclusive as you might wish.</p>

<p>See also <a href="../../lib/pods/perlopentut.html">perlopentut</a>.</p>

<h2 id="Why-do-I-sometimes-get-an-Argument-list-too-long-when-I-use-">Why do I sometimes get an &quot;Argument list too long&quot; when I use &lt;*&gt;? </h2>

<p>The <code><code>&lt;&gt;</code></code> operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can&#39;t handle more than 127 items and so gives the error message <code><code>Argument list too long</code></code>. People who installed tcsh as csh won&#39;t have this problem, but their users may be surprised by it.</p>

<p>To get around this, either upgrade to Perl v5.6.0 or later, do the glob yourself with readdir() and patterns, or use a module like <a href="../../lib/File/Glob.html">File::Glob</a>, one that doesn&#39;t use the shell to do globbing.</p>

<h2 id="How-can-I-open-a-file-with-a-leading-or-trailing-blanks-">How can I open a file with a leading &quot;&gt;&quot; or trailing blanks? </h2>

<p>(contributed by Brian McCauley)</p>

<p>The special two-argument form of Perl&#39;s open() function ignores trailing blanks in filenames and infers the mode from certain leading characters (or a trailing &quot;|&quot;). In older versions of Perl this was the only version of open() and so it is prevalent in old code and books.</p>

<p>Unless you have a particular reason to use the two-argument form you should use the three-argument form of open() which does not treat any characters in the filename as special.</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"&lt;"</span><span class="operator">,</span> <span class="string">"  file  "</span><span class="operator">;</span>  <span class="comment"># filename is "   file   "</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"&gt;"</span><span class="operator">,</span> <span class="string">"&gt;file"</span><span class="operator">;</span>     <span class="comment"># filename is "&gt;file"</span>
</code></code></pre>

<h2 id="How-can-I-reliably-rename-a-file-">How can I reliably rename a file?    </h2>

<p>If your operating system supports a proper mv(1) utility or its functional equivalent, this works:</p>

<pre><code><code>    <span class="keyword">rename</span><span class="operator">(</span><span class="variable">$old</span><span class="operator">,</span> <span class="variable">$new</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">system</span><span class="operator">(</span><span class="string">"mv"</span><span class="operator">,</span> <span class="variable">$old</span><span class="operator">,</span> <span class="variable">$new</span><span class="operator">);</span>
</code></code></pre>

<p>It may be more portable to use the <a href="../../lib/File/Copy.html">File::Copy</a> module instead. You just copy to the new file to the new name (checking return values), then delete the old one. This isn&#39;t really the same semantically as a <code><code>rename()</code></code>, which preserves meta-information like permissions, timestamps, inode info, etc.</p>

<h2 id="How-can-I-lock-a-file-">How can I lock a file?   </h2>

<p>Perl&#39;s builtin flock() function (see <a href="../../lib/pods/perlfunc.html">perlfunc</a> for details) will call flock(2) if that exists, fcntl(2) if it doesn&#39;t (on perl version 5.004 and later), and lockf(3) if neither of the two previous system calls exists. On some systems, it may even use a different form of native locking. Here are some gotchas with Perl&#39;s flock():</p>

<ol>

<li><p>Produces a fatal error if none of the three system calls (or their close equivalent) exists.</p>

</li>
<li><p>lockf(3) does not provide shared locking, and requires that the filehandle be open for writing (or appending, or read/writing).</p>

</li>
<li><p>Some versions of flock() can&#39;t lock files over a network (e.g. on NFS file systems), so you&#39;d need to force the use of fcntl(2) when you build Perl. But even this is dubious at best. See the flock entry of <a href="../../lib/pods/perlfunc.html">perlfunc</a> and the <i>INSTALL</i> file in the source distribution for information on building Perl to do this.</p>

<p>Two potentially non-obvious but traditional flock semantics are that it waits indefinitely until the lock is granted, and that its locks are <i>merely advisory</i>. Such discretionary locks are more flexible, but offer fewer guarantees. This means that files locked with flock() may be modified by programs that do not also use flock(). Cars that stop for red lights get on well with each other, but not with cars that don&#39;t stop for red lights. See the perlport manpage, your port&#39;s specific documentation, or your system-specific local manpages for details. It&#39;s best to assume traditional behavior if you&#39;re writing portable programs. (If you&#39;re not, you should as always feel perfectly free to write for your own system&#39;s idiosyncrasies (sometimes called &quot;features&quot;). Slavish adherence to portability concerns shouldn&#39;t get in the way of your getting your job done.)</p>

<p>For more information on file locking, see also <a href="../../lib/pods/perlopentut.html#File-Locking">&quot;File Locking&quot; in perlopentut</a> if you have it (new for 5.6).</p>

</li>
</ol>

<h2 id="Why-cant-I-just-open-FH-file.lock-">Why can&#39;t I just open(FH, &quot;&gt;file.lock&quot;)? </h2>

<p>A common bit of code <b>NOT TO USE</b> is this:</p>

<pre><code><code>    <span class="keyword">sleep</span><span class="operator">(</span><span class="number">3</span><span class="operator">)</span> <span class="keyword">while</span> <span class="keyword">-e</span> <span class="string">'file.lock'</span><span class="operator">;</span>    <span class="comment"># PLEASE DO NOT USE</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$lock</span><span class="operator">,</span> <span class="string">'&gt;'</span><span class="operator">,</span> <span class="string">'file.lock'</span><span class="operator">;</span> <span class="comment"># THIS BROKEN CODE</span>
</code></code></pre>

<p>This is a classic race condition: you take two steps to do something which must be done in one. That&#39;s why computer hardware provides an atomic test-and-set instruction. In theory, this &quot;ought&quot; to work:</p>

<pre><code><code>    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"file.lock"</span><span class="operator">,</span> <span class="variable">O_WRONLY</span><span class="operator">|</span><span class="variable">O_EXCL</span><span class="operator">|</span><span class="variable">O_CREAT</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't open  file.lock: $!"</span><span class="operator">;</span>
</code></code></pre>

<p>except that lamentably, file creation (and deletion) is not atomic over NFS, so this won&#39;t work (at least, not every time) over the net. Various schemes involving link() have been suggested, but these tend to involve busy-wait, which is also less than desirable.</p>

<h2 id="I-still-dont-get-locking.-I-just-want-to-increment-the-number-in-the-file.-How-can-I-do-this-">I still don&#39;t get locking. I just want to increment the number in the file. How can I do this?  </h2>

<p>Didn&#39;t anyone ever tell you web-page hit counters were useless? They don&#39;t count number of hits, they&#39;re a waste of time, and they serve only to stroke the writer&#39;s vanity. It&#39;s better to pick a random number; they&#39;re more realistic.</p>

<p>Anyway, this is what you can do if you can&#39;t help yourself.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Fcntl</span> <span class="string">qw(:DEFAULT :flock)</span><span class="operator">;</span>
    <span class="keyword">sysopen</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"numfile"</span><span class="operator">,</span> <span class="variable">O_RDWR</span><span class="operator">|</span><span class="variable">O_CREAT</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't open numfile: $!"</span><span class="operator">;</span>
    <span class="keyword">flock</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">LOCK_EX</span>                        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't flock numfile: $!"</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$num</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;</span> <span class="operator">||</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">seek</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">0</span>                            <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't rewind numfile: $!"</span><span class="operator">;</span>
    <span class="keyword">truncate</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="number">0</span>                           <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't truncate numfile: $!"</span><span class="operator">;</span>
    <span class="operator">(</span><span class="keyword">print</span> <span class="variable">$fh</span> <span class="variable">$num</span><span class="operator">+</span><span class="number">1</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">)</span>                  <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't write numfile: $!"</span><span class="operator">;</span>
    <span class="keyword">close</span> <span class="variable">$fh</span>                                 <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't close numfile: $!"</span><span class="operator">;</span>
</code></code></pre>

<p>Here&#39;s a much better web-page hit counter:</p>

<pre><code><code>    <span class="variable">$hits</span> <span class="operator">=</span> <span class="keyword">int</span><span class="operator">(</span> <span class="operator">(</span><span class="keyword">time</span><span class="operator">()</span> <span class="operator">-</span> <span class="number">850_000_000</span><span class="operator">)</span> <span class="operator">/</span> <span class="keyword">rand</span><span class="operator">(</span><span class="number">1_000</span><span class="operator">)</span> <span class="operator">);</span>
</code></code></pre>

<p>If the count doesn&#39;t impress your friends, then the code might. :-)</p>

<h2 id="All-I-want-to-do-is-append-a-small-amount-of-text-to-the-end-of-a-file.-Do-I-still-have-to-use-locking-">All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?  </h2>

<p>If you are on a system that correctly implements <code><code>flock</code></code> and you use the example appending code from &quot;perldoc -f flock&quot; everything will be OK even if the OS you are on doesn&#39;t implement append mode correctly (if such a system exists). So if you are happy to restrict yourself to OSs that implement <code><code>flock</code></code> (and that&#39;s not really much of a restriction) then that is what you should do.</p>

<p>If you know you are only going to use a system that does correctly implement appending (i.e. not Win32) then you can omit the <code><code>seek</code></code> from the code in the previous answer.</p>

<p>If you know you are only writing code to run on an OS and filesystem that does implement append mode correctly (a local filesystem on a modern Unix for example), and you keep the file in block-buffered mode and you write less than one buffer-full of output between each manual flushing of the buffer then each bufferload is almost guaranteed to be written to the end of the file in one chunk without getting intermingled with anyone else&#39;s output. You can also use the <code><code>syswrite</code></code> function which is simply a wrapper around your system&#39;s <code><code>write(2)</code></code> system call.</p>

<p>There is still a small theoretical chance that a signal will interrupt the system-level <code><code>write()</code></code> operation before completion. There is also a possibility that some STDIO implementations may call multiple system level <code><code>write()</code></code>s even if the buffer was empty to start. There may be some systems where this probability is reduced to zero, and this is not a concern when using <code><code>:perlio</code></code> instead of your system&#39;s STDIO.</p>

<h2 id="How-do-I-randomly-update-a-binary-file-">How do I randomly update a binary file? </h2>

<p>If you&#39;re just trying to patch a binary, in many cases something as simple as this works:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">i</span> <span class="operator">-</span><span class="variable">pe</span> <span class="string">'s{window manager}{window mangler}g'</span> <span class="operator">/</span><span class="variable">usr</span><span class="operator">/</span><span class="variable">bin</span><span class="operator">/</span><span class="variable">emacs</span>
</code></code></pre>

<p>However, if you have fixed sized records, then you might do something more like this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$RECSIZE</span> <span class="operator">=</span> <span class="number">220</span><span class="operator">;</span> <span class="comment"># size of record, in bytes</span>
    <span class="keyword">my</span> <span class="variable">$recno</span>   <span class="operator">=</span> <span class="number">37</span><span class="operator">;</span>  <span class="comment"># which record to update</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'+&lt;'</span><span class="operator">,</span> <span class="string">'somewhere'</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't update somewhere: $!"</span><span class="operator">;</span>
    <span class="keyword">seek</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$recno</span> <span class="operator">*</span> <span class="variable">$RECSIZE</span><span class="operator">,</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">read</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$record</span><span class="operator">,</span> <span class="variable">$RECSIZE</span> <span class="operator">==</span> <span class="variable">$RECSIZE</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't read record </span><span class="variable">$recno</span><span class="string">: $!"</span><span class="operator">;</span>
    <span class="comment"># munge the record</span>
    <span class="keyword">seek</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="operator">-</span><span class="variable">$RECSIZE</span><span class="operator">,</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="variable">$fh</span> <span class="variable">$record</span><span class="operator">;</span>
    <span class="keyword">close</span> <span class="variable">$fh</span><span class="operator">;</span>
</code></code></pre>

<p>Locking and error checking are left as an exercise for the reader. Don&#39;t forget them or you&#39;ll be quite sorry.</p>

<h2 id="How-do-I-get-a-files-timestamp-in-perl-">How do I get a file&#39;s timestamp in perl?  </h2>

<p>If you want to retrieve the time at which the file was last read, written, or had its meta-data (owner, etc) changed, you use the <b>-A</b>, <b>-M</b>, or <b>-C</b> file test operations as documented in <a href="../../lib/pods/perlfunc.html">perlfunc</a>. These retrieve the age of the file (measured against the start-time of your program) in days as a floating point number. Some platforms may not have all of these times. See <a href="../../lib/pods/perlport.html">perlport</a> for details. To retrieve the &quot;raw&quot; time in seconds since the epoch, you would call the stat function, then use <code><code>localtime()</code></code>, <code><code>gmtime()</code></code>, or <code><code>POSIX::strftime()</code></code> to convert this into human-readable form.</p>

<p>Here&#39;s an example:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$write_secs</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">stat</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">))</span><span class="operator">[</span><span class="number">9</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">printf</span> <span class="string">"file %s updated at %s\n"</span><span class="operator">,</span> <span class="variable">$file</span><span class="operator">,</span>
        <span class="keyword">scalar</span> <span class="keyword">localtime</span><span class="operator">(</span><span class="variable">$write_secs</span><span class="operator">);</span>
</code></code></pre>

<p>If you prefer something more legible, use the File::stat module (part of the standard distribution in version 5.004 and later):</p>

<pre><code><code>    <span class="comment"># error checking left as an exercise for reader.</span>
    <span class="keyword">use</span> <span class="variable">File::stat</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">Time::localtime</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$date_string</span> <span class="operator">=</span> <span class="variable">ctime</span><span class="operator">(</span><span class="keyword">stat</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">)-&gt;</span><span class="variable">mtime</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"file </span><span class="variable">$file</span><span class="string"> updated at </span><span class="variable">$date_string</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>The POSIX::strftime() approach has the benefit of being, in theory, independent of the current locale. See <a href="../../lib/pods/perllocale.html">perllocale</a> for details.</p>

<h2 id="How-do-I-set-a-files-timestamp-in-perl-">How do I set a file&#39;s timestamp in perl?  </h2>

<p>You use the utime() function documented in <a href="../../lib/pods/perlfunc.html#utime">&quot;utime&quot; in perlfunc</a>. By way of example, here&#39;s a little program that copies the read and write times from its first argument to all the rest of them.</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">@ARGV</span> <span class="operator">&lt;</span> <span class="number">2</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">die</span> <span class="string">"usage: cptimes timestamp_file other_files ...\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">my</span> <span class="variable">$timestamp</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$atime</span><span class="operator">,</span> <span class="variable">$mtime</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">stat</span><span class="operator">(</span><span class="variable">$timestamp</span><span class="operator">))</span><span class="operator">[</span><span class="number">8</span><span class="operator">,</span><span class="number">9</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">utime</span> <span class="variable">$atime</span><span class="operator">,</span> <span class="variable">$mtime</span><span class="operator">,</span> <span class="variable">@ARGV</span><span class="operator">;</span>
</code></code></pre>

<p>Error checking is, as usual, left as an exercise for the reader.</p>

<p>The perldoc for utime also has an example that has the same effect as touch(1) on files that <i>already exist</i>.</p>

<p>Certain file systems have a limited ability to store the times on a file at the expected level of precision. For example, the FAT and HPFS filesystem are unable to create dates on files with a finer granularity than two seconds. This is a limitation of the filesystems, not of utime().</p>

<h2 id="How-do-I-print-to-more-than-one-file-at-once-">How do I print to more than one file at once? </h2>

<p>To connect one filehandle to several output filehandles, you can use the <a>IO::Tee</a> or <a>Tie::FileHandle::Multiplex</a> modules.</p>

<p>If you only have to do this once, you can print individually to each filehandle.</p>

<pre><code><code>    <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">(</span><span class="variable">$fh1</span><span class="operator">,</span> <span class="variable">$fh2</span><span class="operator">,</span> <span class="variable">$fh3</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"whatever\n"</span> <span class="operator">}</span>
</code></code></pre>

<h2 id="How-can-I-read-in-an-entire-file-all-at-once-">How can I read in an entire file all at once?  </h2>

<p>The customary Perl approach for processing all the lines in a file is to do so one line at a time:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$input</span><span class="operator">,</span> <span class="string">'&lt;'</span><span class="operator">,</span> <span class="variable">$file</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't open </span><span class="variable">$file</span><span class="string">: $!"</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(&lt;</span><span class="variable">$input</span><span class="operator">&gt;)</span> <span class="operator">{</span>
        <span class="keyword">chomp</span><span class="operator">;</span>
        <span class="comment"># do something with $_</span>
    <span class="operator">}</span>
    <span class="keyword">close</span> <span class="variable">$input</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't close </span><span class="variable">$file</span><span class="string">: $!"</span><span class="operator">;</span>
</code></code></pre>

<p>This is tremendously more efficient than reading the entire file into memory as an array of lines and then processing it one element at a time, which is often--if not almost always--the wrong approach. Whenever you see someone do this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@lines</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">INPUT</span><span class="operator">&gt;;</span>
</code></code></pre>

<p>You should think long and hard about why you need everything loaded at once. It&#39;s just not a scalable solution.</p>

<p>If you &quot;mmap&quot; the file with the File::Map module from CPAN, you can virtually load the entire file into a string without actually storing it in memory:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Map</span> <span class="string">qw(map_file)</span><span class="operator">;</span>
    
    <span class="variable">map_file</span> <span class="keyword">my</span> <span class="variable">$string</span><span class="operator">,</span> <span class="variable">$filename</span><span class="operator">;</span>
</code></code></pre>

<p>Once mapped, you can treat <code><code>$string</code></code> as you would any other string. Since you don&#39;t necessarily have to load the data, mmap-ing can be very fast and may not increase your memory footprint.</p>

<p>You might also find it more fun to use the standard <a href="../../lib/Tie/File.html">Tie::File</a> module, or the <a>DB_File</a> module&#39;s <code><code>$DB_RECNO</code></code> bindings, which allow you to tie an array to a file so that accessing an element of the array actually accesses the corresponding line in the file.</p>

<p>If you want to load the entire file, you can use the <a>File::Slurp</a> module to do it in one one simple and efficient step:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Slurp</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$all_of_it</span> <span class="operator">=</span> <span class="variable">read_file</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span> <span class="comment"># entire file in scalar</span>
    <span class="keyword">my</span> <span class="variable">@all_lines</span> <span class="operator">=</span> <span class="variable">read_file</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span> <span class="comment"># one line per element</span>
</code></code></pre>

<p>Or you can read the entire file contents into a scalar like this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$var</span><span class="operator">;</span>
    <span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">$/</span><span class="operator">;</span>
        <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">'&lt;'</span><span class="operator">,</span> <span class="variable">$file</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"can't open </span><span class="variable">$file</span><span class="string">: $!"</span><span class="operator">;</span>
        <span class="variable">$var</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>That temporarily undefs your record separator, and will automatically close the file at block exit. If the file is already open, just use this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">=</span> <span class="keyword">do</span> <span class="operator">{</span> <span class="keyword">local</span> <span class="variable">$/</span><span class="operator">;</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;</span> <span class="operator">};</span>
</code></code></pre>

<p>You can also use a localized <code><code>@ARGV</code></code> to eliminate the <code><code>open</code></code>:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">=</span> <span class="keyword">do</span> <span class="operator">{</span> <span class="keyword">local</span><span class="operator">(</span> <span class="variable">@ARGV</span><span class="operator">,</span> <span class="variable">$/</span> <span class="operator">)</span> <span class="operator">=</span> <span class="variable">$file</span><span class="operator">;</span> <span class="operator">&lt;&gt;</span> <span class="operator">};</span>
</code></code></pre>

<p>For ordinary files you can also use the <code><code>read</code></code> function.</p>

<pre><code><code>    <span class="keyword">read</span><span class="operator">(</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="variable">$var</span><span class="operator">,</span> <span class="keyword">-s</span> <span class="variable">$fh</span> <span class="operator">);</span>
</code></code></pre>

<p>That third argument tests the byte size of the data on the <code><code>$fh</code></code> filehandle and reads that many bytes into the buffer <code><code>$var</code></code>.</p>

<h2 id="How-can-I-read-in-a-file-by-paragraphs-">How can I read in a file by paragraphs? </h2>

<p>Use the <code><code>$/</code></code> variable (see <a href="../../lib/pods/perlvar.html">perlvar</a> for details). You can either set it to <code><code>&quot;&quot;</code></code> to eliminate empty paragraphs (<code><code>&quot;abc\n\n\n\ndef&quot;</code></code>, for instance, gets treated as two paragraphs and not three), or <code><code>&quot;\n\n&quot;</code></code> to accept empty paragraphs.</p>

<p>Note that a blank line must have no blanks in it. Thus <span style="white-space: nowrap;"><code><code>&quot;fred\n \nstuff\n\n&quot;</code></code></span> is one paragraph, but <code><code>&quot;fred\n\nstuff\n\n&quot;</code></code> is two.</p>

<h2 id="How-can-I-read-a-single-character-from-a-file-From-the-keyboard-">How can I read a single character from a file? From the keyboard?  </h2>

<p>You can use the builtin <code><code>getc()</code></code> function for most filehandles, but it won&#39;t (easily) work on a terminal device. For STDIN, either use the Term::ReadKey module from CPAN or use the sample code in <a href="../../lib/pods/perlfunc.html#getc">&quot;getc&quot; in perlfunc</a>.</p>

<p>If your system supports the portable operating system programming interface (POSIX), you can use the following code, which you&#39;ll note turns off echo processing as well.</p>

<pre><code><code>    <span class="comment">#!/usr/bin/perl -w</span>
    <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
    <span class="variable">$|</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">4</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"gimme: "</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$got</span> <span class="operator">=</span> <span class="variable">getone</span><span class="operator">();</span>
        <span class="keyword">print</span> <span class="string">"--&gt; </span><span class="variable">$got</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">exit</span><span class="operator">;</span>
    
    <span class="keyword">BEGIN</span> <span class="operator">{</span>
        <span class="keyword">use</span> <span class="variable">POSIX</span> <span class="string">qw(:termios_h)</span><span class="operator">;</span>
    
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$term</span><span class="operator">,</span> <span class="variable">$oterm</span><span class="operator">,</span> <span class="variable">$echo</span><span class="operator">,</span> <span class="variable">$noecho</span><span class="operator">,</span> <span class="variable">$fd_stdin</span><span class="operator">);</span>
    
        <span class="keyword">my</span> <span class="variable">$fd_stdin</span> <span class="operator">=</span> <span class="keyword">fileno</span><span class="operator">(</span><span class="variable">STDIN</span><span class="operator">);</span>
    
        <span class="variable">$term</span>     <span class="operator">=</span> <span class="variable">POSIX::Termios</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
        <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">getattr</span><span class="operator">(</span><span class="variable">$fd_stdin</span><span class="operator">);</span>
        <span class="variable">$oterm</span>     <span class="operator">=</span> <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">getlflag</span><span class="operator">();</span>
    
        <span class="variable">$echo</span>     <span class="operator">=</span> <span class="variable">ECHO</span> <span class="operator">|</span> <span class="variable">ECHOK</span> <span class="operator">|</span> <span class="variable">ICANON</span><span class="operator">;</span>
        <span class="variable">$noecho</span>   <span class="operator">=</span> <span class="variable">$oterm</span> <span class="operator">&amp;</span> <span class="operator">~</span><span class="variable">$echo</span><span class="operator">;</span>
    
        <span class="keyword">sub</span><span class="variable"> cbreak </span><span class="operator">{</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setlflag</span><span class="operator">(</span><span class="variable">$noecho</span><span class="operator">);</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setcc</span><span class="operator">(</span><span class="variable">VTIME</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setattr</span><span class="operator">(</span><span class="variable">$fd_stdin</span><span class="operator">,</span> <span class="variable">TCSANOW</span><span class="operator">);</span>
        <span class="operator">}</span>
    
        <span class="keyword">sub</span><span class="variable"> cooked </span><span class="operator">{</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setlflag</span><span class="operator">(</span><span class="variable">$oterm</span><span class="operator">);</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setcc</span><span class="operator">(</span><span class="variable">VTIME</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
            <span class="variable">$term</span><span class="operator">-&gt;</span><span class="variable">setattr</span><span class="operator">(</span><span class="variable">$fd_stdin</span><span class="operator">,</span> <span class="variable">TCSANOW</span><span class="operator">);</span>
        <span class="operator">}</span>
    
        <span class="keyword">sub</span><span class="variable"> getone </span><span class="operator">{</span>
            <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
            <span class="variable">cbreak</span><span class="operator">();</span>
            <span class="keyword">sysread</span><span class="operator">(</span><span class="variable">STDIN</span><span class="operator">,</span> <span class="variable">$key</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
            <span class="variable">cooked</span><span class="operator">();</span>
            <span class="keyword">return</span> <span class="variable">$key</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
    
    <span class="keyword">END</span> <span class="operator">{</span> <span class="variable">cooked</span><span class="operator">()</span> <span class="operator">}</span>
</code></code></pre>

<p>The Term::ReadKey module from CPAN may be easier to use. Recent versions include also support for non-portable systems as well.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Term::ReadKey</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$tty</span><span class="operator">,</span> <span class="string">'&lt;'</span><span class="operator">,</span> <span class="string">'/dev/tty'</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Gimme a char: "</span><span class="operator">;</span>
    <span class="variable">ReadMode</span> <span class="string">"raw"</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="variable">ReadKey</span> <span class="number">0</span><span class="operator">,</span> <span class="variable">$tty</span><span class="operator">;</span>
    <span class="variable">ReadMode</span> <span class="string">"normal"</span><span class="operator">;</span>
    <span class="keyword">printf</span> <span class="string">"\nYou said %s, char number %03d\n"</span><span class="operator">,</span>
        <span class="variable">$key</span><span class="operator">,</span> <span class="keyword">ord</span> <span class="variable">$key</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-can-I-tell-whether-theres-a-character-waiting-on-a-filehandle-">How can I tell whether there&#39;s a character waiting on a filehandle?</h2>

<p>The very first thing you should do is look into getting the Term::ReadKey extension from CPAN. As we mentioned earlier, it now even has limited support for non-portable (read: not open systems, closed, proprietary, not POSIX, not Unix, etc.) systems.</p>

<p>You should also check out the Frequently Asked Questions list in comp.unix.* for things like this: the answer is essentially the same. It&#39;s very system-dependent. Here&#39;s one solution that works on BSD systems:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> key_ready </span><span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$rin</span><span class="operator">,</span> <span class="variable">$nfd</span><span class="operator">);</span>
        <span class="keyword">vec</span><span class="operator">(</span><span class="variable">$rin</span><span class="operator">,</span> <span class="keyword">fileno</span><span class="operator">(</span><span class="variable">STDIN</span><span class="operator">),</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="variable">$nfd</span> <span class="operator">=</span> <span class="keyword">select</span><span class="operator">(</span><span class="variable">$rin</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
    <span class="operator">}</span>
</code></code></pre>

<p>If you want to find out how many characters are waiting, there&#39;s also the FIONREAD ioctl call to be looked at. The <i>h2ph</i> tool that comes with Perl tries to convert C include files to Perl code, which can be <code><code>require</code></code>d. FIONREAD ends up defined as a function in the <i>sys/ioctl.ph</i> file:</p>

<pre><code><code>    <span class="keyword">require</span> <span class="string">'sys/ioctl.ph'</span><span class="operator">;</span>
    
    <span class="variable">$size</span> <span class="operator">=</span> <span class="keyword">pack</span><span class="operator">(</span><span class="string">"L"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
    <span class="keyword">ioctl</span><span class="operator">(</span><span class="variable">FH</span><span class="operator">,</span> <span class="variable">FIONREAD</span><span class="operator">(),</span> <span class="variable">$size</span><span class="operator">)</span>    <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't call ioctl: $!\n"</span><span class="operator">;</span>
    <span class="variable">$size</span> <span class="operator">=</span> <span class="keyword">unpack</span><span class="operator">(</span><span class="string">"L"</span><span class="operator">,</span> <span class="variable">$size</span><span class="operator">);</span>
</code></code></pre>

<p>If <i>h2ph</i> wasn&#39;t installed or doesn&#39;t work for you, you can <i>grep</i> the include files by hand:</p>

<pre><code><code>    % grep FIONREAD /usr/include/*/*
    /usr/include/asm/ioctls.h:#define FIONREAD      0x541B</code></code></pre>

<p>Or write a small C program using the editor of champions:</p>

<pre><code><code>    % cat &gt; fionread.c
    #include &lt;sys/ioctl.h&gt;
    main() {
        printf(&quot;%#08x\n&quot;, FIONREAD);
    }
    ^D
    % cc -o fionread fionread.c
    % ./fionread
    0x4004667f</code></code></pre>

<p>And then hard-code it, leaving porting as an exercise to your successor.</p>

<pre><code><code>    <span class="variable">$FIONREAD</span> <span class="operator">=</span> <span class="number">0x4004667f</span><span class="operator">;</span>         <span class="comment"># XXX: opsys dependent</span>
    
    <span class="variable">$size</span> <span class="operator">=</span> <span class="keyword">pack</span><span class="operator">(</span><span class="string">"L"</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
    <span class="keyword">ioctl</span><span class="operator">(</span><span class="variable">FH</span><span class="operator">,</span> <span class="variable">$FIONREAD</span><span class="operator">,</span> <span class="variable">$size</span><span class="operator">)</span>     <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Couldn't call ioctl: $!\n"</span><span class="operator">;</span>
    <span class="variable">$size</span> <span class="operator">=</span> <span class="keyword">unpack</span><span class="operator">(</span><span class="string">"L"</span><span class="operator">,</span> <span class="variable">$size</span><span class="operator">);</span>
</code></code></pre>

<p>FIONREAD requires a filehandle connected to a stream, meaning that sockets, pipes, and tty devices work, but <i>not</i> files.</p>

<h2 id="How-do-I-do-a-in-perl-">How do I do a <code><code>tail -f</code></code> in perl?    </h2>

<p>First try</p>

<pre><code><code>    <span class="keyword">seek</span><span class="operator">(</span><span class="variable">$gw_fh</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</code></code></pre>

<p>The statement <code><code>seek($gw_fh, 0, 1)</code></code> doesn&#39;t change the current position, but it does clear the end-of-file condition on the handle, so that the next <code><code>&lt;$gw_fh&gt;</code></code> makes Perl try again to read something.</p>

<p>If that doesn&#39;t work (it relies on features of your stdio implementation), then you need something more like this:</p>

<pre><code><code>    <span class="keyword">for</span> <span class="operator">(;;)</span> <span class="operator">{</span>
      <span class="keyword">for</span> <span class="operator">(</span><span class="variable">$curpos</span> <span class="operator">=</span> <span class="keyword">tell</span><span class="operator">(</span><span class="variable">$gw_fh</span><span class="operator">);</span> <span class="operator">&lt;</span><span class="variable">$gw_fh</span><span class="operator">&gt;;</span> <span class="variable">$curpos</span> <span class="operator">=</span><span class="keyword">tell</span><span class="operator">(</span><span class="variable">$gw_fh</span><span class="operator">))</span> <span class="operator">{</span>
        <span class="comment"># search for some stuff and put it into files</span>
      <span class="operator">}</span>
      <span class="comment"># sleep for a while</span>
      <span class="keyword">seek</span><span class="operator">(</span><span class="variable">$gw_fh</span><span class="operator">,</span> <span class="variable">$curpos</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>  <span class="comment"># seek to where we had been</span>
    <span class="operator">}</span>
</code></code></pre>

<p>If this still doesn&#39;t work, look into the <code><code>clearerr</code></code> method from <a href="../../lib/IO/Handle.html">IO::Handle</a>, which resets the error and end-of-file states on the handle.</p>

<p>There&#39;s also a <a>File::Tail</a> module from CPAN.</p>

<h2 id="How-do-I-dup-a-filehandle-in-Perl-">How do I dup() a filehandle in Perl? </h2>

<p>If you check <a href="../../lib/pods/perlfunc.html#open">&quot;open&quot; in perlfunc</a>, you&#39;ll see that several of the ways to call open() should do the trick. For example:</p>

<pre><code><code>    <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$log</span><span class="operator">,</span> <span class="string">'&gt;&gt;'</span><span class="operator">,</span> <span class="string">'/foo/logfile'</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="variable">STDERR</span><span class="operator">,</span> <span class="string">'&gt;&amp;'</span><span class="operator">,</span> <span class="variable">$log</span><span class="operator">;</span>
</code></code></pre>

<p>Or even with a literal numeric descriptor:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$fd</span> <span class="operator">=</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">MHCONTEXTFD</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">open</span> <span class="variable">$mhcontext</span><span class="operator">,</span> <span class="string">"&lt;&amp;=</span><span class="variable">$fd</span><span class="string">"</span><span class="operator">;</span>  <span class="comment"># like fdopen(3S)</span>
</code></code></pre>

<p>Note that &quot;&lt;&amp;STDIN&quot; makes a copy, but &quot;&lt;&amp;=STDIN&quot; makes an alias. That means if you close an aliased handle, all aliases become inaccessible. This is not true with a copied one.</p>

<p>Error checking, as always, has been left as an exercise for the reader.</p>

<h2 id="How-do-I-close-a-file-descriptor-by-number-">How do I close a file descriptor by number?   </h2>

<p>If, for some reason, you have a file descriptor instead of a filehandle (perhaps you used <code><code>POSIX::open</code></code>), you can use the <code><code>close()</code></code> function from the <a href="../../lib/POSIX.html">POSIX</a> module:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">POSIX</span> <span class="operator">();</span>
    
    <span class="variable">POSIX::close</span><span class="operator">(</span> <span class="variable">$fd</span> <span class="operator">);</span>
</code></code></pre>

<p>This should rarely be necessary, as the Perl <code><code>close()</code></code> function is to be used for things that Perl opened itself, even if it was a dup of a numeric descriptor as with <code><code>MHCONTEXT</code></code> above. But if you really have to, you may be able to do this:</p>

<pre><code><code>    <span class="keyword">require</span> <span class="string">'sys/syscall.ph'</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$rc</span> <span class="operator">=</span> <span class="keyword">syscall</span><span class="operator">(&amp;</span><span class="variable">SYS_close</span><span class="operator">,</span> <span class="variable">$fd</span> <span class="operator">+</span> <span class="number">0</span><span class="operator">);</span>  <span class="comment"># must force numeric</span>
    <span class="keyword">die</span> <span class="string">"can't sysclose </span><span class="variable">$fd</span><span class="string">: $!"</span> <span class="keyword">unless</span> <span class="variable">$rc</span> <span class="operator">==</span> <span class="operator">-</span><span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>Or, just use the fdopen(3S) feature of <code><code>open()</code></code>:</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">open</span> <span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"&lt;&amp;=</span><span class="variable">$fd</span><span class="string">"</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot reopen fd=</span><span class="variable">$fd</span><span class="string">: $!"</span><span class="operator">;</span>
        <span class="keyword">close</span> <span class="variable">$fh</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="Why-cant-I-use-C:-temp-foo-in-DOS-paths-Why-doesnt-C:-temp-foo.exe-work-">Why can&#39;t I use &quot;C:\temp\foo&quot; in DOS paths? Why doesn&#39;t `C:\temp\foo.exe` work? </h2>

<p>Whoops! You just put a tab and a formfeed into that filename! Remember that within double quoted strings (&quot;like\this&quot;), the backslash is an escape character. The full list of these is in <a href="../../lib/pods/perlop.html#Quote-and-Quote-like-Operators">&quot;Quote and Quote-like Operators&quot; in perlop</a>. Unsurprisingly, you don&#39;t have a file called &quot;c:(tab)emp(formfeed)oo&quot; or &quot;c:(tab)emp(formfeed)oo.exe&quot; on your legacy DOS filesystem.</p>

<p>Either single-quote your strings, or (preferably) use forward slashes. Since all DOS and Windows versions since something like MS-DOS 2.0 or so have treated <code><code>/</code></code> and <code><code>\</code></code> the same in a path, you might as well use the one that doesn&#39;t clash with Perl--or the POSIX shell, ANSI C and C++, awk, Tcl, Java, or Python, just to mention a few. POSIX paths are more portable, too.</p>

<h2 id="Why-doesnt-glob-.-get-all-the-files-">Why doesn&#39;t glob(&quot;*.*&quot;) get all the files? </h2>

<p>Because even on non-Unix ports, Perl&#39;s glob function follows standard Unix globbing semantics. You&#39;ll need <code><code>glob(&quot;*&quot;)</code></code> to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</p>

<h2 id="Why-does-Perl-let-me-delete-read-only-files-Why-does-clobber-protected-files-Isnt-this-a-bug-in-Perl-">Why does Perl let me delete read-only files? Why does <code><code>-i</code></code> clobber protected files? Isn&#39;t this a bug in Perl?</h2>

<p>This is elaborately and painstakingly described in the <i>file-dir-perms</i> article in the &quot;Far More Than You Ever Wanted To Know&quot; collection in <a href="http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz">http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz</a> .</p>

<p>The executive summary: learn how your filesystem works. The permissions on a file say what can happen to the data in that file. The permissions on a directory say what can happen to the list of files in that directory. If you delete a file, you&#39;re removing its name from the directory (so the operation depends on the permissions of the directory, not of the file). If you try to write to the file, the permissions of the file govern whether you&#39;re allowed to.</p>

<h2 id="How-do-I-select-a-random-line-from-a-file-">How do I select a random line from a file? </h2>

<p>Short of loading the file into a database or pre-indexing the lines in the file, there are a couple of things that you can do.</p>

<p>Here&#39;s a reservoir-sampling algorithm from the Camel Book:</p>

<pre><code><code>    <span class="keyword">srand</span><span class="operator">;</span>
    <span class="keyword">rand</span><span class="operator">(</span><span class="variable">$.</span><span class="operator">)</span> <span class="operator">&lt;</span> <span class="number">1</span> <span class="operator">&amp;&amp;</span> <span class="operator">(</span><span class="variable">$line</span> <span class="operator">=</span> <span class="variable">$_</span><span class="operator">)</span> <span class="keyword">while</span> <span class="operator">&lt;&gt;;</span>
</code></code></pre>

<p>This has a significant advantage in space over reading the whole file in. You can find a proof of this method in <i>The Art of Computer Programming</i>, Volume 2, Section 3.4.2, by Donald E. Knuth.</p>

<p>You can use the <a>File::Random</a> module which provides a function for that algorithm:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Random</span> <span class="string">qw/random_line/</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$line</span> <span class="operator">=</span> <span class="variable">random_line</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span>
</code></code></pre>

<p>Another way is to use the <a href="../../lib/Tie/File.html">Tie::File</a> module, which treats the entire file as an array. Simply access a random array element.</p>

<h2 id="Why-do-I-get-weird-spaces-when-I-print-an-array-of-lines-">Why do I get weird spaces when I print an array of lines?</h2>

<p>(contributed by brian d foy)</p>

<p>If you are seeing spaces between the elements of your array when you print the array, you are probably interpolating the array in double quotes:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@animals</span> <span class="operator">=</span> <span class="string">qw(camel llama alpaca vicuna)</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"animals are: </span><span class="variable">@animals</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>It&#39;s the double quotes, not the <code><code>print</code></code>, doing this. Whenever you interpolate an array in a double quote context, Perl joins the elements with spaces (or whatever is in <code><code>$&quot;</code></code>, which is a space by default):</p>

<pre><code><code>    animals are: camel llama alpaca vicuna</code></code></pre>

<p>This is different than printing the array without the interpolation:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@animals</span> <span class="operator">=</span> <span class="string">qw(camel llama alpaca vicuna)</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"animals are: "</span><span class="operator">,</span> <span class="variable">@animals</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>Now the output doesn&#39;t have the spaces between the elements because the elements of <code><code>@animals</code></code> simply become part of the list to <code><code>print</code></code>:</p>

<pre><code><code>    animals are: camelllamaalpacavicuna</code></code></pre>

<p>You might notice this when each of the elements of <code><code>@array</code></code> end with a newline. You expect to print one element per line, but notice that every line after the first is indented:</p>

<pre><code><code>    this is a line
     this is another line
     this is the third line</code></code></pre>

<p>That extra space comes from the interpolation of the array. If you don&#39;t want to put anything between your array elements, don&#39;t use the array in double quotes. You can send it to print without them:</p>

<pre><code><code>    <span class="keyword">print</span> <span class="variable">@lines</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-do-I-traverse-a-directory-tree-">How do I traverse a directory tree?</h2>

<p>(contributed by brian d foy)</p>

<p>The <a href="../../lib/File/Find.html">File::Find</a> module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the <code><code>find</code></code> subroutine with a callback subroutine and the directories you want to traverse:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Find</span><span class="operator">;</span>
    
    <span class="variable">find</span><span class="operator">(</span> <span class="operator">\&amp;</span><span class="variable">wanted</span><span class="operator">,</span> <span class="variable">@directories</span> <span class="operator">);</span>
    
    <span class="keyword">sub</span><span class="variable"> wanted </span><span class="operator">{</span>
        <span class="comment"># full path in $File::Find::name</span>
        <span class="comment"># just filename in $_</span>
        <span class="operator">...</span> <span class="keyword">do</span> <span class="variable">whatever</span> <span class="variable">you</span> <span class="variable">want</span> <span class="variable">to</span> <span class="keyword">do</span> <span class="operator">...</span>
    <span class="operator">}</span>
</code></code></pre>

<p>The <a>File::Find::Closures</a>, which you can download from CPAN, provides many ready-to-use subroutines that you can use with <a href="../../lib/File/Find.html">File::Find</a>.</p>

<p>The <a>File::Finder</a>, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the <code><code>find</code></code> command-line utility:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Find</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">File::Finder</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$deep_dirs</span> <span class="operator">=</span> <span class="variable">File::Finder</span><span class="operator">-&gt;</span><span class="variable">depth</span><span class="operator">-&gt;</span><span class="variable">type</span><span class="operator">(</span><span class="string">'d'</span><span class="operator">)-&gt;</span><span class="variable">ls</span><span class="operator">-&gt;</span><span class="variable">exec</span><span class="operator">(</span><span class="string">'rmdir'</span><span class="operator">,</span><span class="string">'{}'</span><span class="operator">);</span>
    
    <span class="variable">find</span><span class="operator">(</span> <span class="variable">$deep_dirs</span><span class="operator">-&gt;</span><span class="variable">as_options</span><span class="operator">,</span> <span class="variable">@places</span> <span class="operator">);</span>
</code></code></pre>

<p>The <a>File::Find::Rule</a> module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Find::Rule</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">@files</span> <span class="operator">=</span> <span class="variable">File::Find::Rule</span><span class="operator">-&gt;</span><span class="variable">file</span><span class="operator">()</span>
                             <span class="operator">-&gt;</span><span class="variable">name</span><span class="operator">(</span> <span class="string">'*.pm'</span> <span class="operator">)</span>
                             <span class="operator">-&gt;</span><span class="variable">in</span><span class="operator">(</span> <span class="variable">@INC</span> <span class="operator">);</span>
</code></code></pre>

<h2 id="How-do-I-delete-a-directory-tree-">How do I delete a directory tree?</h2>

<p>(contributed by brian d foy)</p>

<p>If you have an empty directory, you can use Perl&#39;s built-in <code><code>rmdir</code></code>. If the directory is not empty (so, no files or subdirectories), you either have to empty it yourself (a lot of work) or use a module to help you.</p>

<p>The <a href="../../lib/File/Path.html">File::Path</a> module, which comes with Perl, has a <code><code>remove_tree</code></code> which can take care of all of the hard work for you:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">File::Path</span> <span class="string">qw(remove_tree)</span><span class="operator">;</span>
    
    <span class="variable">remove_tree</span><span class="operator">(</span> <span class="variable">@directories</span> <span class="operator">);</span>
</code></code></pre>

<p>The <a href="../../lib/File/Path.html">File::Path</a> module also has a legacy interface to the older <code><code>rmtree</code></code> subroutine.</p>

<h2 id="How-do-I-copy-an-entire-directory-">How do I copy an entire directory?</h2>

<p>(contributed by Shlomi Fish)</p>

<p>To do the equivalent of <code><code>cp -R</code></code> (i.e. copy an entire directory tree recursively) in portable Perl, you&#39;ll either need to write something yourself or find a good CPAN module such as <a>File::Copy::Recursive</a>.</p>

<h1 id="AUTHOR-AND-COPYRIGHT">AUTHOR AND COPYRIGHT</h1>

<p>Copyright (c) 1997-2010 Tom Christiansen, Nathan Torkington, and other authors as noted. All rights reserved.</p>

<p>This documentation is free; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>Irrespective of its distribution, all code examples here are in the public domain. You are permitted and encouraged to use this code and any derivatives thereof in your own programs for fun or for profit as you see fit. A simple comment in the code giving credit to the FAQ would be courteous but is not required.</p>


</body>

</html>


