<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../displayToc.js"></script>
<script language="JavaScript" src="../tocParas.js"></script>
<script language="JavaScript" src="../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../scineplex.css">
<title></title>
<link rel="stylesheet" href="../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Getting-documents-with-LWP::Simple">Getting documents with LWP::Simple</a></li>
      <li><a href="#The-Basics-of-the-LWP-Class-Model">The Basics of the LWP Class Model</a></li>
      <li><a href="#Adding-Other-HTTP-Request-Headers">Adding Other HTTP Request Headers</a></li>
      <li><a href="#Enabling-Cookies">Enabling Cookies</a></li>
      <li><a href="#Posting-Form-Data">Posting Form Data</a></li>
      <li><a href="#Sending-GET-Form-Data">Sending GET Form Data</a></li>
      <li><a href="#Absolutizing-URLs">Absolutizing URLs</a></li>
      <li><a href="#Other-Browser-Attributes">Other Browser Attributes</a></li>
      <li><a href="#Writing-Polite-Robots">Writing Polite Robots</a></li>
      <li><a href="#Using-Proxies">Using Proxies</a></li>
      <li><a href="#HTTP-Authentication">HTTP Authentication</a></li>
      <li><a href="#Accessing-HTTPS-URLs">Accessing HTTPS URLs</a></li>
      <li><a href="#Getting-Large-Documents">Getting Large Documents</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>lwptut -- An LWP Tutorial</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>LWP (short for &quot;Library for WWW in Perl&quot;) is a very popular group of Perl modules for accessing data on the Web. Like most Perl module-distributions, each of LWP&#39;s component modules comes with documentation that is a complete reference to its interface. However, there are so many modules in LWP that it&#39;s hard to know where to start looking for information on how to do even the simplest most common things.</p>

<p>Really introducing you to using LWP would require a whole book -- a book that just happens to exist, called <i>Perl &amp; LWP</i>. But this article should give you a taste of how you can go about some common tasks with LWP.</p>

<h2 id="Getting-documents-with-LWP::Simple">Getting documents with LWP::Simple</h2>

<p>If you just want to get what&#39;s at a particular URL, the simplest way to do it is LWP::Simple&#39;s functions.</p>

<p>In a Perl program, you can call its <code><code>get($url)</code></code> function. It will try getting that URL&#39;s content. If it works, then it&#39;ll return the content; but if there&#39;s some error, it&#39;ll return undef.</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="string">'http://www.npr.org/programs/fa/?todayDate=current'</span><span class="operator">;</span>
    <span class="comment"># Just an example: the URL for the most recent /Fresh Air/ show</span>
  
  <span class="keyword">use</span> <span class="variable">LWP::Simple</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$content</span> <span class="operator">=</span> <span class="variable">get</span> <span class="variable">$url</span><span class="operator">;</span>
  <span class="keyword">die</span> <span class="string">"Couldn't get </span><span class="variable">$url</span><span class="string">"</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$content</span><span class="operator">;</span>
  
  <span class="comment"># Then go do things with $content, like this:</span>
  
  <span class="keyword">if</span><span class="operator">(</span><span class="variable">$content</span> <span class="operator">=~</span> <span class="regex">m/jazz/i</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"They're talking about jazz today on Fresh Air!\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">else</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Fresh Air is apparently jazzless today.\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The handiest variant on <code><code>get</code></code> is <code><code>getprint</code></code>, which is useful in Perl one-liners. If it can get the page whose URL you provide, it sends it to STDOUT; otherwise it complains to STDERR.</p>

<pre><code><code>  % perl -MLWP::Simple -e &quot;getprint &#39;http://www.cpan.org/RECENT&#39;&quot;</code></code></pre>

<p>That is the URL of a plain text file that lists new files in CPAN in the past two weeks. You can easily make it part of a tidy little shell command, like this one that mails you the list of new <code><code>Acme::</code></code> modules:</p>

<pre><code><code>  % perl -MLWP::Simple -e &quot;getprint &#39;http://www.cpan.org/RECENT&#39;&quot;  \
     | grep &quot;/by-module/Acme&quot; | mail -s &quot;New Acme modules! Joy!&quot; $USER</code></code></pre>

<p>There are other useful functions in LWP::Simple, including one function for running a HEAD request on a URL (useful for checking links, or getting the last-revised time of a URL), and two functions for saving/mirroring a URL to a local file. See <a href="../lib/LWP/Simple.html">the LWP::Simple documentation</a> for the full details, or chapter 2 of <i>Perl &amp; LWP</i> for more examples.</p>

<h2 id="The-Basics-of-the-LWP-Class-Model">The Basics of the LWP Class Model</h2>

<p>LWP::Simple&#39;s functions are handy for simple cases, but its functions don&#39;t support cookies or authorization, don&#39;t support setting header lines in the HTTP request, generally don&#39;t support reading header lines in the HTTP response (notably the full HTTP error message, in case of an error). To get at all those features, you&#39;ll have to use the full LWP class model.</p>

<p>While LWP consists of dozens of classes, the main two that you have to understand are <a href="../lib/LWP/UserAgent.html">LWP::UserAgent</a> and <a href="../lib/HTTP/Response.html">HTTP::Response</a>. LWP::UserAgent is a class for &quot;virtual browsers&quot; which you use for performing requests, and <a href="../lib/HTTP/Response.html">HTTP::Response</a> is a class for the responses (or error messages) that you get back from those requests.</p>

<p>The basic idiom is <code><code>$response = $browser-&gt;get($url)</code></code>, or more fully illustrated:</p>

<pre><code><code>  <span class="comment"># Early in your program:</span>
  
  <span class="keyword">use</span> <span class="variable">LWP</span> <span class="number">5.64</span><span class="operator">;</span> <span class="comment"># Loads all important LWP classes, and makes</span>
                <span class="comment">#  sure your version is reasonably recent.</span>
  
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  <span class="operator">...</span>
  
  <span class="comment"># Then later, whenever you need to make a get request:</span>
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="string">'http://www.npr.org/programs/fa/?todayDate=current'</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span> <span class="variable">$url</span> <span class="operator">);</span>
  <span class="keyword">die</span> <span class="string">"Can't get </span><span class="variable">$url</span><span class="string"> -- "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
  
  <span class="keyword">die</span> <span class="string">"Hey, I was expecting HTML, not "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">content_type</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">content_type</span> <span class="keyword">eq</span> <span class="string">'text/html'</span><span class="operator">;</span>
     <span class="comment"># or whatever content-type you're equipped to deal with</span>
  
  <span class="comment"># Otherwise, process the content somehow:</span>
  
  <span class="keyword">if</span><span class="operator">(</span><span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">decoded_content</span> <span class="operator">=~</span> <span class="regex">m/jazz/i</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"They're talking about jazz today on Fresh Air!\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">else</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Fresh Air is apparently jazzless today.\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>There are two objects involved: <code><code>$browser</code></code>, which holds an object of class LWP::UserAgent, and then the <code><code>$response</code></code> object, which is of class HTTP::Response. You really need only one browser object per program; but every time you make a request, you get back a new HTTP::Response object, which will have some interesting attributes:</p>

<ul>

<li><p>A status code indicating success or failure (which you can test with <code><code>$response-&gt;is_success</code></code>).</p>

</li>
<li><p>An HTTP status line that is hopefully informative if there&#39;s failure (which you can see with <code><code>$response-&gt;status_line</code></code>, returning something like &quot;404 Not Found&quot;).</p>

</li>
<li><p>A MIME content-type like &quot;text/html&quot;, &quot;image/gif&quot;, &quot;application/xml&quot;, etc., which you can see with <code><code>$response-&gt;content_type</code></code></p>

</li>
<li><p>The actual content of the response, in <code><code>$response-&gt;decoded_content</code></code>. If the response is HTML, that&#39;s where the HTML source will be; if it&#39;s a GIF, then <code><code>$response-&gt;decoded_content</code></code> will be the binary GIF data.</p>

</li>
<li><p>And dozens of other convenient and more specific methods that are documented in the docs for <a href="../lib/HTTP/Response.html">HTTP::Response</a>, and its superclasses <a href="../lib/HTTP/Message.html">HTTP::Message</a> and <a href="../lib/HTTP/Headers.html">HTTP::Headers</a>.</p>

</li>
</ul>

<h2 id="Adding-Other-HTTP-Request-Headers">Adding Other HTTP Request Headers</h2>

<p>The most commonly used syntax for requests is <code><code>$response = $browser-&gt;get($url)</code></code>, but in truth, you can add extra HTTP header lines to the request by adding a list of key-value pairs after the URL, like so:</p>

<pre><code><code>  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span> <span class="variable">$url</span><span class="operator">,</span> <span class="variable">$key1</span><span class="operator">,</span> <span class="variable">$value1</span><span class="operator">,</span> <span class="variable">$key2</span><span class="operator">,</span> <span class="variable">$value2</span><span class="operator">,</span> <span class="operator">...</span> <span class="operator">);</span>
</code></code></pre>

<p>For example, here&#39;s how to send some more Netscape-like headers, in case you&#39;re dealing with a site that would otherwise reject your request:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">@ns_headers</span> <span class="operator">=</span> <span class="operator">(</span>
   <span class="string">'User-Agent'</span> <span class="operator">=&gt;</span> <span class="string">'Mozilla/4.76 [en] (Win98; U)'</span><span class="operator">,</span>
   <span class="string">'Accept'</span> <span class="operator">=&gt;</span> <span class="string">'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*'</span><span class="operator">,</span>
   <span class="string">'Accept-Charset'</span> <span class="operator">=&gt;</span> <span class="string">'iso-8859-1,*,utf-8'</span><span class="operator">,</span>
   <span class="string">'Accept-Language'</span> <span class="operator">=&gt;</span> <span class="string">'en-US'</span><span class="operator">,</span>
  <span class="operator">);</span>
  
  <span class="operator">...</span>
  
  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">,</span> <span class="variable">@ns_headers</span><span class="operator">);</span>
</code></code></pre>

<p>If you weren&#39;t reusing that array, you could just go ahead and do this:</p>

<pre><code><code>  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">,</span>
   <span class="string">'User-Agent'</span> <span class="operator">=&gt;</span> <span class="string">'Mozilla/4.76 [en] (Win98; U)'</span><span class="operator">,</span>
   <span class="string">'Accept'</span> <span class="operator">=&gt;</span> <span class="string">'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, image/png, */*'</span><span class="operator">,</span>
   <span class="string">'Accept-Charset'</span> <span class="operator">=&gt;</span> <span class="string">'iso-8859-1,*,utf-8'</span><span class="operator">,</span>
   <span class="string">'Accept-Language'</span> <span class="operator">=&gt;</span> <span class="string">'en-US'</span><span class="operator">,</span>
  <span class="operator">);</span>
</code></code></pre>

<p>If you were only ever changing the &#39;User-Agent&#39; line, you could just change the <code><code>$browser</code></code> object&#39;s default line from &quot;libwww-perl/5.65&quot; (or the like) to whatever you like, using the LWP::UserAgent <code><code>agent</code></code> method:</p>

<pre><code><code>   <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">agent</span><span class="operator">(</span><span class="string">'Mozilla/4.76 [en] (Win98; U)'</span><span class="operator">);</span>
</code></code></pre>

<h2 id="Enabling-Cookies">Enabling Cookies</h2>

<p>A default LWP::UserAgent object acts like a browser with its cookies support turned off. There are various ways of turning it on, by setting its <code><code>cookie_jar</code></code> attribute. A &quot;cookie jar&quot; is an object representing a little database of all the HTTP cookies that a browser can know about. It can correspond to a file on disk (the way Netscape uses its <i>cookies.txt</i> file), or it can be just an in-memory object that starts out empty, and whose collection of cookies will disappear once the program is finished running.</p>

<p>To give a browser an in-memory empty cookie jar, you set its <code><code>cookie_jar</code></code> attribute like so:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">cookie_jar</span><span class="operator">(</span><span class="operator">{}</span><span class="operator">);</span>
</code></code></pre>

<p>To give it a copy that will be read from a file on disk, and will be saved to it when the program is finished running, set the <code><code>cookie_jar</code></code> attribute like this:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">HTTP::Cookies</span><span class="operator">;</span>
  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">cookie_jar</span><span class="operator">(</span> <span class="variable">HTTP::Cookies</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span>
    <span class="string">'file'</span> <span class="operator">=&gt;</span> <span class="string">'/some/where/cookies.lwp'</span><span class="operator">,</span>
        <span class="comment"># where to read/write cookies</span>
    <span class="string">'autosave'</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
        <span class="comment"># save it to disk when done</span>
  <span class="operator">));</span>
</code></code></pre>

<p>That file will be an LWP-specific format. If you want to be access the cookies in your Netscape cookies file, you can use the HTTP::Cookies::Netscape class:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">HTTP::Cookies</span><span class="operator">;</span>
    <span class="comment"># yes, loads HTTP::Cookies::Netscape too</span>
  
  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">cookie_jar</span><span class="operator">(</span> <span class="variable">HTTP::Cookies::Netscape</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span>
    <span class="string">'file'</span> <span class="operator">=&gt;</span> <span class="string">'c:/Program Files/Netscape/Users/DIR-NAME-HERE/cookies.txt'</span><span class="operator">,</span>
        <span class="comment"># where to read cookies</span>
  <span class="operator">));</span>
</code></code></pre>

<p>You could add an <code><code>&#39;autosave&#39; =&gt; 1</code></code> line as further above, but at time of writing, it&#39;s uncertain whether Netscape might discard some of the cookies you could be writing back to disk.</p>

<h2 id="Posting-Form-Data">Posting Form Data</h2>

<p>Many HTML forms send data to their server using an HTTP POST request, which you can send with this syntax:</p>

<pre><code><code> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">post</span><span class="operator">(</span> <span class="variable">$url</span><span class="operator">,</span>
   <span class="operator">[</span>
     <span class="string">formkey1</span> <span class="operator">=&gt;</span> <span class="variable">value1</span><span class="operator">,</span> 
     <span class="string">formkey2</span> <span class="operator">=&gt;</span> <span class="variable">value2</span><span class="operator">,</span> 
     <span class="operator">...</span>
   <span class="operator">]</span><span class="operator">,</span>
 <span class="operator">);</span>
</code></code></pre>

<p>Or if you need to send HTTP headers:</p>

<pre><code><code> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">post</span><span class="operator">(</span> <span class="variable">$url</span><span class="operator">,</span>
   <span class="operator">[</span>
     <span class="string">formkey1</span> <span class="operator">=&gt;</span> <span class="variable">value1</span><span class="operator">,</span> 
     <span class="string">formkey2</span> <span class="operator">=&gt;</span> <span class="variable">value2</span><span class="operator">,</span> 
     <span class="operator">...</span>
   <span class="operator">]</span><span class="operator">,</span>
   <span class="string">headerkey1</span> <span class="operator">=&gt;</span> <span class="variable">value1</span><span class="operator">,</span> 
   <span class="string">headerkey2</span> <span class="operator">=&gt;</span> <span class="variable">value2</span><span class="operator">,</span> 
 <span class="operator">);</span>
</code></code></pre>

<p>For example, the following program makes a search request to AltaVista (by sending some form data via an HTTP POST request), and extracts from the HTML the report of the number of matches:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">LWP</span> <span class="number">5.64</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$word</span> <span class="operator">=</span> <span class="string">'tarragon'</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="string">'http://search.yahoo.com/yhs/search'</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">post</span><span class="operator">(</span> <span class="variable">$url</span><span class="operator">,</span>
    <span class="operator">[</span> <span class="string">'q'</span> <span class="operator">=&gt;</span> <span class="variable">$word</span><span class="operator">,</span>  <span class="comment"># the Altavista query string</span>
      <span class="string">'fr'</span> <span class="operator">=&gt;</span> <span class="string">'altavista'</span><span class="operator">,</span> <span class="string">'pg'</span> <span class="operator">=&gt;</span> <span class="string">'q'</span><span class="operator">,</span> <span class="string">'avkw'</span> <span class="operator">=&gt;</span> <span class="string">'tgz'</span><span class="operator">,</span> <span class="string">'kl'</span> <span class="operator">=&gt;</span> <span class="string">'XX'</span><span class="operator">,</span>
    <span class="operator">]</span>
  <span class="operator">);</span>
  <span class="keyword">die</span> <span class="string">"</span><span class="variable">$url</span><span class="string"> error: "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
  <span class="keyword">die</span> <span class="string">"Weird content type at </span><span class="variable">$url</span><span class="string"> -- "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">content_type</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">content_is_html</span><span class="operator">;</span>
  
  <span class="keyword">if</span><span class="operator">(</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">decoded_content</span> <span class="operator">=~</span> <span class="regex">m{([0-9,]+)(?:&lt;.*?&gt;)? results for}</span> <span class="operator">)</span> <span class="operator">{</span>
    <span class="comment"># The substring will be like "996,000&lt;/strong&gt; results for"</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$word</span><span class="string">: </span><span class="variable">$1</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">else</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Couldn't find the match-string in the response\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h2 id="Sending-GET-Form-Data">Sending GET Form Data</h2>

<p>Some HTML forms convey their form data not by sending the data in an HTTP POST request, but by making a normal GET request with the data stuck on the end of the URL. For example, if you went to <code><code>www.imdb.com</code></code> and ran a search on &quot;Blade Runner&quot;, the URL you&#39;d see in your browser window would be:</p>

<pre><code><code>  http://www.imdb.com/find?s=all&amp;q=Blade+Runner</code></code></pre>

<p>To run the same search with LWP, you&#39;d use this idiom, which involves the URI class:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">URI</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="variable">URI</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">'http://www.imdb.com/find'</span> <span class="operator">);</span>
    <span class="comment"># makes an object representing the URL</span>
  
  <span class="variable">$url</span><span class="operator">-&gt;</span><span class="variable">query_form</span><span class="operator">(</span>  <span class="comment"># And here the form data pairs:</span>
    <span class="string">'q'</span> <span class="operator">=&gt;</span> <span class="string">'Blade Runner'</span><span class="operator">,</span>
    <span class="string">'s'</span> <span class="operator">=&gt;</span> <span class="string">'all'</span><span class="operator">,</span>
  <span class="operator">);</span>
  
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">);</span>
</code></code></pre>

<p>See chapter 5 of <i>Perl &amp; LWP</i> for a longer discussion of HTML forms and of form data, and chapters 6 through 9 for a longer discussion of extracting data from HTML.</p>

<h2 id="Absolutizing-URLs">Absolutizing URLs</h2>

<p>The URI class that we just mentioned above provides all sorts of methods for accessing and modifying parts of URLs (such as asking sort of URL it is with <code><code>$url-&gt;scheme</code></code>, and asking what host it refers to with <code><code>$url-&gt;host</code></code>, and so on, as described in <a href="../lib/URI.html">the docs for the URI class</a>. However, the methods of most immediate interest are the <code><code>query_form</code></code> method seen above, and now the <code><code>new_abs</code></code> method for taking a probably-relative URL string (like &quot;../foo.html&quot;) and getting back an absolute URL (like &quot;http://www.perl.com/stuff/foo.html&quot;), as shown here:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">URI</span><span class="operator">;</span>
  <span class="variable">$abs</span> <span class="operator">=</span> <span class="variable">URI</span><span class="operator">-&gt;</span><span class="variable">new_abs</span><span class="operator">(</span><span class="variable">$maybe_relative</span><span class="operator">,</span> <span class="variable">$base</span><span class="operator">);</span>
</code></code></pre>

<p>For example, consider this program that matches URLs in the HTML list of new modules in CPAN:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">LWP</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="string">'http://www.cpan.org/RECENT.html'</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">);</span>
  <span class="keyword">die</span> <span class="string">"Can't get </span><span class="variable">$url</span><span class="string"> -- "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$html</span> <span class="operator">=</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">decoded_content</span><span class="operator">;</span>
  <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$html</span> <span class="operator">=~</span> <span class="regex">m/&lt;A HREF=\"(.*?)\"/g</span> <span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$1</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>When run, it emits output that starts out something like this:</p>

<pre><code><code>  MIRRORING.FROM
  RECENT
  RECENT.html
  authors/00whois.html
  authors/01mailrc.txt.gz
  authors/id/A/AA/AASSAD/CHECKSUMS
  ...</code></code></pre>

<p>However, if you actually want to have those be absolute URLs, you can use the URI module&#39;s <code><code>new_abs</code></code> method, by changing the <code><code>while</code></code> loop to this:</p>

<pre><code><code>  <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$html</span> <span class="operator">=~</span> <span class="regex">m/&lt;A HREF=\"(.*?)\"/g</span> <span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="variable">URI</span><span class="operator">-&gt;</span><span class="variable">new_abs</span><span class="operator">(</span> <span class="variable">$1</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">base</span> <span class="operator">)</span> <span class="operator">,</span><span class="string">"\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>(The <code><code>$response-&gt;base</code></code> method from <a href="../lib/HTTP/Message.html">HTTP::Message</a> is for returning what URL should be used for resolving relative URLs -- it&#39;s usually just the same as the URL that you requested.)</p>

<p>That program then emits nicely absolute URLs:</p>

<pre><code><code>  http://www.cpan.org/MIRRORING.FROM
  http://www.cpan.org/RECENT
  http://www.cpan.org/RECENT.html
  http://www.cpan.org/authors/00whois.html
  http://www.cpan.org/authors/01mailrc.txt.gz
  http://www.cpan.org/authors/id/A/AA/AASSAD/CHECKSUMS
  ...</code></code></pre>

<p>See chapter 4 of <i>Perl &amp; LWP</i> for a longer discussion of URI objects.</p>

<p>Of course, using a regexp to match hrefs is a bit simplistic, and for more robust programs, you&#39;ll probably want to use an HTML-parsing module like <a href="../lib/HTML/LinkExtor.html">HTML::LinkExtor</a> or <a href="../lib/HTML/TokeParser.html">HTML::TokeParser</a> or even maybe <a href="../lib/HTML/TreeBuilder.html">HTML::TreeBuilder</a>.</p>

<h2 id="Other-Browser-Attributes">Other Browser Attributes</h2>

<p>LWP::UserAgent objects have many attributes for controlling how they work. Here are a few notable ones:</p>

<ul>

<li><p><code><code><span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">timeout</span><span class="operator">(</span><span class="number">15</span><span class="operator">);</span>
</code></code></p>

<p>This sets this browser object to give up on requests that don&#39;t answer within 15 seconds.</p>

</li>
<li><p><code><code><span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">protocols_allowed</span><span class="operator">(</span> <span class="operator">[</span> <span class="string">'http'</span><span class="operator">,</span> <span class="string">'gopher'</span><span class="operator">]</span> <span class="operator">);</span>
</code></code></p>

<p>This sets this browser object to not speak any protocols other than HTTP and gopher. If it tries accessing any other kind of URL (like an &quot;ftp:&quot; or &quot;mailto:&quot; or &quot;news:&quot; URL), then it won&#39;t actually try connecting, but instead will immediately return an error code 500, with a message like &quot;Access to &#39;ftp&#39; URIs has been disabled&quot;.</p>

</li>
<li><p><code><code><span class="keyword">use</span> <span class="variable">LWP::ConnCache</span><span class="operator">;</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">conn_cache</span><span class="operator">(</span><span class="variable">LWP::ConnCache</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">());</span>
</code></code></p>

<p>This tells the browser object to try using the HTTP/1.1 &quot;Keep-Alive&quot; feature, which speeds up requests by reusing the same socket connection for multiple requests to the same server.</p>

</li>
<li><p><code><code>$browser-&gt;agent( &#39;SomeName/1.23 (more info here maybe)&#39; )</code></code></p>

<p>This changes how the browser object will identify itself in the default &quot;User-Agent&quot; line is its HTTP requests. By default, it&#39;ll send &quot;libwww-perl/<i>versionnumber</i>&quot;, like &quot;libwww-perl/5.65&quot;. You can change that to something more descriptive like this:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">agent</span><span class="operator">(</span> <span class="string">'SomeName/3.14 (contact@robotplexus.int)'</span> <span class="operator">);</span>
</code></code></pre>

<p>Or if need be, you can go in disguise, like this:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">agent</span><span class="operator">(</span> <span class="string">'Mozilla/4.0 (compatible; MSIE 5.12; Mac_PowerPC)'</span> <span class="operator">);</span>
</code></code></pre>

</li>
<li><p><code><code><span class="keyword">push</span> <span class="variable">@</span><span class="operator">{</span> <span class="variable">$ua</span><span class="operator">-&gt;</span><span class="variable">requests_redirectable</span> <span class="operator">}</span><span class="operator">,</span> <span class="string">'POST'</span><span class="operator">;</span>
</code></code></p>

<p>This tells this browser to obey redirection responses to POST requests (like most modern interactive browsers), even though the HTTP RFC says that should not normally be done.</p>

</li>
</ul>

<p>For more options and information, see <a href="../lib/LWP/UserAgent.html">the full documentation for LWP::UserAgent</a>.</p>

<h2 id="Writing-Polite-Robots">Writing Polite Robots</h2>

<p>If you want to make sure that your LWP-based program respects <i>robots.txt</i> files and doesn&#39;t make too many requests too fast, you can use the LWP::RobotUA class instead of the LWP::UserAgent class.</p>

<p>LWP::RobotUA class is just like LWP::UserAgent, and you can use it like so:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">LWP::RobotUA</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::RobotUA</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">'YourSuperBot/1.34'</span><span class="operator">,</span> <span class="string">'you@yoursite.com'</span><span class="operator">);</span>
    <span class="comment"># Your bot's name and your email address</span>
  
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">);</span>
</code></code></pre>

<p>But HTTP::RobotUA adds these features:</p>

<ul>

<li><p>If the <i>robots.txt</i> on <code><code>$url</code></code>&#39;s server forbids you from accessing <code><code>$url</code></code>, then the <code><code>$browser</code></code> object (assuming it&#39;s of class LWP::RobotUA) won&#39;t actually request it, but instead will give you back (in <code><code>$response</code></code>) a 403 error with a message &quot;Forbidden by robots.txt&quot;. That is, if you have this line:</p>

<pre><code><code>  <span class="keyword">die</span> <span class="string">"</span><span class="variable">$url</span><span class="string"> -- "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span><span class="operator">,</span> <span class="string">"\nAborted"</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
</code></code></pre>

<p>then the program would die with an error message like this:</p>

<pre><code><code>  http://whatever.site.int/pith/x.html -- 403 Forbidden by robots.txt
  Aborted at whateverprogram.pl line 1234</code></code></pre>

</li>
<li><p>If this <code><code>$browser</code></code> object sees that the last time it talked to <code><code>$url</code></code>&#39;s server was too recently, then it will pause (via <code><code>sleep</code></code>) to avoid making too many requests too often. How long it will pause for, is by default one minute -- but you can control it with the <code><code>$browser-&gt;delay( </code><i><code>minutes</code></i><code> )</code></code> attribute.</p>

<p>For example, this code:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">delay</span><span class="operator">(</span> <span class="number">7</span><span class="operator">/</span><span class="number">60</span> <span class="operator">);</span>
</code></code></pre>

<p>...means that this browser will pause when it needs to avoid talking to any given server more than once every 7 seconds.</p>

</li>
</ul>

<p>For more options and information, see <a href="../lib/LWP/RobotUA.html">the full documentation for LWP::RobotUA</a>.</p>

<h2 id="Using-Proxies">Using Proxies</h2>

<p>In some cases, you will want to (or will have to) use proxies for accessing certain sites and/or using certain protocols. This is most commonly the case when your LWP program is running (or could be running) on a machine that is behind a firewall.</p>

<p>To make a browser object use proxies that are defined in the usual environment variables (<code><code>HTTP_PROXY</code></code>, etc.), just call the <code><code>env_proxy</code></code> on a user-agent object before you go making any requests on it. Specifically:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">LWP::UserAgent</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  <span class="comment"># And before you go making any requests:</span>
  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">env_proxy</span><span class="operator">;</span>
</code></code></pre>

<p>For more information on proxy parameters, see <a href="../lib/LWP/UserAgent.html">the LWP::UserAgent documentation</a>, specifically the <code><code>proxy</code></code>, <code><code>env_proxy</code></code>, and <code><code>no_proxy</code></code> methods.</p>

<h2 id="HTTP-Authentication">HTTP Authentication</h2>

<p>Many web sites restrict access to documents by using &quot;HTTP Authentication&quot;. This isn&#39;t just any form of &quot;enter your password&quot; restriction, but is a specific mechanism where the HTTP server sends the browser an HTTP code that says &quot;That document is part of a protected &#39;realm&#39;, and you can access it only if you re-request it and add some special authorization headers to your request&quot;.</p>

<p>For example, the Unicode.org admins stop email-harvesting bots from harvesting the contents of their mailing list archives, by protecting them with HTTP Authentication, and then publicly stating the username and password (at <code><code>http://www.unicode.org/mail-arch/</code></code>) -- namely username &quot;unicode-ml&quot; and password &quot;unicode&quot;.</p>

<p>For example, consider this URL, which is part of the protected area of the web site:</p>

<pre><code><code>  http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html</code></code></pre>

<p>If you access that with a browser, you&#39;ll get a prompt like &quot;Enter username and password for &#39;Unicode-MailList-Archives&#39; at server &#39;www.unicode.org&#39;&quot;.</p>

<p>In LWP, if you just request that URL, like this:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">LWP</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span>
   <span class="string">'http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html'</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">);</span>
  
  <span class="keyword">die</span> <span class="string">"Error: "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">header</span><span class="operator">(</span><span class="string">'WWW-Authenticate'</span><span class="operator">)</span> <span class="operator">||</span> <span class="string">'Error accessing'</span><span class="operator">,</span>
    <span class="comment">#  ('WWW-Authenticate' is the realm-name)</span>
    <span class="string">"\n "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span><span class="operator">,</span> <span class="string">"\n at </span><span class="variable">$url</span><span class="string">\n Aborting"</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
</code></code></pre>

<p>Then you&#39;ll get this error:</p>

<pre><code><code>  Error: Basic realm=&quot;Unicode-MailList-Archives&quot;
   401 Authorization Required
   at http://www.unicode.org/mail-arch/unicode-ml/y2002-m08/0067.html
   Aborting at auth1.pl line 9.  [or wherever]</code></code></pre>

<p>...because the <code><code>$browser</code></code> doesn&#39;t know any the username and password for that realm (&quot;Unicode-MailList-Archives&quot;) at that host (&quot;www.unicode.org&quot;). The simplest way to let the browser know about this is to use the <code><code>credentials</code></code> method to let it know about a username and password that it can try using for that realm at that host. The syntax is:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">credentials</span><span class="operator">(</span>
    <span class="string">'servername:portnumber'</span><span class="operator">,</span>
    <span class="string">'realm-name'</span><span class="operator">,</span>
   <span class="string">'username'</span> <span class="operator">=&gt;</span> <span class="string">'password'</span>
  <span class="operator">);</span>
</code></code></pre>

<p>In most cases, the port number is 80, the default TCP/IP port for HTTP; and you usually call the <code><code>credentials</code></code> method before you make any requests. For example:</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">credentials</span><span class="operator">(</span>
    <span class="string">'reports.mybazouki.com:80'</span><span class="operator">,</span>
    <span class="string">'web_server_usage_reports'</span><span class="operator">,</span>
    <span class="string">'plinky'</span> <span class="operator">=&gt;</span> <span class="string">'banjo123'</span>
  <span class="operator">);</span>
</code></code></pre>

<p>So if we add the following to the program above, right after the <code><code><span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
</code></code> line...</p>

<pre><code><code>  <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">credentials</span><span class="operator">(</span>  <span class="comment"># add this to our $browser 's "key ring"</span>
    <span class="string">'www.unicode.org:80'</span><span class="operator">,</span>
    <span class="string">'Unicode-MailList-Archives'</span><span class="operator">,</span>
    <span class="string">'unicode-ml'</span> <span class="operator">=&gt;</span> <span class="string">'unicode'</span>
  <span class="operator">);</span>
</code></code></pre>

<p>...then when we run it, the request succeeds, instead of causing the <code><code>die</code></code> to be called.</p>

<h2 id="Accessing-HTTPS-URLs">Accessing HTTPS URLs</h2>

<p>When you access an HTTPS URL, it&#39;ll work for you just like an HTTP URL would -- if your LWP installation has HTTPS support (via an appropriate Secure Sockets Layer library). For example:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">LWP</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$url</span> <span class="operator">=</span> <span class="string">'https://www.paypal.com/'</span><span class="operator">;</span>   <span class="comment"># Yes, HTTPS!</span>
  <span class="keyword">my</span> <span class="variable">$browser</span> <span class="operator">=</span> <span class="variable">LWP::UserAgent</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$browser</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">);</span>
  <span class="keyword">die</span> <span class="string">"Error at </span><span class="variable">$url</span><span class="string">\n "</span><span class="operator">,</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">status_line</span><span class="operator">,</span> <span class="string">"\n Aborting"</span>
   <span class="keyword">unless</span> <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">is_success</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"Whee, it worked!  I got that "</span><span class="operator">,</span>
   <span class="variable">$response</span><span class="operator">-&gt;</span><span class="variable">content_type</span><span class="operator">,</span> <span class="string">" document!\n"</span><span class="operator">;</span>
</code></code></pre>

<p>If your LWP installation doesn&#39;t have HTTPS support set up, then the response will be unsuccessful, and you&#39;ll get this error message:</p>

<pre><code><code>  Error at https://www.paypal.com/
   501 Protocol scheme &#39;https&#39; is not supported
   Aborting at paypal.pl line 7.   [or whatever program and line]</code></code></pre>

<p>If your LWP installation <i>does</i> have HTTPS support installed, then the response should be successful, and you should be able to consult <code><code>$response</code></code> just like with any normal HTTP response.</p>

<p>For information about installing HTTPS support for your LWP installation, see the helpful <i>README.SSL</i> file that comes in the libwww-perl distribution.</p>

<h2 id="Getting-Large-Documents">Getting Large Documents</h2>

<p>When you&#39;re requesting a large (or at least potentially large) document, a problem with the normal way of using the request methods (like <code><code>$response = $browser-&gt;get($url)</code></code>) is that the response object in memory will have to hold the whole document -- <i>in memory</i>. If the response is a thirty megabyte file, this is likely to be quite an imposition on this process&#39;s memory usage.</p>

<p>A notable alternative is to have LWP save the content to a file on disk, instead of saving it up in memory. This is the syntax to use:</p>

<pre><code><code>  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$ua</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">,</span>
                         <span class="string">':content_file'</span> <span class="operator">=&gt;</span> <span class="variable">$filespec</span><span class="operator">,</span>
                      <span class="operator">);</span>
</code></code></pre>

<p>For example,</p>

<pre><code><code>  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$ua</span><span class="operator">-&gt;</span><span class="variable">get</span><span class="operator">(</span><span class="string">'http://search.cpan.org/'</span><span class="operator">,</span>
                         <span class="string">':content_file'</span> <span class="operator">=&gt;</span> <span class="string">'/tmp/sco.html'</span>
                      <span class="operator">);</span>
</code></code></pre>

<p>When you use this <code><code>:content_file</code></code> option, the <code><code>$response</code></code> will have all the normal header lines, but <code><code>$response-&gt;content</code></code> will be empty.</p>

<p>Note that this &quot;:content_file&quot; option isn&#39;t supported under older versions of LWP, so you should consider adding <code><code><span class="keyword">use</span> <span class="variable">LWP</span> <span class="number">5.66</span><span class="operator">;</span>
</code></code> to check the LWP version, if you think your program might run on systems with older versions.</p>

<p>If you need to be compatible with older LWP versions, then use this syntax, which does the same thing:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">HTTP::Request::Common</span><span class="operator">;</span>
  <span class="variable">$response</span> <span class="operator">=</span> <span class="variable">$ua</span><span class="operator">-&gt;</span><span class="variable">request</span><span class="operator">(</span> <span class="variable">GET</span><span class="operator">(</span><span class="variable">$url</span><span class="operator">),</span> <span class="variable">$filespec</span> <span class="operator">);</span>
</code></code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>Remember, this article is just the most rudimentary introduction to LWP -- to learn more about LWP and LWP-related tasks, you really must read from the following:</p>

<ul>

<li><p><a href="../lib/LWP/Simple.html">LWP::Simple</a> -- simple functions for getting/heading/mirroring URLs</p>

</li>
<li><p><a href="../lib/LWP.html">LWP</a> -- overview of the libwww-perl modules</p>

</li>
<li><p><a href="../lib/LWP/UserAgent.html">LWP::UserAgent</a> -- the class for objects that represent &quot;virtual browsers&quot;</p>

</li>
<li><p><a href="../lib/HTTP/Response.html">HTTP::Response</a> -- the class for objects that represent the response to a LWP response, as in <code><code>$response = $browser-&gt;get(...)</code></code></p>

</li>
<li><p><a href="../lib/HTTP/Message.html">HTTP::Message</a> and <a href="../lib/HTTP/Headers.html">HTTP::Headers</a> -- classes that provide more methods to HTTP::Response.</p>

</li>
<li><p><a href="../lib/URI.html">URI</a> -- class for objects that represent absolute or relative URLs</p>

</li>
<li><p><a href="../lib/URI/Escape.html">URI::Escape</a> -- functions for URL-escaping and URL-unescaping strings (like turning &quot;this &amp; that&quot; to and from &quot;this%20%26%20that&quot;).</p>

</li>
<li><p><a href="../lib/HTML/Entities.html">HTML::Entities</a> -- functions for HTML-escaping and HTML-unescaping strings (like turning &quot;C. &amp; E. Bront&euml;&quot; to and from &quot;C. &amp;amp; E. Bront&amp;euml;&quot;)</p>

</li>
<li><p><a href="../lib/HTML/TokeParser.html">HTML::TokeParser</a> and <a href="../lib/HTML/TreeBuilder.html">HTML::TreeBuilder</a> -- classes for parsing HTML</p>

</li>
<li><p><a href="../lib/HTML/LinkExtor.html">HTML::LinkExtor</a> -- class for finding links in HTML documents</p>

</li>
<li><p>The book <i>Perl &amp; LWP</i> by Sean M. Burke. O&#39;Reilly &amp; Associates, 2002. ISBN: 0-596-00178-9, <a href="http://oreilly.com/catalog/perllwp/">http://oreilly.com/catalog/perllwp/</a>. The whole book is also available free online: <a href="http://lwp.interglacial.com">http://lwp.interglacial.com</a>.</p>

</li>
</ul>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2002, Sean M. Burke. You can redistribute this document and/or modify it, but only under the same terms as Perl itself.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Sean M. Burke <code><code>sburke@cpan.org</code></code></p>


</body>

</html>


