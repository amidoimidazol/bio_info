<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Notes-for-users-of-Compress::Zlib-version-1">Notes for users of Compress::Zlib version 1</a></li>
    </ul>
  </li>
  <li><a href="#GZIP-INTERFACE">GZIP INTERFACE</a>
    <ul>
      <li><a href="#Examples">Examples</a></li>
      <li><a href="#Compress::Zlib::memGzip">Compress::Zlib::memGzip</a></li>
      <li><a href="#Compress::Zlib::memGunzip">Compress::Zlib::memGunzip</a></li>
    </ul>
  </li>
  <li><a href="#COMPRESS-UNCOMPRESS">COMPRESS/UNCOMPRESS</a></li>
  <li><a href="#Deflate-Interface">Deflate Interface</a>
    <ul>
      <li><a href="#d-status-deflateInit-OPT-">($d, $status) = deflateInit( [OPT] )</a></li>
      <li><a href="#out-status-d-deflate-buffer-">($out, $status) = $d-&gt;deflate($buffer)</a></li>
      <li><a href="#out-status-d-flush-head2-out-status-d-flush-flush_type-">($out, $status) = $d-&gt;flush() =head2 ($out, $status) = $d-&gt;flush($flush_type)</a></li>
      <li><a href="#status-d-deflateParams-OPT-">$status = $d-&gt;deflateParams([OPT])</a></li>
      <li><a href="#d-dict_adler-">$d-&gt;dict_adler()</a></li>
      <li><a href="#d-msg-">$d-&gt;msg()</a></li>
      <li><a href="#d-total_in-">$d-&gt;total_in()</a></li>
      <li><a href="#d-total_out-">$d-&gt;total_out()</a></li>
      <li><a href="#Example">Example</a></li>
    </ul>
  </li>
  <li><a href="#Inflate-Interface">Inflate Interface</a>
    <ul>
      <li><a href="#i-status-inflateInit-">($i, $status) = inflateInit()</a></li>
      <li><a href="#out-status-i-inflate-buffer-">($out, $status) = $i-&gt;inflate($buffer)</a></li>
      <li><a href="#status-i-inflateSync-buffer-">$status = $i-&gt;inflateSync($buffer)</a></li>
      <li><a href="#i-dict_adler-">$i-&gt;dict_adler()</a></li>
      <li><a href="#i-msg-">$i-&gt;msg()</a></li>
      <li><a href="#i-total_in-">$i-&gt;total_in()</a></li>
      <li><a href="#i-total_out-">$i-&gt;total_out()</a></li>
      <li><a href="#Example1">Example</a></li>
    </ul>
  </li>
  <li><a href="#CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</a></li>
  <li><a href="#Misc">Misc</a>
    <ul>
      <li><a href="#my-version-Compress::Zlib::zlib_version-">my $version = Compress::Zlib::zlib_version();</a></li>
    </ul>
  </li>
  <li><a href="#CONSTANTS">CONSTANTS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#MODIFICATION-HISTORY">MODIFICATION HISTORY</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Compress::Zlib - Interface to zlib compression library</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="operator">(</span><span class="variable">$d</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">deflateInit</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">OPT</span><span class="operator">]</span> <span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">deflate</span><span class="operator">(</span><span class="variable">$input</span><span class="operator">,</span> <span class="variable">$output</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">flush</span><span class="operator">(</span><span class="operator">[</span><span class="variable">$flush_type</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">deflateParams</span><span class="operator">(</span><span class="variable">OPTS</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">deflateTune</span><span class="operator">(</span><span class="variable">OPTS</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">dict_adler</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">crc32</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">adler32</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">total_in</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">total_out</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">msg</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">get_Strategy</span><span class="operator">();</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">get_Level</span><span class="operator">();</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">get_BufSize</span><span class="operator">();</span>
    
    <span class="operator">(</span><span class="variable">$i</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">inflateInit</span><span class="operator">(</span> <span class="operator">[</span><span class="variable">OPT</span><span class="operator">]</span> <span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">inflate</span><span class="operator">(</span><span class="variable">$input</span><span class="operator">,</span> <span class="variable">$output</span> <span class="operator">[</span><span class="operator">,</span> <span class="variable">$eof</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">inflateSync</span><span class="operator">(</span><span class="variable">$input</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">dict_adler</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">crc32</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">adler32</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">total_in</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">total_out</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$i</span><span class="operator">-&gt;</span><span class="variable">msg</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$d</span><span class="operator">-&gt;</span><span class="variable">get_BufSize</span><span class="operator">();</span>
    
    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">compress</span><span class="operator">(</span><span class="variable">$source</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">uncompress</span><span class="operator">(</span><span class="variable">$source</span><span class="operator">)</span> <span class="operator">;</span>
    
    <span class="variable">$gz</span> <span class="operator">=</span> <span class="variable">gzopen</span><span class="operator">(</span><span class="variable">$filename</span> <span class="keyword">or</span> <span class="variable">filehandle</span><span class="operator">,</span> <span class="variable">$mode</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$bytesread</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzread</span><span class="operator">(</span><span class="variable">$buffer</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$size</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$bytesread</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzreadline</span><span class="operator">(</span><span class="variable">$line</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$byteswritten</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzwrite</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzflush</span><span class="operator">(</span><span class="variable">$flush</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$offset</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gztell</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzseek</span><span class="operator">(</span><span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$whence</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzclose</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzeof</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="variable">$status</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzsetparams</span><span class="operator">(</span><span class="variable">$level</span><span class="operator">,</span> <span class="variable">$strategy</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$errstring</span> <span class="operator">=</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzerror</span><span class="operator">()</span> <span class="operator">;</span> 
    <span class="variable">$gzerrno</span>
    
    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">Compress::Zlib::memGzip</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">Compress::Zlib::memGunzip</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> <span class="operator">;</span>
    
    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">adler32</span><span class="operator">(</span><span class="variable">$buffer</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$crc</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">crc32</span><span class="operator">(</span><span class="variable">$buffer</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$crc</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    
    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">adler32_combine</span><span class="operator">(</span><span class="variable">$crc1</span><span class="operator">,</span> <span class="variable">$crc2</span><span class="operator">,</span> <span class="variable">$len2</span><span class="operator">)</span><span class="variable">l</span>
    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">crc32_combine</span><span class="operator">(</span><span class="variable">$adler1</span><span class="operator">,</span> <span class="variable">$adler2</span><span class="operator">,</span> <span class="variable">$len2</span><span class="operator">)</span>
    
    <span class="keyword">my</span> <span class="variable">$version</span> <span class="operator">=</span> <span class="variable">Compress::Raw::Zlib::zlib_version</span><span class="operator">();</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <i>Compress::Zlib</i> module provides a Perl interface to the <i>zlib</i> compression library (see <a href="#AUTHOR">&quot;AUTHOR&quot;</a> for details about where to get <i>zlib</i>).</p>

<p>The <code><code>Compress::Zlib</code></code> module can be split into two general areas of functionality, namely a simple read/write interface to <i>gzip</i> files and a low-level in-memory compression/decompression interface.</p>

<p>Each of these areas will be discussed in the following sections.</p>

<h2 id="Notes-for-users-of-Compress::Zlib-version-1">Notes for users of Compress::Zlib version 1</h2>

<p>The main change in <code><code>Compress::Zlib</code></code> version 2.x is that it does not now interface directly to the zlib library. Instead it uses the <code><code>IO::Compress::Gzip</code></code> and <code><code>IO::Uncompress::Gunzip</code></code> modules for reading/writing gzip files, and the <code><code>Compress::Raw::Zlib</code></code> module for some low-level zlib access.</p>

<p>The interface provided by version 2 of this module should be 100% backward compatible with version 1. If you find a difference in the expected behaviour please contact the author (See <a href="#AUTHOR">&quot;AUTHOR&quot;</a>). See <a href="#GZIP-INTERFACE">&quot;GZIP INTERFACE&quot;</a></p>

<p>With the creation of the <code><code>IO::Compress</code></code> and <code><code>IO::Uncompress</code></code> modules no new features are planned for <code><code>Compress::Zlib</code></code> - the new modules do everything that <code><code>Compress::Zlib</code></code> does and then some. Development on <code><code>Compress::Zlib</code></code> will be limited to bug fixes only.</p>

<p>If you are writing new code, your first port of call should be one of the new <code><code>IO::Compress</code></code> or <code><code>IO::Uncompress</code></code> modules.</p>

<h1 id="GZIP-INTERFACE">GZIP INTERFACE</h1>

<p>A number of functions are supplied in <i>zlib</i> for reading and writing <i>gzip</i> files that conform to RFC 1952. This module provides an interface to most of them.</p>

<p>If you have previously used <code><code>Compress::Zlib</code></code> 1.x, the following enhancements/changes have been made to the <code><code>gzopen</code></code> interface:</p>

<ol>

<li><p>If you want to open either STDIN or STDOUT with <code><code>gzopen</code></code>, you can now optionally use the special filename &quot;<code><code>-</code></code>&quot; as a synonym for <code><code>\*STDIN</code></code> and <code><code>\*STDOUT</code></code>.</p>

</li>
<li><p>In <code><code>Compress::Zlib</code></code> version 1.x, <code><code>gzopen</code></code> used the zlib library to open the underlying file. This made things especially tricky when a Perl filehandle was passed to <code><code>gzopen</code></code>. Behind the scenes the numeric C file descriptor had to be extracted from the Perl filehandle and this passed to the zlib library.</p>

<p>Apart from being non-portable to some operating systems, this made it difficult to use <code><code>gzopen</code></code> in situations where you wanted to extract/create a gzip data stream that is embedded in a larger file, without having to resort to opening and closing the file multiple times.</p>

<p>It also made it impossible to pass a perl filehandle that wasn&#39;t associated with a real filesystem file, like, say, an <code><code>IO::String</code></code>.</p>

<p>In <code><code>Compress::Zlib</code></code> version 2.x, the <code><code>gzopen</code></code> interface has been completely rewritten to use the <a href="../../lib/IO/Compress/Gzip.html">IO::Compress::Gzip</a> for writing gzip files and <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a> for reading gzip files. None of the limitations mentioned above apply.</p>

</li>
<li><p>Addition of <code><code>gzseek</code></code> to provide a restricted <code><code>seek</code></code> interface.</p>

</li>
<li><p>Added <code><code>gztell</code></code>.</p>

</li>
</ol>

<p>A more complete and flexible interface for reading/writing gzip files/buffers is included with the module <code><code>IO-Compress-Zlib</code></code>. See <a href="../../lib/IO/Compress/Gzip.html">IO::Compress::Gzip</a> and <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a> for more details.</p>

<dl>

<dt id="gz-gzopen-filename-mode-"><b>$gz = gzopen($filename, $mode)</b></dt>
<dd>

</dd>
<dt id="gz-gzopen-filehandle-mode-"><b>$gz = gzopen($filehandle, $mode)</b></dt>
<dd>

<p>This function opens either the <i>gzip</i> file <code><code>$filename</code></code> for reading or writing or attaches to the opened filehandle, <code><code>$filehandle</code></code>. It returns an object on success and <code><code>undef</code></code> on failure.</p>

<p>When writing a gzip file this interface will <i>always</i> create the smallest possible gzip header (exactly 10 bytes). If you want greater control over what gets stored in the gzip header (like the original filename or a comment) use <a href="../../lib/IO/Compress/Gzip.html">IO::Compress::Gzip</a> instead. Similarly if you want to read the contents of the gzip header use <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a>.</p>

<p>The second parameter, <code><code>$mode</code></code>, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the <code><code>$mode</code></code> parameter is similar to the mode parameter to the &#39;C&#39; function <code><code>fopen</code></code>, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</p>

<p>To specify a compression level when writing, append a digit between 0 and 9 to the mode string -- 0 means no compression and 9 means maximum compression. If no compression level is specified Z_DEFAULT_COMPRESSION is used.</p>

<p>To specify the compression strategy when writing, append &#39;f&#39; for filtered data, &#39;h&#39; for Huffman only compression, or &#39;R&#39; for run-length encoding. If no strategy is specified Z_DEFAULT_STRATEGY is used.</p>

<p>So, for example, &quot;wb9&quot; means open for writing with the maximum compression using the default strategy and &quot;wb4R&quot; means open for writing with compression level 4 and run-length encoding.</p>

<p>Refer to the <i>zlib</i> documentation for the exact format of the <code><code>$mode</code></code> parameter.</p>

</dd>
<dt id="bytesread-gz-gzread-buffer-size-"><b>$bytesread = $gz-&gt;gzread($buffer [, $size]) ;</b></dt>
<dd>

<p>Reads <code><code>$size</code></code> bytes from the compressed file into <code><code>$buffer</code></code>. If <code><code>$size</code></code> is not specified, it will default to 4096. If the scalar <code><code>$buffer</code></code> is not large enough, it will be extended automatically.</p>

<p>Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.</p>

</dd>
<dt id="bytesread-gz-gzreadline-line-"><b>$bytesread = $gz-&gt;gzreadline($line) ;</b></dt>
<dd>

<p>Reads the next line from the compressed file into <code><code>$line</code></code>.</p>

<p>Returns the number of bytes actually read. On EOF it returns 0 and in the case of an error, -1.</p>

<p>It is legal to intermix calls to <code><code>gzread</code></code> and <code><code>gzreadline</code></code>.</p>

<p>To maintain backward compatibility with version 1.x of this module <code><code>gzreadline</code></code> ignores the <code><code>$/</code></code> variable - it <i>always</i> uses the string <code><code>&quot;\n&quot;</code></code> as the line delimiter.</p>

<p>If you want to read a gzip file a line at a time and have it respect the <code><code>$/</code></code> variable (or <code><code>$INPUT_RECORD_SEPARATOR</code></code>, or <code><code>$RS</code></code> when <code><code>English</code></code> is in use) see <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a>.</p>

</dd>
<dt id="byteswritten-gz-gzwrite-buffer-"><b>$byteswritten = $gz-&gt;gzwrite($buffer) ;</b></dt>
<dd>

<p>Writes the contents of <code><code>$buffer</code></code> to the compressed file. Returns the number of bytes actually written, or 0 on error.</p>

</dd>
<dt id="status-gz-gzflush-flush_type-"><b>$status = $gz-&gt;gzflush($flush_type) ;</b></dt>
<dd>

<p>Flushes all pending output into the compressed file.</p>

<p>This method takes an optional parameter, <code><code>$flush_type</code></code>, that controls how the flushing will be carried out. By default the <code><code>$flush_type</code></code> used is <code><code>Z_FINISH</code></code>. Other valid values for <code><code>$flush_type</code></code> are <code><code>Z_NO_FLUSH</code></code>, <code><code>Z_SYNC_FLUSH</code></code>, <code><code>Z_FULL_FLUSH</code></code> and <code><code>Z_BLOCK</code></code>. It is strongly recommended that you only set the <code><code>flush_type</code></code> parameter if you fully understand the implications of what it does - overuse of <code><code>flush</code></code> can seriously degrade the level of compression achieved. See the <code><code>zlib</code></code> documentation for details.</p>

<p>Returns 0 on success.</p>

</dd>
<dt id="offset-gz-gztell-"><b>$offset = $gz-&gt;gztell() ;</b></dt>
<dd>

<p>Returns the uncompressed file offset.</p>

</dd>
<dt id="status-gz-gzseek-offset-whence-"><b>$status = $gz-&gt;gzseek($offset, $whence) ;</b></dt>
<dd>

<p>Provides a sub-set of the <code><code>seek</code></code> functionality, with the restriction that it is only legal to seek forward in the compressed file. It is a fatal error to attempt to seek backward.</p>

<p>When opened for writing, empty parts of the file will have NULL (0x00) bytes written to them.</p>

<p>The <code><code>$whence</code></code> parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</p>

<p>Returns 1 on success, 0 on failure.</p>

</dd>
<dt id="gz-gzclose"><b>$gz-&gt;gzclose</b></dt>
<dd>

<p>Closes the compressed file. Any pending data is flushed to the file before it is closed.</p>

<p>Returns 0 on success.</p>

</dd>
<dt id="gz-gzsetparams-level-strategy"><b>$gz-&gt;gzsetparams($level, $strategy</b></dt>
<dd>

<p>Change settings for the deflate stream <code><code>$gz</code></code>.</p>

<p>The list of the valid options is shown below. Options not specified will remain unchanged.</p>

<p>Note: This method is only available if you are running zlib 1.0.6 or better.</p>

<dl>

<dt id="level"><b>$level</b></dt>
<dd>

<p>Defines the compression level. Valid values are 0 through 9, <code><code>Z_NO_COMPRESSION</code></code>, <code><code>Z_BEST_SPEED</code></code>, <code><code>Z_BEST_COMPRESSION</code></code>, and <code><code>Z_DEFAULT_COMPRESSION</code></code>.</p>

</dd>
<dt id="strategy"><b>$strategy</b></dt>
<dd>

<p>Defines the strategy used to tune the compression. The valid values are <code><code>Z_DEFAULT_STRATEGY</code></code>, <code><code>Z_FILTERED</code></code> and <code><code>Z_HUFFMAN_ONLY</code></code>.</p>

</dd>
</dl>

</dd>
<dt id="gz-gzerror"><b>$gz-&gt;gzerror</b></dt>
<dd>

<p>Returns the <i>zlib</i> error message or number for the last operation associated with <code><code>$gz</code></code>. The return value will be the <i>zlib</i> error number when used in a numeric context and the <i>zlib</i> error message when used in a string context. The <i>zlib</i> error number constants, shown below, are available for use.</p>

<pre><code><code>    Z_OK
    Z_STREAM_END
    Z_ERRNO
    Z_STREAM_ERROR
    Z_DATA_ERROR
    Z_MEM_ERROR
    Z_BUF_ERROR</code></code></pre>

</dd>
<dt id="gzerrno"><b>$gzerrno</b></dt>
<dd>

<p>The <code><code>$gzerrno</code></code> scalar holds the error code associated with the most recent <i>gzip</i> routine. Note that unlike <code><code>gzerror()</code></code>, the error is <i>not</i> associated with a particular file.</p>

<p>As with <code><code>gzerror()</code></code> it returns an error number in numeric context and an error message in string context. Unlike <code><code>gzerror()</code></code> though, the error message will correspond to the <i>zlib</i> message when the error is associated with <i>zlib</i> itself, or the UNIX error message when it is not (i.e. <i>zlib</i> returned <code><code>Z_ERRORNO</code></code>).</p>

<p>As there is an overlap between the error numbers used by <i>zlib</i> and UNIX, <code><code>$gzerrno</code></code> should only be used to check for the presence of <i>an</i> error in numeric context. Use <code><code>gzerror()</code></code> to check for specific <i>zlib</i> errors. The <i>gzcat</i> example below shows how the variable can be used safely.</p>

</dd>
</dl>

<h2 id="Examples">Examples</h2>

<p>Here is an example script which uses the interface. It implements a <i>gzcat</i> function.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span> <span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="comment"># use stdin if no files supplied</span>
    <span class="variable">@ARGV</span> <span class="operator">=</span> <span class="string">'-'</span> <span class="keyword">unless</span> <span class="variable">@ARGV</span> <span class="operator">;</span>
    
    <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$file</span> <span class="operator">(</span><span class="variable">@ARGV</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$buffer</span> <span class="operator">;</span>
    
        <span class="keyword">my</span> <span class="variable">$gz</span> <span class="operator">=</span> <span class="variable">gzopen</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">,</span> <span class="string">"rb"</span><span class="operator">)</span> 
             <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot open </span><span class="variable">$file</span><span class="string">: </span><span class="variable">$gzerrno</span><span class="string">\n"</span> <span class="operator">;</span>
    
        <span class="keyword">print</span> <span class="variable">$buffer</span> <span class="keyword">while</span> <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzread</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> <span class="operator">&gt;</span> <span class="number">0</span> <span class="operator">;</span>
    
        <span class="keyword">die</span> <span class="string">"Error reading from </span><span class="variable">$file</span><span class="string">: </span><span class="variable">$gzerrno</span><span class="string">"</span> <span class="operator">.</span> <span class="operator">(</span><span class="variable">$gzerrno</span><span class="operator">+</span><span class="number">0</span><span class="operator">)</span> <span class="operator">.</span> <span class="string">"\n"</span> 
            <span class="keyword">if</span> <span class="variable">$gzerrno</span> <span class="operator">!=</span> <span class="variable">Z_STREAM_END</span> <span class="operator">;</span>
        
        <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzclose</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Below is a script which makes use of <code><code>gzreadline</code></code>. It implements a very simple <i>grep</i> like script.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span> <span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="keyword">die</span> <span class="string">"Usage: gzgrep pattern [file...]\n"</span>
        <span class="keyword">unless</span> <span class="variable">@ARGV</span> <span class="operator">&gt;=</span> <span class="number">1</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$pattern</span> <span class="operator">=</span> <span class="keyword">shift</span> <span class="operator">;</span>
    
    <span class="comment"># use stdin if no files supplied</span>
    <span class="variable">@ARGV</span> <span class="operator">=</span> <span class="string">'-'</span> <span class="keyword">unless</span> <span class="variable">@ARGV</span> <span class="operator">;</span>
    
    <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$file</span> <span class="operator">(</span><span class="variable">@ARGV</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$gz</span> <span class="operator">=</span> <span class="variable">gzopen</span><span class="operator">(</span><span class="variable">$file</span><span class="operator">,</span> <span class="string">"rb"</span><span class="operator">)</span> 
             <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot open </span><span class="variable">$file</span><span class="string">: </span><span class="variable">$gzerrno</span><span class="string">\n"</span> <span class="operator">;</span>
    
        <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzreadline</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">&gt;</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="keyword">if</span> <span class="regex">/</span><span class="variable">$pattern</span><span class="regex">/</span> <span class="operator">;</span>
        <span class="operator">}</span>
    
        <span class="keyword">die</span> <span class="string">"Error reading from </span><span class="variable">$file</span><span class="string">: </span><span class="variable">$gzerrno</span><span class="string">\n"</span> 
            <span class="keyword">if</span> <span class="variable">$gzerrno</span> <span class="operator">!=</span> <span class="variable">Z_STREAM_END</span> <span class="operator">;</span>
        
        <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzclose</span><span class="operator">()</span> <span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>This script, <i>gzstream</i>, does the opposite of the <i>gzcat</i> script above. It reads from standard input and writes a gzip data stream to standard output.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span> <span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="keyword">binmode</span> <span class="variable">STDOUT</span><span class="operator">;</span>  <span class="comment"># gzopen only sets it on the fd</span>
    
    <span class="keyword">my</span> <span class="variable">$gz</span> <span class="operator">=</span> <span class="variable">gzopen</span><span class="operator">(\</span><span class="variable">*STDOUT</span><span class="operator">,</span> <span class="string">"wb"</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot open stdout: </span><span class="variable">$gzerrno</span><span class="string">\n"</span> <span class="operator">;</span>
    
    <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span> <span class="operator">{</span>
        <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzwrite</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> 
          <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"error writing: </span><span class="variable">$gzerrno</span><span class="string">\n"</span> <span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="variable">$gz</span><span class="operator">-&gt;</span><span class="variable">gzclose</span> <span class="operator">;</span>
</code></code></pre>

<h2 id="Compress::Zlib::memGzip">Compress::Zlib::memGzip</h2>

<p>This function is used to create an in-memory gzip file with the minimum possible gzip header (exactly 10 bytes).</p>

<pre><code><code>    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">Compress::Zlib::memGzip</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> 
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot compress: </span><span class="variable">$gzerrno</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>If successful, it returns the in-memory gzip file. Otherwise it returns <code><code>undef</code></code> and the <code><code>$gzerrno</code></code> variable will store the zlib error code.</p>

<p>The <code><code>$buffer</code></code> parameter can either be a scalar or a scalar reference.</p>

<p>See <a href="../../lib/IO/Compress/Gzip.html">IO::Compress::Gzip</a> for an alternative way to carry out in-memory gzip compression.</p>

<h2 id="Compress::Zlib::memGunzip">Compress::Zlib::memGunzip</h2>

<p>This function is used to uncompress an in-memory gzip file.</p>

<pre><code><code>    <span class="variable">$dest</span> <span class="operator">=</span> <span class="variable">Compress::Zlib::memGunzip</span><span class="operator">(</span><span class="variable">$buffer</span><span class="operator">)</span> 
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot uncompress: </span><span class="variable">$gzerrno</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>If successful, it returns the uncompressed gzip file. Otherwise it returns <code><code>undef</code></code> and the <code><code>$gzerrno</code></code> variable will store the zlib error code.</p>

<p>The <code><code>$buffer</code></code> parameter can either be a scalar or a scalar reference. The contents of the <code><code>$buffer</code></code> parameter are destroyed after calling this function.</p>

<p>If <code><code>$buffer</code></code> consists of multiple concatenated gzip data streams only the first will be uncompressed. Use <code><code>gunzip</code></code> with the <code><code>MultiStream</code></code> option in the <code><code>IO::Uncompress::Gunzip</code></code> module if you need to deal with concatenated data streams.</p>

<p>See <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a> for an alternative way to carry out in-memory gzip uncompression.</p>

<h1 id="COMPRESS-UNCOMPRESS">COMPRESS/UNCOMPRESS</h1>

<p>Two functions are provided to perform in-memory compression/uncompression of RFC 1950 data streams. They are called <code><code>compress</code></code> and <code><code>uncompress</code></code>.</p>

<dl>

<dt id="dest-compress-source-level-"><b>$dest = compress($source [, $level] ) ;</b></dt>
<dd>

<p>Compresses <code><code>$source</code></code>. If successful it returns the compressed data. Otherwise it returns <i>undef</i>.</p>

<p>The source buffer, <code><code>$source</code></code>, can either be a scalar or a scalar reference.</p>

<p>The <code><code>$level</code></code> parameter defines the compression level. Valid values are 0 through 9, <code><code>Z_NO_COMPRESSION</code></code>, <code><code>Z_BEST_SPEED</code></code>, <code><code>Z_BEST_COMPRESSION</code></code>, and <code><code>Z_DEFAULT_COMPRESSION</code></code>. If <code><code>$level</code></code> is not specified <code><code>Z_DEFAULT_COMPRESSION</code></code> will be used.</p>

</dd>
<dt id="dest-uncompress-source-"><b>$dest = uncompress($source) ;</b></dt>
<dd>

<p>Uncompresses <code><code>$source</code></code>. If successful it returns the uncompressed data. Otherwise it returns <i>undef</i>.</p>

<p>The source buffer can either be a scalar or a scalar reference.</p>

</dd>
</dl>

<p>Please note: the two functions defined above are <i>not</i> compatible with the Unix commands of the same name.</p>

<p>See <a>IO::Deflate</a> and <a>IO::Inflate</a> included with this distribution for an alternative interface for reading/writing RFC 1950 files/buffers.</p>

<h1 id="Deflate-Interface">Deflate Interface</h1>

<p>This section defines an interface that allows in-memory compression using the <i>deflate</i> interface provided by zlib.</p>

<p>Here is a definition of the interface available:</p>

<h2 id="d-status-deflateInit-OPT-"><b>($d, $status) = deflateInit( [OPT] )</b></h2>

<p>Initialises a deflation stream.</p>

<p>It combines the features of the <i>zlib</i> functions <code><code>deflateInit</code></code>, <code><code>deflateInit2</code></code> and <code><code>deflateSetDictionary</code></code>.</p>

<p>If successful, it will return the initialised deflation stream, <code><code>$d</code></code> and <code><code>$status</code></code> of <code><code>Z_OK</code></code> in a list context. In scalar context it returns the deflation stream, <code><code>$d</code></code>, only.</p>

<p>If not successful, the returned deflation stream (<code><code>$d</code></code>) will be <i>undef</i> and <code><code>$status</code></code> will hold the exact <i>zlib</i> error code.</p>

<p>The function optionally takes a number of named options specified as <code><code>-Name=&gt;value</code></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p>

<p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.</p>

<p>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</p>

<p>Here is a list of the valid options:</p>

<dl>

<dt id="Level"><b>-Level</b></dt>
<dd>

<p>Defines the compression level. Valid values are 0 through 9, <code><code>Z_NO_COMPRESSION</code></code>, <code><code>Z_BEST_SPEED</code></code>, <code><code>Z_BEST_COMPRESSION</code></code>, and <code><code>Z_DEFAULT_COMPRESSION</code></code>.</p>

<p>The default is Z_DEFAULT_COMPRESSION.</p>

</dd>
<dt id="Method"><b>-Method</b></dt>
<dd>

<p>Defines the compression method. The only valid value at present (and the default) is Z_DEFLATED.</p>

</dd>
<dt id="WindowBits"><b>-WindowBits</b></dt>
<dd>

<p>To create an RFC 1950 data stream, set <code><code>WindowBits</code></code> to a positive number.</p>

<p>To create an RFC 1951 data stream, set <code><code>WindowBits</code></code> to <code><code>-MAX_WBITS</code></code>.</p>

<p>For a full definition of the meaning and valid values for <code><code>WindowBits</code></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p>

<p>Defaults to MAX_WBITS.</p>

</dd>
<dt id="MemLevel"><b>-MemLevel</b></dt>
<dd>

<p>For a definition of the meaning and valid values for <code><code>MemLevel</code></code> refer to the <i>zlib</i> documentation for <i>deflateInit2</i>.</p>

<p>Defaults to MAX_MEM_LEVEL.</p>

</dd>
<dt id="Strategy"><b>-Strategy</b></dt>
<dd>

<p>Defines the strategy used to tune the compression. The valid values are <code><code>Z_DEFAULT_STRATEGY</code></code>, <code><code>Z_FILTERED</code></code> and <code><code>Z_HUFFMAN_ONLY</code></code>.</p>

<p>The default is Z_DEFAULT_STRATEGY.</p>

</dd>
<dt id="Dictionary"><b>-Dictionary</b></dt>
<dd>

<p>When a dictionary is specified <i>Compress::Zlib</i> will automatically call <code><code>deflateSetDictionary</code></code> directly after calling <code><code>deflateInit</code></code>. The Adler32 value for the dictionary can be obtained by calling the method <code><code>$d-</code></code>dict_adler()&gt;.</p>

<p>The default is no dictionary.</p>

</dd>
<dt id="Bufsize"><b>-Bufsize</b></dt>
<dd>

<p>Sets the initial size for the deflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of <code><code>Bufsize</code></code>.</p>

<p>The default is 4096.</p>

</dd>
</dl>

<p>Here is an example of using the <code><code>deflateInit</code></code> optional parameter list to override the default buffer size and compression level. All other options will take their default values.</p>

<pre><code><code>    <span class="variable">deflateInit</span><span class="operator">(</span> <span class="string">-Bufsize</span> <span class="operator">=&gt;</span> <span class="number">300</span><span class="operator">,</span> 
                 <span class="string">-Level</span> <span class="operator">=&gt;</span> <span class="variable">Z_BEST_SPEED</span>  <span class="operator">)</span> <span class="operator">;</span>
</code></code></pre>

<h2 id="out-status-d-deflate-buffer-"><b>($out, $status) = $d-&gt;deflate($buffer)</b></h2>

<p>Deflates the contents of <code><code>$buffer</code></code>. The buffer can either be a scalar or a scalar reference. When finished, <code><code>$buffer</code></code> will be completely processed (assuming there were no errors). If the deflation was successful it returns the deflated output, <code><code>$out</code></code>, and a status value, <code><code>$status</code></code>, of <code><code>Z_OK</code></code>.</p>

<p>On error, <code><code>$out</code></code> will be <i>undef</i> and <code><code>$status</code></code> will contain the <i>zlib</i> error code.</p>

<p>In a scalar context <code><code>deflate</code></code> will return <code><code>$out</code></code> only.</p>

<p>As with the <i>deflate</i> function in <i>zlib</i>, it is not necessarily the case that any output will be produced by this method. So don&#39;t rely on the fact that <code><code>$out</code></code> is empty for an error test.</p>

<h2 id="out-status-d-flush-head2-out-status-d-flush-flush_type-"><b>($out, $status) = $d-&gt;flush()</b> =head2 <b>($out, $status) = $d-&gt;flush($flush_type)</b></h2>

<p>Typically used to finish the deflation. Any pending output will be returned via <code><code>$out</code></code>. <code><code>$status</code></code> will have a value <code><code>Z_OK</code></code> if successful.</p>

<p>In a scalar context <code><code>flush</code></code> will return <code><code>$out</code></code> only.</p>

<p>Note that flushing can seriously degrade the compression ratio, so it should only be used to terminate a decompression (using <code><code>Z_FINISH</code></code>) or when you want to create a <i>full flush point</i> (using <code><code>Z_FULL_FLUSH</code></code>).</p>

<p>By default the <code><code>flush_type</code></code> used is <code><code>Z_FINISH</code></code>. Other valid values for <code><code>flush_type</code></code> are <code><code>Z_NO_FLUSH</code></code>, <code><code>Z_PARTIAL_FLUSH</code></code>, <code><code>Z_SYNC_FLUSH</code></code> and <code><code>Z_FULL_FLUSH</code></code>. It is strongly recommended that you only set the <code><code>flush_type</code></code> parameter if you fully understand the implications of what it does. See the <code><code>zlib</code></code> documentation for details.</p>

<h2 id="status-d-deflateParams-OPT-"><b>$status = $d-&gt;deflateParams([OPT])</b></h2>

<p>Change settings for the deflate stream <code><code>$d</code></code>.</p>

<p>The list of the valid options is shown below. Options not specified will remain unchanged.</p>

<dl>

<dt id="Level1"><b>-Level</b></dt>
<dd>

<p>Defines the compression level. Valid values are 0 through 9, <code><code>Z_NO_COMPRESSION</code></code>, <code><code>Z_BEST_SPEED</code></code>, <code><code>Z_BEST_COMPRESSION</code></code>, and <code><code>Z_DEFAULT_COMPRESSION</code></code>.</p>

</dd>
<dt id="Strategy1"><b>-Strategy</b></dt>
<dd>

<p>Defines the strategy used to tune the compression. The valid values are <code><code>Z_DEFAULT_STRATEGY</code></code>, <code><code>Z_FILTERED</code></code> and <code><code>Z_HUFFMAN_ONLY</code></code>.</p>

</dd>
</dl>

<h2 id="d-dict_adler-"><b>$d-&gt;dict_adler()</b></h2>

<p>Returns the adler32 value for the dictionary.</p>

<h2 id="d-msg-"><b>$d-&gt;msg()</b></h2>

<p>Returns the last error message generated by zlib.</p>

<h2 id="d-total_in-"><b>$d-&gt;total_in()</b></h2>

<p>Returns the total number of bytes uncompressed bytes input to deflate.</p>

<h2 id="d-total_out-"><b>$d-&gt;total_out()</b></h2>

<p>Returns the total number of compressed bytes output from deflate.</p>

<h2 id="Example">Example</h2>

<p>Here is a trivial example of using <code><code>deflate</code></code>. It simply reads standard input, deflates it and writes it to standard output.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span> <span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="keyword">binmode</span> <span class="variable">STDIN</span><span class="operator">;</span>
    <span class="keyword">binmode</span> <span class="variable">STDOUT</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">deflateInit</span><span class="operator">()</span>
       <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot create a deflation stream\n"</span> <span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$output</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(&lt;&gt;)</span>
    <span class="operator">{</span>
        <span class="operator">(</span><span class="variable">$output</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$x</span><span class="operator">-&gt;</span><span class="variable">deflate</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">;</span>
    
        <span class="variable">$status</span> <span class="operator">==</span> <span class="variable">Z_OK</span>
            <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"deflation failed\n"</span> <span class="operator">;</span>
    
        <span class="keyword">print</span> <span class="variable">$output</span> <span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="operator">(</span><span class="variable">$output</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$x</span><span class="operator">-&gt;</span><span class="variable">flush</span><span class="operator">()</span> <span class="operator">;</span>
    
    <span class="variable">$status</span> <span class="operator">==</span> <span class="variable">Z_OK</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"deflation failed\n"</span> <span class="operator">;</span>
    
    <span class="keyword">print</span> <span class="variable">$output</span> <span class="operator">;</span>
</code></code></pre>

<h1 id="Inflate-Interface">Inflate Interface</h1>

<p>This section defines the interface available that allows in-memory uncompression using the <i>deflate</i> interface provided by zlib.</p>

<p>Here is a definition of the interface:</p>

<h2 id="i-status-inflateInit-"><b>($i, $status) = inflateInit()</b></h2>

<p>Initialises an inflation stream.</p>

<p>In a list context it returns the inflation stream, <code><code>$i</code></code>, and the <i>zlib</i> status code in <code><code>$status</code></code>. In a scalar context it returns the inflation stream only.</p>

<p>If successful, <code><code>$i</code></code> will hold the inflation stream and <code><code>$status</code></code> will be <code><code>Z_OK</code></code>.</p>

<p>If not successful, <code><code>$i</code></code> will be <i>undef</i> and <code><code>$status</code></code> will hold the <i>zlib</i> error code.</p>

<p>The function optionally takes a number of named options specified as <code><code>-Name=&gt;value</code></code> pairs. This allows individual options to be tailored without having to specify them all in the parameter list.</p>

<p>For backward compatibility, it is also possible to pass the parameters as a reference to a hash containing the name=&gt;value pairs.</p>

<p>The function takes one optional parameter, a reference to a hash. The contents of the hash allow the deflation interface to be tailored.</p>

<p>Here is a list of the valid options:</p>

<dl>

<dt id="WindowBits1"><b>-WindowBits</b></dt>
<dd>

<p>To uncompress an RFC 1950 data stream, set <code><code>WindowBits</code></code> to a positive number.</p>

<p>To uncompress an RFC 1951 data stream, set <code><code>WindowBits</code></code> to <code><code>-MAX_WBITS</code></code>.</p>

<p>For a full definition of the meaning and valid values for <code><code>WindowBits</code></code> refer to the <i>zlib</i> documentation for <i>inflateInit2</i>.</p>

<p>Defaults to MAX_WBITS.</p>

</dd>
<dt id="Bufsize1"><b>-Bufsize</b></dt>
<dd>

<p>Sets the initial size for the inflation buffer. If the buffer has to be reallocated to increase the size, it will grow in increments of <code><code>Bufsize</code></code>.</p>

<p>Default is 4096.</p>

</dd>
<dt id="Dictionary1"><b>-Dictionary</b></dt>
<dd>

<p>The default is no dictionary.</p>

</dd>
</dl>

<p>Here is an example of using the <code><code>inflateInit</code></code> optional parameter to override the default buffer size.</p>

<pre><code><code>    <span class="variable">inflateInit</span><span class="operator">(</span> <span class="string">-Bufsize</span> <span class="operator">=&gt;</span> <span class="number">300</span> <span class="operator">)</span> <span class="operator">;</span>
</code></code></pre>

<h2 id="out-status-i-inflate-buffer-"><b>($out, $status) = $i-&gt;inflate($buffer)</b></h2>

<p>Inflates the complete contents of <code><code>$buffer</code></code>. The buffer can either be a scalar or a scalar reference.</p>

<p>Returns <code><code>Z_OK</code></code> if successful and <code><code>Z_STREAM_END</code></code> if the end of the compressed data has been successfully reached. If not successful, <code><code>$out</code></code> will be <i>undef</i> and <code><code>$status</code></code> will hold the <i>zlib</i> error code.</p>

<p>The <code><code>$buffer</code></code> parameter is modified by <code><code>inflate</code></code>. On completion it will contain what remains of the input buffer after inflation. This means that <code><code>$buffer</code></code> will be an empty string when the return status is <code><code>Z_OK</code></code>. When the return status is <code><code>Z_STREAM_END</code></code> the <code><code>$buffer</code></code> parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</p>

<p>This feature is useful when processing a file format that encapsulates a compressed data stream (e.g. gzip, zip).</p>

<h2 id="status-i-inflateSync-buffer-"><b>$status = $i-&gt;inflateSync($buffer)</b></h2>

<p>Scans <code><code>$buffer</code></code> until it reaches either a <i>full flush point</i> or the end of the buffer.</p>

<p>If a <i>full flush point</i> is found, <code><code>Z_OK</code></code> is returned and <code><code>$buffer</code></code> will be have all data up to the flush point removed. This can then be passed to the <code><code>deflate</code></code> method.</p>

<p>Any other return code means that a flush point was not found. If more data is available, <code><code>inflateSync</code></code> can be called repeatedly with more compressed data until the flush point is found.</p>

<h2 id="i-dict_adler-"><b>$i-&gt;dict_adler()</b></h2>

<p>Returns the adler32 value for the dictionary.</p>

<h2 id="i-msg-"><b>$i-&gt;msg()</b></h2>

<p>Returns the last error message generated by zlib.</p>

<h2 id="i-total_in-"><b>$i-&gt;total_in()</b></h2>

<p>Returns the total number of bytes compressed bytes input to inflate.</p>

<h2 id="i-total_out-"><b>$i-&gt;total_out()</b></h2>

<p>Returns the total number of uncompressed bytes output from inflate.</p>

<h2 id="Example1">Example</h2>

<p>Here is an example of using <code><code>inflate</code></code>.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">warnings</span> <span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">Compress::Zlib</span> <span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">inflateInit</span><span class="operator">()</span>
       <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Cannot create a inflation stream\n"</span> <span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$input</span> <span class="operator">=</span> <span class="string">''</span> <span class="operator">;</span>
    <span class="keyword">binmode</span> <span class="variable">STDIN</span><span class="operator">;</span>
    <span class="keyword">binmode</span> <span class="variable">STDOUT</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$output</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">read</span><span class="operator">(</span><span class="variable">STDIN</span><span class="operator">,</span> <span class="variable">$input</span><span class="operator">,</span> <span class="number">4096</span><span class="operator">))</span>
    <span class="operator">{</span>
        <span class="operator">(</span><span class="variable">$output</span><span class="operator">,</span> <span class="variable">$status</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$x</span><span class="operator">-&gt;</span><span class="variable">inflate</span><span class="operator">(\</span><span class="variable">$input</span><span class="operator">)</span> <span class="operator">;</span>
    
        <span class="keyword">print</span> <span class="variable">$output</span> 
            <span class="keyword">if</span> <span class="variable">$status</span> <span class="operator">==</span> <span class="variable">Z_OK</span> <span class="keyword">or</span> <span class="variable">$status</span> <span class="operator">==</span> <span class="variable">Z_STREAM_END</span> <span class="operator">;</span>
    
        <span class="keyword">last</span> <span class="keyword">if</span> <span class="variable">$status</span> <span class="operator">!=</span> <span class="variable">Z_OK</span> <span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">die</span> <span class="string">"inflation failed\n"</span>
        <span class="keyword">unless</span> <span class="variable">$status</span> <span class="operator">==</span> <span class="variable">Z_STREAM_END</span> <span class="operator">;</span>
</code></code></pre>

<h1 id="CHECKSUM-FUNCTIONS">CHECKSUM FUNCTIONS</h1>

<p>Two functions are provided by <i>zlib</i> to calculate checksums. For the Perl interface, the order of the two parameters in both functions has been reversed. This allows both running checksums and one off calculations to be done.</p>

<pre><code><code>    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">adler32</span><span class="operator">(</span><span class="variable">$buffer</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$crc</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
    <span class="variable">$crc</span> <span class="operator">=</span> <span class="variable">crc32</span><span class="operator">(</span><span class="variable">$buffer</span> <span class="operator">[</span><span class="operator">,</span><span class="variable">$crc</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">;</span>
</code></code></pre>

<p>The buffer parameters can either be a scalar or a scalar reference.</p>

<p>If the $crc parameters is <code><code>undef</code></code>, the crc value will be reset.</p>

<p>If you have built this module with zlib 1.2.3 or better, two more CRC-related functions are available.</p>

<pre><code><code>    $crc = adler32_combine($crc1, $crc2, $len2)l
    $crc = crc32_combine($adler1, $adler2, $len2)</code></code></pre>

<p>These functions allow checksums to be merged.</p>

<h1 id="Misc">Misc</h1>

<h2 id="my-version-Compress::Zlib::zlib_version-">my $version = Compress::Zlib::zlib_version();</h2>

<p>Returns the version of the zlib library.</p>

<h1 id="CONSTANTS">CONSTANTS</h1>

<p>All the <i>zlib</i> constants are automatically imported when you make use of <i>Compress::Zlib</i>.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../lib/IO/Compress/Gzip.html">IO::Compress::Gzip</a>, <a href="../../lib/IO/Uncompress/Gunzip.html">IO::Uncompress::Gunzip</a>, <a href="../../lib/IO/Compress/Deflate.html">IO::Compress::Deflate</a>, <a href="../../lib/IO/Uncompress/Inflate.html">IO::Uncompress::Inflate</a>, <a href="../../lib/IO/Compress/RawDeflate.html">IO::Compress::RawDeflate</a>, <a href="../../lib/IO/Uncompress/RawInflate.html">IO::Uncompress::RawInflate</a>, <a href="../../lib/IO/Compress/Bzip2.html">IO::Compress::Bzip2</a>, <a href="../../lib/IO/Uncompress/Bunzip2.html">IO::Uncompress::Bunzip2</a>, <a>IO::Compress::Lzma</a>, <a>IO::Uncompress::UnLzma</a>, <a>IO::Compress::Xz</a>, <a>IO::Uncompress::UnXz</a>, <a>IO::Compress::Lzop</a>, <a>IO::Uncompress::UnLzop</a>, <a>IO::Compress::Lzf</a>, <a>IO::Uncompress::UnLzf</a>, <a href="../../lib/IO/Uncompress/AnyInflate.html">IO::Uncompress::AnyInflate</a>, <a href="../../lib/IO/Uncompress/AnyUncompress.html">IO::Uncompress::AnyUncompress</a></p>

<p><a href="../../lib/IO/Compress/FAQ.html">IO::Compress::FAQ</a></p>

<p><a href="../../lib/File/GlobMapper.html">File::GlobMapper</a>, <a href="../../lib/Archive/Zip.html">Archive::Zip</a>, <a href="../../lib/Archive/Tar.html">Archive::Tar</a>, <a href="../../lib/IO/Zlib.html">IO::Zlib</a></p>

<p>For RFC 1950, 1951 and 1952 see <i>http://www.faqs.org/rfcs/rfc1950.html</i>, <i>http://www.faqs.org/rfcs/rfc1951.html</i> and <i>http://www.faqs.org/rfcs/rfc1952.html</i></p>

<p>The <i>zlib</i> compression library was written by Jean-loup Gailly <i>gzip@prep.ai.mit.edu</i> and Mark Adler <i>madler@alumni.caltech.edu</i>.</p>

<p>The primary site for the <i>zlib</i> compression library is <i>http://www.zlib.org</i>.</p>

<p>The primary site for gzip is <i>http://www.gzip.org</i>.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>This module was written by Paul Marquess, <i>pmqs@cpan.org</i>.</p>

<h1 id="MODIFICATION-HISTORY">MODIFICATION HISTORY</h1>

<p>See the Changes file.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (c) 1995-2012 Paul Marquess. All rights reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>


</body>

</html>


