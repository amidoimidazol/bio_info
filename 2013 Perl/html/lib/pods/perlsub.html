<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME  </a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Private-Variables-via-my-">Private Variables via my()       </a></li>
      <li><a href="#Persistent-Private-Variables">Persistent Private Variables      </a>
        <ul>
          <li><a href="#Persistent-variables-via-state-">Persistent variables via state()</a></li>
          <li><a href="#Persistent-variables-with-closures">Persistent variables with closures</a></li>
        </ul>
      </li>
      <li><a href="#Temporary-Values-via-local-">Temporary Values via local()     </a>
        <ul>
          <li><a href="#Grammatical-note-on-local-">Grammatical note on local() </a></li>
          <li><a href="#Localization-of-special-variables">Localization of special variables </a></li>
          <li><a href="#Localization-of-globs">Localization of globs  </a></li>
          <li><a href="#Localization-of-elements-of-composite-types">Localization of elements of composite types   </a></li>
          <li><a href="#Localized-deletion-of-elements-of-composite-types">Localized deletion of elements of composite types    </a></li>
        </ul>
      </li>
      <li><a href="#Lvalue-subroutines">Lvalue subroutines  </a></li>
      <li><a href="#Passing-Symbol-Table-Entries-typeglobs-">Passing Symbol Table Entries (typeglobs)  </a></li>
      <li><a href="#When-to-Still-Use-local-">When to Still Use local()  </a></li>
      <li><a href="#Pass-by-Reference">Pass by Reference   </a></li>
      <li><a href="#Prototypes">Prototypes  </a></li>
      <li><a href="#Constant-Functions">Constant Functions </a></li>
      <li><a href="#Overriding-Built-in-Functions">Overriding Built-in Functions    </a></li>
      <li><a href="#Autoloading">Autoloading  </a></li>
      <li><a href="#Subroutine-Attributes">Subroutine Attributes   </a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME  </h1>

<p>perlsub - Perl subroutines</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<p>To declare subroutines:  </p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> NAME</span><span class="operator">;</span>                     <span class="comment"># A "forward" declaration.</span>
    <span class="keyword">sub</span><span class="variable"> NAME</span><span class="operator">(</span>PROTO<span class="operator">);</span>              <span class="comment">#  ditto, but with prototypes</span>
    <span class="keyword">sub</span><span class="variable"> NAME : ATTRS</span><span class="operator">;</span>             <span class="comment">#  with attributes</span>
    <span class="keyword">sub</span><span class="variable"> NAME</span><span class="operator">(</span>PROTO<span class="operator">)</span> <span class="operator">:</span> <span class="variable">ATTRS</span><span class="operator">;</span>      <span class="comment">#  with attributes and prototypes</span>
    
    <span class="keyword">sub</span><span class="variable"> NAME BLOCK                </span><span class="comment"># A declaration and a definition.</span><span class="variable">
    sub NAME</span><span class="operator">(</span>PROTO<span class="operator">)</span> <span class="variable">BLOCK</span>         <span class="comment">#  ditto, but with prototypes</span>
    <span class="keyword">sub</span><span class="variable"> NAME : ATTRS BLOCK        </span><span class="comment">#  with attributes</span><span class="variable">
    sub NAME</span><span class="operator">(</span>PROTO<span class="operator">)</span> <span class="operator">:</span> <span class="variable">ATTRS</span> <span class="variable">BLOCK</span> <span class="comment">#  with prototypes and attributes</span>
</code></code></pre>

<p>To define an anonymous subroutine at runtime: </p>

<pre><code><code>    <span class="variable">$subref</span> <span class="operator">=</span> <span class="keyword">sub</span><span class="variable"> BLOCK</span><span class="operator">;</span>                 <span class="comment"># no proto</span>
    <span class="variable">$subref</span> <span class="operator">=</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">(</span>PROTO<span class="operator">)</span> <span class="variable">BLOCK</span><span class="operator">;</span>         <span class="comment"># with proto</span>
    <span class="variable">$subref</span> <span class="operator">=</span> <span class="variable">sub</span> <span class="operator">:</span> <span class="variable">ATTRS</span> <span class="variable">BLOCK</span><span class="operator">;</span>         <span class="comment"># with attributes</span>
    <span class="variable">$subref</span> <span class="operator">=</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">(</span>PROTO<span class="operator">)</span> <span class="operator">:</span> <span class="variable">ATTRS</span> <span class="variable">BLOCK</span><span class="operator">;</span> <span class="comment"># with proto and attributes</span>
</code></code></pre>

<p>To import subroutines: </p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">MODULE</span> <span class="string">qw(NAME1 NAME2 NAME3)</span><span class="operator">;</span>
</code></code></pre>

<p>To call subroutines:  </p>

<pre><code><code>    <span class="variable">NAME</span><span class="operator">(</span><span class="variable">LIST</span><span class="operator">);</span>    <span class="comment"># &amp; is optional with parentheses.</span>
    <span class="variable">NAME</span> <span class="variable">LIST</span><span class="operator">;</span>     <span class="comment"># Parentheses optional if predeclared/imported.</span>
    <span class="operator">&amp;</span><span class="variable">NAME</span><span class="operator">(</span><span class="variable">LIST</span><span class="operator">);</span>   <span class="comment"># Circumvent prototypes.</span>
    <span class="operator">&amp;</span><span class="variable">NAME</span><span class="operator">;</span>         <span class="comment"># Makes current @_ visible to called subroutine.</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Like many languages, Perl provides for user-defined subroutines. These may be located anywhere in the main program, loaded in from other files via the <code><code>do</code></code>, <code><code>require</code></code>, or <code><code>use</code></code> keywords, or generated on the fly using <code><code>eval</code></code> or anonymous subroutines. You can even call a function indirectly using a variable containing its name or a CODE reference.</p>

<p>The Perl model for function call and return values is simple: all functions are passed as parameters one single flat list of scalars, and all functions likewise return to their caller one single flat list of scalars. Any arrays or hashes in these call and return lists will collapse, losing their identities--but you may always use pass-by-reference instead to avoid this. Both call and return lists may contain as many or as few scalar elements as you&#39;d like. (Often a function without an explicit return statement is called a subroutine, but there&#39;s really no difference from Perl&#39;s perspective.)  </p>

<p>Any arguments passed in show up in the array <code><code>@_</code></code>. Therefore, if you called a function with two arguments, those would be stored in <code><code>$_[0]</code></code> and <code><code>$_[1]</code></code>. The array <code><code>@_</code></code> is a local array, but its elements are aliases for the actual scalar parameters. In particular, if an element <code><code>$_[0]</code></code> is updated, the corresponding argument is updated (or an error occurs if it is not updatable). If an argument is an array or hash element which did not exist when the function was called, that element is created only when (and if) it is modified or a reference to it is taken. (Some earlier versions of Perl created the element whether or not the element was assigned to.) Assigning to the whole array <code><code>@_</code></code> removes that aliasing, and does not update any arguments.   </p>

<p>A <code><code>return</code></code> statement may be used to exit a subroutine, optionally specifying the returned value, which will be evaluated in the appropriate context (list, scalar, or void) depending on the context of the subroutine call. If you specify no return value, the subroutine returns an empty list in list context, the undefined value in scalar context, or nothing in void context. If you return one or more aggregates (arrays and hashes), these will be flattened together into one large indistinguishable list.</p>

<p>If no <code><code>return</code></code> is found and if the last statement is an expression, its value is returned. If the last statement is a loop control structure like a <code><code>foreach</code></code> or a <code><code>while</code></code>, the returned value is unspecified. The empty sub returns the empty list.   </p>

<p>Perl does not have named formal parameters. In practice all you do is assign to a <code><code>my()</code></code> list of these. Variables that aren&#39;t declared to be private are global variables. For gory details on creating private variables, see <a href="#Private-Variables-via-my-">&quot;Private Variables via my()&quot;</a> and <a href="#Temporary-Values-via-local-">&quot;Temporary Values via local()&quot;</a>. To create protected environments for a set of functions in a separate package (and probably a separate file), see <a href="../../lib/pods/perlmod.html#Packages">&quot;Packages&quot; in perlmod</a>.  </p>

<p>Example:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> max </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$max</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">(</span><span class="variable">@_</span><span class="operator">);</span>
        <span class="keyword">foreach</span> <span class="variable">$foo</span> <span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$max</span> <span class="operator">=</span> <span class="variable">$foo</span> <span class="keyword">if</span> <span class="variable">$max</span> <span class="operator">&lt;</span> <span class="variable">$foo</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">$max</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">$bestday</span> <span class="operator">=</span> <span class="variable">max</span><span class="operator">(</span><span class="variable">$mon</span><span class="operator">,</span><span class="variable">$tue</span><span class="operator">,</span><span class="variable">$wed</span><span class="operator">,</span><span class="variable">$thu</span><span class="operator">,</span><span class="variable">$fri</span><span class="operator">);</span>
</code></code></pre>

<p>Example:</p>

<pre><code><code>    <span class="comment"># get a line, combining continuation lines</span>
    <span class="comment">#  that start with whitespace</span>
    
    <span class="keyword">sub</span><span class="variable"> get_line </span><span class="operator">{</span>
        <span class="variable">$thisline</span> <span class="operator">=</span> <span class="variable">$lookahead</span><span class="operator">;</span>  <span class="comment"># global variables!</span>
        <span class="variable">LINE</span><span class="operator">:</span> <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">defined</span><span class="operator">(</span><span class="variable">$lookahead</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;))</span> <span class="operator">{</span>
            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$lookahead</span> <span class="operator">=~</span> <span class="regex">/^[ \t]/</span><span class="operator">)</span> <span class="operator">{</span>
                <span class="variable">$thisline</span> <span class="operator">.=</span> <span class="variable">$lookahead</span><span class="operator">;</span>
            <span class="operator">}</span>
            <span class="keyword">else</span> <span class="operator">{</span>
                <span class="keyword">last</span> <span class="variable">LINE</span><span class="operator">;</span>
            <span class="operator">}</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">$thisline</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="variable">$lookahead</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>       <span class="comment"># get first line</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">defined</span><span class="operator">(</span><span class="variable">$line</span> <span class="operator">=</span> <span class="variable">get_line</span><span class="operator">()))</span> <span class="operator">{</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Assigning to a list of private variables to name your arguments:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> maybeset </span><span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$key</span><span class="operator">,</span> <span class="variable">$value</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="variable">$Foo</span><span class="operator">{</span><span class="variable">$key</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$value</span> <span class="keyword">unless</span> <span class="variable">$Foo</span><span class="operator">{</span><span class="variable">$key</span><span class="operator">}</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of <code><code>@_</code></code> and change its caller&#39;s values.  </p>

<pre><code><code>    <span class="variable">upcase_in</span><span class="operator">(</span><span class="variable">$v1</span><span class="operator">,</span> <span class="variable">$v2</span><span class="operator">);</span>  <span class="comment"># this changes $v1 and $v2</span>
    <span class="keyword">sub</span><span class="variable"> upcase_in </span><span class="operator">{</span>
        <span class="keyword">for</span> <span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">{</span> <span class="regex">tr/a-z/A-Z/</span> <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>You aren&#39;t allowed to modify constants in this way, of course. If an argument were actually literal and you tried to change it, you&#39;d take a (presumably fatal) exception. For example, this won&#39;t work:  </p>

<pre><code><code>    <span class="variable">upcase_in</span><span class="operator">(</span><span class="string">"frederick"</span><span class="operator">);</span>
</code></code></pre>

<p>It would be much safer if the <code><code>upcase_in()</code></code> function were written to return a copy of its parameters instead of changing them in place:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">$v3</span><span class="operator">,</span> <span class="variable">$v4</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">upcase</span><span class="operator">(</span><span class="variable">$v1</span><span class="operator">,</span> <span class="variable">$v2</span><span class="operator">);</span>  <span class="comment"># this doesn't change $v1 and $v2</span>
    <span class="keyword">sub</span><span class="variable"> upcase </span><span class="operator">{</span>
        <span class="keyword">return</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="keyword">wantarray</span><span class="operator">;</span>  <span class="comment"># void context, do nothing</span>
        <span class="keyword">my</span> <span class="variable">@parms</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">for</span> <span class="operator">(</span><span class="variable">@parms</span><span class="operator">)</span> <span class="operator">{</span> <span class="regex">tr/a-z/A-Z/</span> <span class="operator">}</span>
        <span class="keyword">return</span> <span class="keyword">wantarray</span> <span class="operator">?</span> <span class="variable">@parms</span> <span class="operator">:</span> <span class="variable">$parms</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Notice how this (unprototyped) function doesn&#39;t care whether it was passed real scalars or arrays. Perl sees all arguments as one big, long, flat parameter list in <code><code>@_</code></code>. This is one area where Perl&#39;s simple argument-passing style shines. The <code><code>upcase()</code></code> function would work perfectly well without changing the <code><code>upcase()</code></code> definition even if we fed it things like this:</p>

<pre><code><code>    <span class="variable">@newlist</span>   <span class="operator">=</span> <span class="variable">upcase</span><span class="operator">(</span><span class="variable">@list1</span><span class="operator">,</span> <span class="variable">@list2</span><span class="operator">);</span>
    <span class="variable">@newlist</span>   <span class="operator">=</span> <span class="variable">upcase</span><span class="operator">(</span> <span class="keyword">split</span> <span class="regex">/:/</span><span class="operator">,</span> <span class="variable">$var</span> <span class="operator">);</span>
</code></code></pre>

<p>Do not, however, be tempted to do this:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">@a</span><span class="operator">,</span> <span class="variable">@b</span><span class="operator">)</span>   <span class="operator">=</span> <span class="variable">upcase</span><span class="operator">(</span><span class="variable">@list1</span><span class="operator">,</span> <span class="variable">@list2</span><span class="operator">);</span>
</code></code></pre>

<p>Like the flattened incoming parameter list, the return list is also flattened on return. So all you have managed to do here is stored everything in <code><code>@a</code></code> and made <code><code>@b</code></code> empty. See <a href="#Pass-by-Reference">&quot;Pass by Reference&quot;</a> for alternatives.</p>

<p>A subroutine may be called using an explicit <code><code>&amp;</code></code> prefix. The <code><code>&amp;</code></code> is optional in modern Perl, as are parentheses if the subroutine has been predeclared. The <code><code>&amp;</code></code> is <i>not</i> optional when just naming the subroutine, such as when it&#39;s used as an argument to defined() or undef(). Nor is it optional when you want to do an indirect subroutine call with a subroutine name or reference using the <code><code>&amp;$subref()</code></code> or <code><code><span class="operator">&amp;{</span><span class="variable">$subref</span><span class="operator">}()</span>
</code></code> constructs, although the <code><code>$subref-&gt;()</code></code> notation solves that problem. See <a href="../../lib/pods/perlref.html">perlref</a> for more about all that. </p>

<p>Subroutines may be called recursively. If a subroutine is called using the <code><code>&amp;</code></code> form, the argument list is optional, and if omitted, no <code><code>@_</code></code> array is set up for the subroutine: the <code><code>@_</code></code> array at the time of the call is visible to subroutine instead. This is an efficiency mechanism that new users may wish to avoid. </p>

<pre><code><code>    <span class="operator">&amp;</span><span class="variable">foo</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">);</span>        <span class="comment"># pass three arguments</span>
    <span class="variable">foo</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">);</span>         <span class="comment"># the same</span>
    
    <span class="variable">foo</span><span class="operator">();</span>              <span class="comment"># pass a null list</span>
    <span class="operator">&amp;</span><span class="variable">foo</span><span class="operator">();</span>             <span class="comment"># the same</span>
    
    <span class="operator">&amp;</span><span class="variable">foo</span><span class="operator">;</span>               <span class="comment"># foo() get current args, like foo(@_) !!</span>
    <span class="variable">foo</span><span class="operator">;</span>                <span class="comment"># like foo() IFF sub foo predeclared, else "foo"</span>
</code></code></pre>

<p>Not only does the <code><code>&amp;</code></code> form make the argument list optional, it also disables any prototype checking on arguments you do provide. This is partly for historical reasons, and partly for having a convenient way to cheat if you know what you&#39;re doing. See <a href="#Prototypes">&quot;Prototypes&quot;</a> below. </p>

<p>Since Perl 5.16.0, the <code><code>__SUB__</code></code> token is available under <code><code>use feature &#39;current_sub&#39;</code></code> and <code><code>use 5.16.0</code></code>. It will evaluate to a reference to the currently-running sub, which allows for recursive calls without knowing your subroutine&#39;s name.</p>

<pre><code><code>    <span class="keyword">use</span> <span class="number">5.16</span><span class="operator">.</span><span class="number">0</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$factorial</span> <span class="operator">=</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$x</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> <span class="variable">$x</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">;</span>
      <span class="keyword">return</span><span class="operator">(</span><span class="variable">$x</span> <span class="operator">*</span> <span class="variable">__SUB__</span><span class="operator">-&gt;(</span> <span class="variable">$x</span> <span class="operator">-</span> <span class="number">1</span> <span class="operator">)</span> <span class="operator">);</span>
    <span class="operator">};</span>
</code></code></pre>

<p>Subroutines whose names are in all upper case are reserved to the Perl core, as are modules whose names are in all lower case. A subroutine in all capitals is a loosely-held convention meaning it will be called indirectly by the run-time system itself, usually due to a triggered event. Subroutines that do special, pre-defined things include <code><code>AUTOLOAD</code></code>, <code><code>CLONE</code></code>, <code><code>DESTROY</code></code> plus all functions mentioned in <a href="../../lib/pods/perltie.html">perltie</a> and <a href="../../lib/PerlIO/via.html">PerlIO::via</a>.</p>

<p>The <code><code>BEGIN</code></code>, <code><code>UNITCHECK</code></code>, <code><code>CHECK</code></code>, <code><code>INIT</code></code> and <code><code>END</code></code> subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can <b>not</b> call explicitly. See <a href="../../lib/pods/perlmod.html#BEGIN-UNITCHECK-CHECK-INIT-and-END">&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod</a></p>

<h2 id="Private-Variables-via-my-">Private Variables via my()       </h2>

<p>Synopsis:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$foo</span><span class="operator">;</span>            <span class="comment"># declare $foo lexically local</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">@wid</span><span class="operator">,</span> <span class="variable">%get</span><span class="operator">);</span>    <span class="comment"># declare list of variables local</span>
    <span class="keyword">my</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="string">"flurp"</span><span class="operator">;</span>  <span class="comment"># declare $foo lexical, and init it</span>
    <span class="keyword">my</span> <span class="variable">@oof</span> <span class="operator">=</span> <span class="variable">@bar</span><span class="operator">;</span>     <span class="comment"># declare @oof lexical, and init it</span>
    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">:</span> <span class="variable">Foo</span> <span class="operator">=</span> <span class="variable">$y</span><span class="operator">;</span>   <span class="comment"># similar, with an attribute applied</span>
</code></code></pre>

<p><b>WARNING</b>: The use of attribute lists on <code><code>my</code></code> declarations is still evolving. The current semantics and interface are subject to change. See <a href="../../lib/attributes.html">attributes</a> and <a href="../../lib/Attribute/Handlers.html">Attribute::Handlers</a>.</p>

<p>The <code><code>my</code></code> operator declares the listed variables to be lexically confined to the enclosing block, conditional (<code><code>if/unless/elsif/else</code></code>), loop (<code><code>for/foreach/while/until/continue</code></code>), subroutine, <code><code>eval</code></code>, or <code><code>do/require/use</code></code>&#39;d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like <code><code>$/</code></code> must currently be <code><code>local</code></code>ized with <code><code>local</code></code> instead.</p>

<p>Unlike dynamic variables created by the <code><code>local</code></code> operator, lexical variables declared with <code><code>my</code></code> are totally hidden from the outside world, including any called subroutines. This is true if it&#39;s the same subroutine called from itself or elsewhere--every call gets its own copy. </p>

<p>This doesn&#39;t mean that a <code><code>my</code></code> variable declared in a statically enclosing lexical scope would be invisible. Only dynamic scopes are cut off. For example, the <code><code>bumpx()</code></code> function below has access to the lexical $x variable because both the <code><code>my</code></code> and the <code><code>sub</code></code> occurred at the same scope, presumably file scope.</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="number">10</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> bumpx </span><span class="operator">{</span> <span class="variable">$x</span><span class="operator">++</span> <span class="operator">}</span> 
</code></code></pre>

<p>An <code><code>eval()</code></code>, however, can see lexical variables of the scope it is being evaluated in, so long as the names aren&#39;t hidden by declarations within the <code><code>eval()</code></code> itself. See <a href="../../lib/pods/perlref.html">perlref</a>. </p>

<p>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</p>

<pre><code><code>    <span class="variable">$arg</span> <span class="operator">=</span> <span class="string">"fred"</span><span class="operator">;</span>        <span class="comment"># "global" variable</span>
    <span class="variable">$n</span> <span class="operator">=</span> <span class="variable">cube_root</span><span class="operator">(</span><span class="number">27</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$arg</span><span class="string"> thinks the root is </span><span class="variable">$n</span><span class="string">\n"</span><span class="operator">;</span>
     <span class="variable">fred</span> <span class="variable">thinks</span> <span class="variable">the</span> <span class="variable">root</span> <span class="variable">is</span> <span class="number">3</span>
    
    <span class="keyword">sub</span><span class="variable"> cube_root </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$arg</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>  <span class="comment"># name doesn't matter</span>
        <span class="variable">$arg</span> <span class="operator">**=</span> <span class="number">1</span><span class="operator">/</span><span class="number">3</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="variable">$arg</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>The <code><code>my</code></code> is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, <code><code>my</code></code> doesn&#39;t change whether those variables are viewed as a scalar or an array. So</p>

<pre><code><code>    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$foo</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>                <span class="comment"># WRONG?</span>
    <span class="keyword">my</span> <span class="variable">@FOO</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
</code></code></pre>

<p>both supply a list context to the right-hand side, while</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
</code></code></pre>

<p>supplies a scalar context. But the following declares only one variable:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$foo</span><span class="operator">,</span> <span class="variable">$bar</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>                  <span class="comment"># WRONG</span>
</code></code></pre>

<p>That has the same effect as</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$foo</span><span class="operator">;</span>
    <span class="variable">$bar</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>The declared variable is not introduced (is not visible) until after the current statement. Thus,</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="variable">$x</span><span class="operator">;</span>
</code></code></pre>

<p>can be used to initialize a new $x with the value of the old $x, and the expression</p>

<pre><code><code>    my $x = 123 and $x == 123</code></code></pre>

<p>is false unless the old $x happened to have the value <code><code>123</code></code>.</p>

<p>Lexical scopes of control structures are not bounded precisely by the braces that delimit their controlled blocks; control expressions are part of that scope, too. Thus in the loop</p>

<pre><code><code>    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$line</span> <span class="operator">=</span> <span class="operator">&lt;&gt;)</span> <span class="operator">{</span>
        <span class="variable">$line</span> <span class="operator">=</span> <span class="keyword">lc</span> <span class="variable">$line</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">continue</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="variable">$line</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>the scope of $line extends from its declaration throughout the rest of the loop construct (including the <code><code>continue</code></code> clause), but not beyond it. Similarly, in the conditional</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">((</span><span class="keyword">my</span> <span class="variable">$answer</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;)</span> <span class="operator">=~</span> <span class="regex">/^yes$/i</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">user_agrees</span><span class="operator">();</span>
    <span class="operator">}</span> <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$answer</span> <span class="operator">=~</span> <span class="regex">/^no$/i</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">user_disagrees</span><span class="operator">();</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">chomp</span> <span class="variable">$answer</span><span class="operator">;</span>
        <span class="keyword">die</span> <span class="string">"'</span><span class="variable">$answer</span><span class="string">' is neither 'yes' nor 'no'"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>the scope of $answer extends from its declaration through the rest of that conditional, including any <code><code>elsif</code></code> and <code><code>else</code></code> clauses, but not beyond it. See <a href="../../lib/pods/perlsyn.html#Simple-Statements">&quot;Simple Statements&quot; in perlsyn</a> for information on the scope of variables in statements with modifiers.</p>

<p>The <code><code>foreach</code></code> loop defaults to scoping its index variable dynamically in the manner of <code><code>local</code></code>. However, if the index variable is prefixed with the keyword <code><code>my</code></code>, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop  </p>

<pre><code><code>    <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$i</span> <span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="number">3</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">some_function</span><span class="operator">();</span>
    <span class="operator">}</span>
</code></code></pre>

<p>the scope of $i extends to the end of the loop, but not beyond it, rendering the value of $i inaccessible within <code><code>some_function()</code></code>.  </p>

<p>Some users may wish to encourage the use of lexically scoped variables. As an aid to catching implicit uses to package variables, which are always global, if you say</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">strict</span> <span class="string">'vars'</span><span class="operator">;</span>
</code></code></pre>

<p>then any variable mentioned from there to the end of the enclosing block must either refer to a lexical variable, be predeclared via <code><code>our</code></code> or <code><code>use vars</code></code>, or else must be fully qualified with the package name. A compilation error results otherwise. An inner block may countermand this with <code><code>no strict &#39;vars&#39;</code></code>.</p>

<p>A <code><code>my</code></code> has both a compile-time and a run-time effect. At compile time, the compiler takes notice of it. The principal usefulness of this is to quiet <code><code>use strict &#39;vars&#39;</code></code>, but it is also essential for generation of closures as detailed in <a href="../../lib/pods/perlref.html">perlref</a>. Actual initialization is delayed until run time, though, so it gets executed at the appropriate time, such as each time through a loop, for example.</p>

<p>Variables declared with <code><code>my</code></code> are not part of any package and are therefore never fully qualified with the package name. In particular, you&#39;re not allowed to try to make a package variable (or other global) lexical:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$pack::var</span><span class="operator">;</span>      <span class="comment"># ERROR!  Illegal syntax</span>
</code></code></pre>

<p>In fact, a dynamic variable (also known as package or global variables) are still accessible using the fully qualified <code><code>::</code></code> notation even while a lexical of the same name is also visible:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    <span class="keyword">local</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="number">10</span><span class="operator">;</span>
    <span class="keyword">my</span>    <span class="variable">$x</span> <span class="operator">=</span> <span class="number">20</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$x</span><span class="string"> and $::x\n"</span><span class="operator">;</span>
</code></code></pre>

<p>That will print out <code><code>20</code></code> and <code><code>10</code></code>.</p>

<p>You may declare <code><code>my</code></code> variables at the outermost scope of a file to hide any such identifiers from the world outside that file. This is similar in spirit to C&#39;s static variables when they are used at the file level. To do this with a subroutine requires the use of a closure (an anonymous function that accesses enclosing lexicals). If you want to create a private subroutine that cannot be called from outside that block, it can declare a lexical variable containing an anonymous sub reference:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$secret_version</span> <span class="operator">=</span> <span class="string">'1.001-beta'</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$secret_sub</span> <span class="operator">=</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">print</span> <span class="variable">$secret_version</span> <span class="operator">};</span>
    <span class="operator">&amp;</span><span class="variable">$secret_sub</span><span class="operator">();</span>
</code></code></pre>

<p>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package&#39;s symbol table. Remember that it&#39;s not <i>REALLY</i> called <code><code>$some_pack::secret_version</code></code> or anything; it&#39;s just $secret_version, unqualified and unqualifiable.</p>

<p>This does not work with object methods, however; all object methods have to be in the symbol table of some package to be found. See <a href="../../lib/pods/perlref.html#Function-Templates">&quot;Function Templates&quot; in perlref</a> for something of a work-around to this.</p>

<h2 id="Persistent-Private-Variables">Persistent Private Variables      </h2>

<p>There are two ways to build persistent private variables in Perl 5.10. First, you can simply use the <code><code>state</code></code> feature. Or, you can use closures, if you want to stay compatible with releases older than 5.10.</p>

<h3 id="Persistent-variables-via-state-">Persistent variables via state()</h3>

<p>Beginning with Perl 5.9.4, you can declare variables with the <code><code>state</code></code> keyword in place of <code><code>my</code></code>. For that to work, though, you must have enabled that feature beforehand, either by using the <code><code>feature</code></code> pragma, or by using <code><code>-E</code></code> on one-liners (see <a href="../../lib/feature.html">feature</a>). Beginning with Perl 5.16, the <code><code>CORE::state</code></code> form does not require the <code><code>feature</code></code> pragma.</p>

<p>For example, the following code maintains a private counter, incremented each time the gimme_another() function is called:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">feature</span> <span class="string">'state'</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> gimme_another </span><span class="operator">{</span> <span class="keyword">state</span> <span class="variable">$x</span><span class="operator">;</span> <span class="keyword">return</span> <span class="operator">++</span><span class="variable">$x</span> <span class="operator">}</span>
</code></code></pre>

<p>Also, since <code><code>$x</code></code> is lexical, it can&#39;t be reached or modified by any Perl code outside.</p>

<p>When combined with variable declaration, simple scalar assignment to <code><code>state</code></code> variables (as in <code><code>state $x = 42</code></code>) is executed only the first time. When such statements are evaluated subsequent times, the assignment is ignored. The behavior of this sort of assignment to non-scalar variables is undefined.</p>

<h3 id="Persistent-variables-with-closures">Persistent variables with closures</h3>

<p>Just because a lexical variable is lexically (also called statically) scoped to its enclosing block, <code><code>eval</code></code>, or <code><code>do</code></code> FILE, this doesn&#39;t mean that within a function it works like a C static. It normally works more like a C auto, but with implicit garbage collection.</p>

<p>Unlike local variables in C or C++, Perl&#39;s lexical variables don&#39;t necessarily get recycled just because their scope has exited. If something more permanent is still aware of the lexical, it will stick around. So long as something else references a lexical, that lexical won&#39;t be freed--which is as it should be. You wouldn&#39;t want memory being free until you were done using it, or kept around once you were done. Automatic garbage collection takes care of this for you.</p>

<p>This means that you can pass back or save away references to lexical variables, whereas to return a pointer to a C auto is a grave error. It also gives us a way to simulate C&#39;s function statics. Here&#39;s a mechanism for giving a function private variables with both lexical scoping and a static lifetime. If you do want to create something like C&#39;s static variables, just enclose the whole function in an extra block, and put the static variable outside the function but in the block.</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$secret_val</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
        <span class="keyword">sub</span><span class="variable"> gimme_another </span><span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">++</span><span class="variable">$secret_val</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="comment"># $secret_val now becomes unreachable by the outside</span>
    <span class="comment"># world, but retains its value between calls to gimme_another</span>
</code></code></pre>

<p>If this function is being sourced in from a separate file via <code><code>require</code></code> or <code><code>use</code></code>, then this is probably just fine. If it&#39;s all in the main program, you&#39;ll need to arrange for the <code><code>my</code></code> to be executed early, either by putting the whole block above your main program, or more likely, placing merely a <code><code>BEGIN</code></code> code block around it to make sure it gets executed before your program starts to run:</p>

<pre><code><code>    <span class="keyword">BEGIN</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$secret_val</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
        <span class="keyword">sub</span><span class="variable"> gimme_another </span><span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">++</span><span class="variable">$secret_val</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>See <a href="../../lib/pods/perlmod.html#BEGIN-UNITCHECK-CHECK-INIT-and-END">&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod</a> about the special triggered code blocks, <code><code>BEGIN</code></code>, <code><code>UNITCHECK</code></code>, <code><code>CHECK</code></code>, <code><code>INIT</code></code> and <code><code>END</code></code>.</p>

<p>If declared at the outermost scope (the file scope), then lexicals work somewhat like C&#39;s file statics. They are available to all functions in that same file declared below them, but are inaccessible from outside that file. This strategy is sometimes used in modules to create private variables that the whole module can see.</p>

<h2 id="Temporary-Values-via-local-">Temporary Values via local()     </h2>

<p><b>WARNING</b>: In general, you should be using <code><code>my</code></code> instead of <code><code>local</code></code>, because it&#39;s faster and safer. Exceptions to this include the global punctuation variables, global filehandles and formats, and direct manipulation of the Perl symbol table itself. <code><code>local</code></code> is mostly used when the current value of a variable must be visible to called subroutines.</p>

<p>Synopsis:</p>

<pre><code><code>    <span class="comment"># localization of values</span>
    
    <span class="keyword">local</span> <span class="variable">$foo</span><span class="operator">;</span>                 <span class="comment"># make $foo dynamically local</span>
    <span class="keyword">local</span> <span class="operator">(</span><span class="variable">@wid</span><span class="operator">,</span> <span class="variable">%get</span><span class="operator">);</span>         <span class="comment"># make list of variables local</span>
    <span class="keyword">local</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="string">"flurp"</span><span class="operator">;</span>       <span class="comment"># make $foo dynamic, and init it</span>
    <span class="keyword">local</span> <span class="variable">@oof</span> <span class="operator">=</span> <span class="variable">@bar</span><span class="operator">;</span>          <span class="comment"># make @oof dynamic, and init it</span>
    
    <span class="keyword">local</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"val"</span><span class="operator">;</span>   <span class="comment"># sets a local value for this hash entry</span>
    <span class="keyword">delete</span> <span class="keyword">local</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span><span class="operator">;</span>    <span class="comment"># delete this entry for the current block</span>
    <span class="keyword">local</span> <span class="operator">(</span><span class="variable">$cond</span> <span class="operator">?</span> <span class="variable">$v1</span> <span class="operator">:</span> <span class="variable">$v2</span><span class="operator">);</span>  <span class="comment"># several types of lvalues support</span>
                                <span class="comment"># localization</span>
    
    <span class="comment"># localization of symbols</span>
    
    <span class="keyword">local</span> <span class="variable">*FH</span><span class="operator">;</span>                  <span class="comment"># localize $FH, @FH, %FH, &amp;FH  ...</span>
    <span class="keyword">local</span> <span class="variable">*merlyn</span> <span class="operator">=</span> <span class="variable">*randal</span><span class="operator">;</span>    <span class="comment"># now $merlyn is really $randal, plus</span>
                                <span class="comment">#     @merlyn is really @randal, etc</span>
    <span class="keyword">local</span> <span class="variable">*merlyn</span> <span class="operator">=</span> <span class="string">'randal'</span><span class="operator">;</span>   <span class="comment"># SAME THING: promote 'randal' to *randal</span>
    <span class="keyword">local</span> <span class="variable">*merlyn</span> <span class="operator">=</span> <span class="operator">\</span><span class="variable">$randal</span><span class="operator">;</span>   <span class="comment"># just alias $merlyn, not @merlyn etc</span>
</code></code></pre>

<p>A <code><code>local</code></code> modifies its listed variables to be &quot;local&quot; to the enclosing block, <code><code>eval</code></code>, or <code><code>do FILE</code></code>--and to <i>any subroutine called from within that block</i>. A <code><code>local</code></code> just gives temporary values to global (meaning package) variables. It does <i>not</i> create a local variable. This is known as dynamic scoping. Lexical scoping is done with <code><code>my</code></code>, which works more like C&#39;s auto declarations.</p>

<p>Some types of lvalues can be localized as well: hash and array elements and slices, conditionals (provided that their result is always localizable), and symbolic references. As for simple variables, this creates new, dynamically scoped values.</p>

<p>If more than one variable or expression is given to <code><code>local</code></code>, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval. This means that called subroutines can also reference the local variable, but not the global one. The argument list may be assigned to if desired, which allows you to initialize your local variables. (If no initializer is given for a particular variable, it is created with an undefined value.)</p>

<p>Because <code><code>local</code></code> is a run-time operator, it gets executed each time through a loop. Consequently, it&#39;s more efficient to localize your variables outside the loop.</p>

<h3 id="Grammatical-note-on-local-">Grammatical note on local() </h3>

<p>A <code><code>local</code></code> is simply a modifier on an lvalue expression. When you assign to a <code><code>local</code></code>ized variable, the <code><code>local</code></code> doesn&#39;t change whether its list is viewed as a scalar or an array. So</p>

<pre><code><code>    <span class="keyword">local</span><span class="operator">(</span><span class="variable">$foo</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
    <span class="keyword">local</span> <span class="variable">@FOO</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
</code></code></pre>

<p>both supply a list context to the right-hand side, while</p>

<pre><code><code>    <span class="keyword">local</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">STDIN</span><span class="operator">&gt;;</span>
</code></code></pre>

<p>supplies a scalar context.</p>

<h3 id="Localization-of-special-variables">Localization of special variables </h3>

<p>If you localize a special variable, you&#39;ll be giving a new value to it, but its magic won&#39;t go away. That means that all side-effects related to this magic still work with the localized value.</p>

<p>This feature allows code like this to work :</p>

<pre><code><code>    <span class="comment"># Read the whole contents of FILE in $slurp</span>
    <span class="operator">{</span> <span class="keyword">local</span> <span class="variable">$/</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span> <span class="variable">$slurp</span> <span class="operator">=</span> <span class="operator">&lt;</span><span class="variable">FILE</span><span class="operator">&gt;;</span> <span class="operator">}</span>
</code></code></pre>

<p>Note, however, that this restricts localization of some values ; for example, the following statement dies, as of perl 5.9.0, with an error <i>Modification of a read-only value attempted</i>, because the $1 variable is magical and read-only :</p>

<pre><code><code>    <span class="keyword">local</span> <span class="variable">$1</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span>
</code></code></pre>

<p>One exception is the default scalar variable: starting with perl 5.14 <code><code>local($_)</code></code> will always strip all magic from $_, to make it possible to safely reuse $_ in a subroutine.</p>

<p><b>WARNING</b>: Localization of tied arrays and hashes does not currently work as described. This will be fixed in a future release of Perl; in the meantime, avoid code that relies on any particular behaviour of localising tied arrays or hashes (localising individual elements is still okay). See <a href="../../lib/pods/perl58delta.html#Localising-Tied-Arrays-and-Hashes-Is-Broken">&quot;Localising Tied Arrays and Hashes Is Broken&quot; in perl58delta</a> for more details. </p>

<h3 id="Localization-of-globs">Localization of globs  </h3>

<p>The construct</p>

<pre><code><code>    <span class="keyword">local</span> <span class="variable">*name</span><span class="operator">;</span>
</code></code></pre>

<p>creates a whole new symbol table entry for the glob <code><code>name</code></code> in the current package. That means that all variables in its glob slot ($name, @name, %name, &amp;name, and the <code><code>name</code></code> filehandle) are dynamically reset.</p>

<p>This implies, among other things, that any magic eventually carried by those variables is locally lost. In other words, saying <code><code>local */</code></code> will not have any effect on the internal value of the input record separator.</p>

<h3 id="Localization-of-elements-of-composite-types">Localization of elements of composite types   </h3>

<p>It&#39;s also worth taking a moment to explain what happens when you <code><code>local</code></code>ize a member of a composite type (i.e. an array or hash element). In this case, the element is <code><code>local</code></code>ized <i>by name</i>. This means that when the scope of the <code><code>local()</code></code> ends, the saved value will be restored to the hash element whose key was named in the <code><code>local()</code></code>, or the array element whose index was named in the <code><code>local()</code></code>. If that element was deleted while the <code><code>local()</code></code> was in effect (e.g. by a <code><code>delete()</code></code> from a hash or a <code><code>shift()</code></code> of an array), it will spring back into existence, possibly extending an array and filling in the skipped elements with <code><code>undef</code></code>. For instance, if you say</p>

<pre><code><code>    <span class="variable">%hash</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'This'</span> <span class="operator">=&gt;</span> <span class="string">'is'</span><span class="operator">,</span> <span class="string">'a'</span> <span class="operator">=&gt;</span> <span class="string">'test'</span> <span class="operator">);</span>
    <span class="variable">@ary</span>  <span class="operator">=</span> <span class="operator">(</span> <span class="number">0</span><span class="operator">..</span><span class="number">5</span> <span class="operator">);</span>
    <span class="operator">{</span>
         <span class="keyword">local</span><span class="operator">(</span><span class="variable">$ary</span><span class="operator">[</span><span class="number">5</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">6</span><span class="operator">;</span>
         <span class="keyword">local</span><span class="operator">(</span><span class="variable">$hash</span><span class="operator">{</span><span class="string">'a'</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">=</span> <span class="string">'drill'</span><span class="operator">;</span>
         <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$e</span> <span class="operator">=</span> <span class="keyword">pop</span><span class="operator">(</span><span class="variable">@ary</span><span class="operator">))</span> <span class="operator">{</span>
             <span class="keyword">print</span> <span class="string">"</span><span class="variable">$e</span><span class="string"> . . .\n"</span><span class="operator">;</span>
             <span class="keyword">last</span> <span class="keyword">unless</span> <span class="variable">$e</span> <span class="operator">&gt;</span> <span class="number">3</span><span class="operator">;</span>
         <span class="operator">}</span>
         <span class="keyword">if</span> <span class="operator">(</span><span class="variable">@ary</span><span class="operator">)</span> <span class="operator">{</span>
             <span class="variable">$hash</span><span class="operator">{</span><span class="string">'only a'</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'test'</span><span class="operator">;</span>
             <span class="keyword">delete</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">'a'</span><span class="operator">}</span><span class="operator">;</span>
         <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="keyword">print</span> <span class="keyword">join</span><span class="operator">(</span><span class="string">' '</span><span class="operator">,</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="string">"</span><span class="variable">$_</span><span class="string"> </span><span class="variable">$hash</span><span class="string">{</span><span class="variable">$_</span><span class="string">}"</span> <span class="operator">}</span> <span class="keyword">sort</span> <span class="keyword">keys</span> <span class="variable">%hash</span><span class="operator">),</span><span class="string">".\n"</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"The array has "</span><span class="operator">,</span><span class="keyword">scalar</span><span class="operator">(</span><span class="variable">@ary</span><span class="operator">),</span><span class="string">" elements: "</span><span class="operator">,</span>
          <span class="keyword">join</span><span class="operator">(</span><span class="string">', '</span><span class="operator">,</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="keyword">defined</span> <span class="variable">$_</span> <span class="operator">?</span> <span class="variable">$_</span> <span class="operator">:</span> <span class="string">'undef'</span> <span class="operator">}</span> <span class="variable">@ary</span><span class="operator">),</span><span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>Perl will print</p>

<pre><code><code>    6 . . .
    4 . . .
    3 . . .
    This is a test only a test.
    The array has 6 elements: 0, 1, 2, undef, undef, 5</code></code></pre>

<p>The behavior of local() on non-existent members of composite types is subject to change in future.</p>

<h3 id="Localized-deletion-of-elements-of-composite-types">Localized deletion of elements of composite types    </h3>

<p>You can use the <code><code>delete local $array[$idx]</code></code> and <code><code><span class="keyword">delete</span> <span class="keyword">local</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span>
</code></code> constructs to delete a composite type entry for the current block and restore it when it ends. They return the array/hash value before the localization, which means that they are respectively equivalent to</p>

<pre><code><code>    <span class="keyword">do</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$val</span> <span class="operator">=</span> <span class="variable">$array</span><span class="operator">[</span><span class="variable">$idx</span><span class="operator">]</span><span class="operator">;</span>
        <span class="keyword">local</span>  <span class="variable">$array</span><span class="operator">[</span><span class="variable">$idx</span><span class="operator">]</span><span class="operator">;</span>
        <span class="keyword">delete</span> <span class="variable">$array</span><span class="operator">[</span><span class="variable">$idx</span><span class="operator">]</span><span class="operator">;</span>
        <span class="variable">$val</span>
    <span class="operator">}</span>
</code></code></pre>

<p>and</p>

<pre><code><code>    <span class="keyword">do</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$val</span> <span class="operator">=</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span><span class="operator">;</span>
        <span class="keyword">local</span>  <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span><span class="operator">;</span>
        <span class="keyword">delete</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">key</span><span class="operator">}</span><span class="operator">;</span>
        <span class="variable">$val</span>
    <span class="operator">}</span>
</code></code></pre>

<p>except that for those the <code><code>local</code></code> is scoped to the <code><code>do</code></code> block. Slices are also accepted.</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">%hash</span> <span class="operator">=</span> <span class="operator">(</span>
     <span class="string">a</span> <span class="operator">=&gt;</span> <span class="operator">[</span> <span class="number">7</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="number">9</span> <span class="operator">]</span><span class="operator">,</span>
     <span class="string">b</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
    <span class="operator">)</span>
    
    <span class="operator">{</span>
     <span class="keyword">my</span> <span class="variable">$a</span> <span class="operator">=</span> <span class="keyword">delete</span> <span class="keyword">local</span> <span class="variable">$hash</span><span class="operator">{</span><span class="string">a</span><span class="operator">}</span><span class="operator">;</span>
     <span class="comment"># $a is [ 7, 8, 9 ]</span>
     <span class="comment"># %hash is (b =&gt; 1)</span>
    
     <span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">@nums</span> <span class="operator">=</span> <span class="keyword">delete</span> <span class="keyword">local</span> <span class="variable">@$a</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span> <span class="number">2</span><span class="operator">]</span>
      <span class="comment"># @nums is (7, 9)</span>
      <span class="comment"># $a is [ undef, 8 ]</span>
    
      <span class="variable">$a</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">999</span><span class="operator">;</span> <span class="comment"># will be erased when the scope ends</span>
     <span class="operator">}</span>
     <span class="comment"># $a is back to [ 7, 8, 9 ]</span>
    
    <span class="operator">}</span>
    <span class="comment"># %hash is back to its original state</span>
</code></code></pre>

<h2 id="Lvalue-subroutines">Lvalue subroutines  </h2>

<p><b>WARNING</b>: Lvalue subroutines are still experimental and the implementation may change in future versions of Perl.</p>

<p>It is possible to return a modifiable value from a subroutine. To do this, you have to declare the subroutine to return an lvalue.</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$val</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> canmod : lvalue </span><span class="operator">{</span>
        <span class="variable">$val</span><span class="operator">;</span>  <span class="comment"># or:  return $val;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> nomod </span><span class="operator">{</span>
        <span class="variable">$val</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="variable">canmod</span><span class="operator">()</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>   <span class="comment"># assigns to $val</span>
    <span class="variable">nomod</span><span class="operator">()</span>  <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>   <span class="comment"># ERROR</span>
</code></code></pre>

<p>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</p>

<pre><code><code>    <span class="variable">data</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">get_data</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">);</span>
</code></code></pre>

<p>Both subroutines here are called in a scalar context, while in:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">data</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">))</span> <span class="operator">=</span> <span class="variable">get_data</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">);</span>
</code></code></pre>

<p>and in:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">data</span><span class="operator">(</span><span class="number">2</span><span class="operator">),</span><span class="variable">data</span><span class="operator">(</span><span class="number">3</span><span class="operator">))</span> <span class="operator">=</span> <span class="variable">get_data</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">);</span>
</code></code></pre>

<p>all the subroutines are called in a list context.</p>

<dl>

<dt id="Lvalue-subroutines-are-EXPERIMENTAL">Lvalue subroutines are EXPERIMENTAL</dt>
<dd>

<p>They appear to be convenient, but there is at least one reason to be circumspect.</p>

<p>They violate encapsulation. A normal mutator can check the supplied argument before setting the attribute it is protecting, an lvalue subroutine never gets that chance. Consider;</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$some_array_ref</span> <span class="operator">=</span> <span class="operator">[]</span><span class="operator">;</span>    <span class="comment"># protected by mutators ??</span>
    
    <span class="keyword">sub</span><span class="variable"> set_arr </span><span class="operator">{</span>               <span class="comment"># normal mutator</span>
        <span class="keyword">my</span> <span class="variable">$val</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">die</span><span class="operator">(</span><span class="string">"expected array, you supplied "</span><span class="operator">,</span> <span class="keyword">ref</span> <span class="variable">$val</span><span class="operator">)</span>
           <span class="keyword">unless</span> <span class="keyword">ref</span> <span class="variable">$val</span> <span class="keyword">eq</span> <span class="string">'ARRAY'</span><span class="operator">;</span>
        <span class="variable">$some_array_ref</span> <span class="operator">=</span> <span class="variable">$val</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> set_arr_lv : lvalue </span><span class="operator">{</span>   <span class="comment"># lvalue mutator</span>
        <span class="variable">$some_array_ref</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="comment"># set_arr_lv cannot stop this !</span>
    <span class="variable">set_arr_lv</span><span class="operator">()</span> <span class="operator">=</span> <span class="operator">{</span> <span class="string">a</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

</dd>
</dl>

<h2 id="Passing-Symbol-Table-Entries-typeglobs-">Passing Symbol Table Entries (typeglobs)  </h2>

<p><b>WARNING</b>: The mechanism described in this section was originally the only way to simulate pass-by-reference in older versions of Perl. While it still works fine in modern versions, the new reference mechanism is generally easier to work with. See below.</p>

<p>Sometimes you don&#39;t want to pass the value of an array to a subroutine but rather the name of it, so that the subroutine can modify the global copy of it rather than working with a local copy. In perl you can refer to all objects of a particular name by prefixing the name with a star: <code><code>*foo</code></code>. This is often known as a &quot;typeglob&quot;, because the star on the front can be thought of as a wildcard match for all the funny prefix characters on variables and subroutines and such.</p>

<p>When evaluated, the typeglob produces a scalar value that represents all the objects of that name, including any filehandle, format, or subroutine. When assigned to, it causes the name mentioned to refer to whatever <code><code>*</code></code> value was assigned to it. Example:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> doubleary </span><span class="operator">{</span>
        <span class="keyword">local</span><span class="operator">(</span><span class="variable">*someary</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">foreach</span> <span class="variable">$elem</span> <span class="operator">(</span><span class="variable">@someary</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="variable">$elem</span> <span class="operator">*=</span> <span class="number">2</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="variable">doubleary</span><span class="operator">(</span><span class="variable">*foo</span><span class="operator">);</span>
    <span class="variable">doubleary</span><span class="operator">(</span><span class="variable">*bar</span><span class="operator">);</span>
</code></code></pre>

<p>Scalars are already passed by reference, so you can modify scalar arguments without using this mechanism by referring explicitly to <code><code>$_[0]</code></code> etc. You can modify all the elements of an array by passing all the elements as scalars, but you have to use the <code><code>*</code></code> mechanism (or the equivalent reference mechanism) to <code><code>push</code></code>, <code><code>pop</code></code>, or change the size of an array. It will certainly be faster to pass the typeglob (or reference).</p>

<p>Even if you don&#39;t want to modify an array, this mechanism is useful for passing multiple arrays in a single LIST, because normally the LIST mechanism will merge all the array values so that you can&#39;t extract out the individual arrays. For more on typeglobs, see <a href="../../lib/pods/perldata.html#Typeglobs-and-Filehandles">&quot;Typeglobs and Filehandles&quot; in perldata</a>.</p>

<h2 id="When-to-Still-Use-local-">When to Still Use local()  </h2>

<p>Despite the existence of <code><code>my</code></code>, there are still three places where the <code><code>local</code></code> operator still shines. In fact, in these three places, you <i>must</i> use <code><code>local</code></code> instead of <code><code>my</code></code>.</p>

<ol>

<li><p>You need to give a global variable a temporary value, especially $_.</p>

<p>The global variables, like <code><code>@ARGV</code></code> or the punctuation variables, must be <code><code>local</code></code>ized with <code><code>local()</code></code>. This block reads in <i>/etc/motd</i>, and splits it up into chunks separated by lines of equal signs, which are placed in <code><code>@Fields</code></code>.</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">@ARGV</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">"/etc/motd"</span><span class="operator">);</span>
        <span class="keyword">local</span> <span class="variable">$/</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span>
        <span class="keyword">local</span> <span class="variable">$_</span> <span class="operator">=</span> <span class="operator">&lt;&gt;;</span>  
        <span class="variable">@Fields</span> <span class="operator">=</span> <span class="keyword">split</span> <span class="regex">/^\s*=+\s*$/</span><span class="operator">;</span>
    <span class="operator">}</span> 
</code></code></pre>

<p>It particular, it&#39;s important to <code><code>local</code></code>ize $_ in any routine that assigns to it. Look out for implicit assignments in <code><code>while</code></code> conditionals.</p>

</li>
<li><p>You need to create a local file or directory handle or a local function.</p>

<p>A function that needs a filehandle of its own must use <code><code>local()</code></code> on a complete typeglob. This can be used to create new symbol table entries:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> ioqueue </span><span class="operator">{</span>
        <span class="keyword">local</span>  <span class="operator">(</span><span class="variable">*READER</span><span class="operator">,</span> <span class="variable">*WRITER</span><span class="operator">);</span>    <span class="comment"># not my!</span>
        <span class="keyword">pipe</span>    <span class="operator">(</span><span class="variable">READER</span><span class="operator">,</span>  <span class="variable">WRITER</span><span class="operator">)</span>     <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"pipe: $!"</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="operator">(</span><span class="variable">*READER</span><span class="operator">,</span> <span class="variable">*WRITER</span><span class="operator">);</span>
    <span class="operator">}</span>
    <span class="operator">(</span><span class="variable">$head</span><span class="operator">,</span> <span class="variable">$tail</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">ioqueue</span><span class="operator">();</span>
</code></code></pre>

<p>See the Symbol module for a way to create anonymous symbol table entries.</p>

<p>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">*grow</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">shrink</span><span class="operator">;</span> <span class="comment"># only until this block exits</span>
        <span class="variable">grow</span><span class="operator">();</span>                 <span class="comment"># really calls shrink()</span>
        <span class="variable">move</span><span class="operator">();</span>                 <span class="comment"># if move() grow()s, it shrink()s too</span>
    <span class="operator">}</span>
    <span class="variable">grow</span><span class="operator">();</span>                     <span class="comment"># get the real grow() again</span>
</code></code></pre>

<p>See <a href="../../lib/pods/perlref.html#Function-Templates">&quot;Function Templates&quot; in perlref</a> for more about manipulating functions by name in this way.</p>

</li>
<li><p>You want to temporarily change just one element of an array or hash.</p>

<p>You can <code><code>local</code></code>ize just one element of an aggregate. Usually this is done on dynamics:</p>

<pre><code><code>    <span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">$SIG</span><span class="operator">{</span><span class="string">INT</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'IGNORE'</span><span class="operator">;</span>
        <span class="variable">funct</span><span class="operator">();</span>                            <span class="comment"># uninterruptible</span>
    <span class="operator">}</span> 
    <span class="comment"># interruptibility automatically restored here</span>
</code></code></pre>

<p>But it also works on lexically declared aggregates. Prior to 5.005, this operation could on occasion misbehave.</p>

</li>
</ol>

<h2 id="Pass-by-Reference">Pass by Reference   </h2>

<p>If you want to pass more than one array or hash into a function--or return them from it--and have them maintain their integrity, then you&#39;re going to have to use an explicit pass-by-reference. Before you do that, you need to understand references as detailed in <a href="../../lib/pods/perlref.html">perlref</a>. This section may not make much sense to you otherwise.</p>

<p>Here are a few simple examples. First, let&#39;s pass in several arrays to a function and have it <code><code>pop</code></code> all of then, returning a new list of all their former last elements:</p>

<pre><code><code>    <span class="variable">@tailings</span> <span class="operator">=</span> <span class="variable">popmany</span> <span class="operator">(</span> <span class="operator">\</span><span class="variable">@a</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@b</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@c</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@d</span> <span class="operator">);</span>
    
    <span class="keyword">sub</span><span class="variable"> popmany </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$aref</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@retlist</span> <span class="operator">=</span> <span class="operator">();</span>
        <span class="keyword">foreach</span> <span class="variable">$aref</span> <span class="operator">(</span> <span class="variable">@_</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">push</span> <span class="variable">@retlist</span><span class="operator">,</span> <span class="keyword">pop</span> <span class="variable">@$aref</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">@retlist</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Here&#39;s how you might write a function that returns a list of keys occurring in all the hashes passed to it:</p>

<pre><code><code>    <span class="variable">@common</span> <span class="operator">=</span> <span class="variable">inter</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">%foo</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%bar</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%joe</span> <span class="operator">);</span>
    <span class="keyword">sub</span><span class="variable"> inter </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$k</span><span class="operator">,</span> <span class="variable">$href</span><span class="operator">,</span> <span class="variable">%seen</span><span class="operator">);</span> <span class="comment"># locals</span>
        <span class="keyword">foreach</span> <span class="variable">$href</span> <span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">while</span> <span class="operator">(</span> <span class="variable">$k</span> <span class="operator">=</span> <span class="keyword">each</span> <span class="variable">%$href</span> <span class="operator">)</span> <span class="operator">{</span>
                <span class="variable">$seen</span><span class="operator">{</span><span class="variable">$k</span><span class="operator">}</span><span class="operator">++;</span>
            <span class="operator">}</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="keyword">grep</span> <span class="operator">{</span> <span class="variable">$seen</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">==</span> <span class="variable">@_</span> <span class="operator">}</span> <span class="keyword">keys</span> <span class="variable">%seen</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>So far, we&#39;re using just the normal list return mechanism. What happens if you want to pass or return a hash? Well, if you&#39;re using only one of them, or you don&#39;t mind them concatenating, then the normal calling convention is ok, although a little expensive.</p>

<p>Where people get into trouble is here:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">@a</span><span class="operator">,</span> <span class="variable">@b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">func</span><span class="operator">(</span><span class="variable">@c</span><span class="operator">,</span> <span class="variable">@d</span><span class="operator">);</span>
    <span class="keyword">or</span>
    <span class="operator">(</span><span class="variable">%a</span><span class="operator">,</span> <span class="variable">%b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">func</span><span class="operator">(</span><span class="variable">%c</span><span class="operator">,</span> <span class="variable">%d</span><span class="operator">);</span>
</code></code></pre>

<p>That syntax simply won&#39;t work. It sets just <code><code>@a</code></code> or <code><code>%a</code></code> and clears the <code><code>@b</code></code> or <code><code>%b</code></code>. Plus the function didn&#39;t get passed into two separate arrays or hashes: it got one long list in <code><code>@_</code></code>, as always.</p>

<p>If you can arrange for everyone to deal with this through references, it&#39;s cleaner code, although not so nice to look at. Here&#39;s a function that takes two array references as arguments, returning the two array elements in order of how many elements they have in them:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">$aref</span><span class="operator">,</span> <span class="variable">$bref</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">func</span><span class="operator">(\</span><span class="variable">@c</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@d</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"@</span><span class="variable">$aref</span><span class="string"> has more than @</span><span class="variable">$bref</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> func </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$cref</span><span class="operator">,</span> <span class="variable">$dref</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">@$cref</span> <span class="operator">&gt;</span> <span class="variable">@$dref</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">(</span><span class="variable">$cref</span><span class="operator">,</span> <span class="variable">$dref</span><span class="operator">);</span>
        <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">(</span><span class="variable">$dref</span><span class="operator">,</span> <span class="variable">$cref</span><span class="operator">);</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>It turns out that you can actually do this also:</p>

<pre><code><code>    <span class="operator">(</span><span class="variable">*a</span><span class="operator">,</span> <span class="variable">*b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">func</span><span class="operator">(\</span><span class="variable">@c</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@d</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">@a</span><span class="string"> has more than </span><span class="variable">@b</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> func </span><span class="operator">{</span>
        <span class="keyword">local</span> <span class="operator">(</span><span class="variable">*c</span><span class="operator">,</span> <span class="variable">*d</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">@c</span> <span class="operator">&gt;</span> <span class="variable">@d</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">(\</span><span class="variable">@c</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@d</span><span class="operator">);</span>
        <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="operator">(\</span><span class="variable">@d</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@c</span><span class="operator">);</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Here we&#39;re using the typeglobs to do symbol table aliasing. It&#39;s a tad subtle, though, and also won&#39;t work if you&#39;re using <code><code>my</code></code> variables, because only globals (even in disguise as <code><code>local</code></code>s) are in the symbol table.</p>

<p>If you&#39;re passing around filehandles, you could usually just use the bare typeglob, like <code><code>*STDOUT</code></code>, but typeglobs references work, too. For example:</p>

<pre><code><code>    <span class="variable">splutter</span><span class="operator">(\</span><span class="variable">*STDOUT</span><span class="operator">);</span>
    <span class="keyword">sub</span><span class="variable"> splutter </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$fh</span> <span class="string">"her um well a hmmm\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="variable">$rec</span> <span class="operator">=</span> <span class="variable">get_rec</span><span class="operator">(\</span><span class="variable">*STDIN</span><span class="operator">);</span>
    <span class="keyword">sub</span><span class="variable"> get_rec </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="keyword">scalar</span> <span class="operator">&lt;</span><span class="variable">$fh</span><span class="operator">&gt;;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>If you&#39;re planning on generating new filehandles, you could do this. Notice to pass back just the bare *FH, not its reference.</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> openit </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$path</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">local</span> <span class="variable">*FH</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="keyword">open</span> <span class="operator">(</span><span class="variable">FH</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">)</span> <span class="operator">?</span> <span class="variable">*FH</span> <span class="operator">:</span> <span class="keyword">undef</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="Prototypes">Prototypes  </h2>

<p>Perl supports a very limited kind of compile-time argument checking using function prototyping. If you declare</p>

<pre><code><code>    sub mypush (+@)</code></code></pre>

<p>then <code><code>mypush()</code></code> takes arguments exactly like <code><code>push()</code></code> does. The function declaration must be visible at compile time. The prototype affects only interpretation of new-style calls to the function, where new-style is defined as not using the <code><code>&amp;</code></code> character. In other words, if you call it like a built-in function, then it behaves like a built-in function. If you call it like an old-fashioned subroutine, then it behaves like an old-fashioned subroutine. It naturally falls out from this rule that prototypes have no influence on subroutine references like <code><code>\&amp;foo</code></code> or on indirect subroutine calls like <code><code><span class="operator">&amp;{</span><span class="variable">$subref</span><span class="operator">}</span>
</code></code> or <code><code>$subref-&gt;()</code></code>.</p>

<p>Method calls are not influenced by prototypes either, because the function to be called is indeterminate at compile time, since the exact code called depends on inheritance.</p>

<p>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</p>

<pre><code><code>    <span class="variable">Declared</span> <span class="variable">as</span>                 <span class="variable">Called</span> <span class="variable">as</span>
    
    <span class="keyword">sub</span><span class="variable"> mylink </span><span class="operator">(</span>$$<span class="operator">)</span>          <span class="variable">mylink</span> <span class="variable">$old</span><span class="operator">,</span> <span class="variable">$new</span>
    <span class="keyword">sub</span><span class="variable"> myvec </span><span class="operator">(</span>$$$<span class="operator">)</span>          <span class="variable">myvec</span> <span class="variable">$var</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="number">1</span>
    <span class="keyword">sub</span><span class="variable"> myindex </span><span class="operator">(</span>$$;$<span class="operator">)</span>       <span class="variable">myindex</span> <span class="operator">&amp;</span><span class="variable">getstring</span><span class="operator">,</span> <span class="string">"substr"</span>
    <span class="keyword">sub</span><span class="variable"> mysyswrite </span><span class="operator">(</span>$$$;$<span class="operator">)</span>   <span class="variable">mysyswrite</span> <span class="variable">$buf</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="keyword">length</span><span class="operator">(</span><span class="variable">$buf</span><span class="operator">)</span> <span class="operator">-</span> <span class="variable">$off</span><span class="operator">,</span> <span class="variable">$off</span>
    <span class="keyword">sub</span><span class="variable"> myreverse </span><span class="operator">(</span>@<span class="operator">)</span>        <span class="variable">myreverse</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">,</span> <span class="variable">$c</span>
    <span class="keyword">sub</span><span class="variable"> myjoin </span><span class="operator">(</span>$@<span class="operator">)</span>          <span class="variable">myjoin</span> <span class="string">":"</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">,</span> <span class="variable">$c</span>
    <span class="keyword">sub</span><span class="variable"> mypop </span><span class="operator">(</span>+<span class="operator">)</span>            <span class="variable">mypop</span> <span class="variable">@array</span>
    <span class="keyword">sub</span><span class="variable"> mysplice </span><span class="operator">(</span>+$$@<span class="operator">)</span>      <span class="variable">mysplice</span> <span class="variable">@array</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">2</span><span class="operator">,</span> <span class="variable">@pushme</span>
    <span class="keyword">sub</span><span class="variable"> mykeys </span><span class="operator">(</span>+<span class="operator">)</span>           <span class="variable">mykeys</span> <span class="variable">%</span><span class="operator">{</span><span class="variable">$hashref</span><span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> myopen </span><span class="operator">(</span>*;$<span class="operator">)</span>         <span class="variable">myopen</span> <span class="variable">HANDLE</span><span class="operator">,</span> <span class="variable">$name</span>
    <span class="keyword">sub</span><span class="variable"> mypipe </span><span class="operator">(</span>**<span class="operator">)</span>          <span class="variable">mypipe</span> <span class="variable">READHANDLE</span><span class="operator">,</span> <span class="variable">WRITEHANDLE</span>
    <span class="keyword">sub</span><span class="variable"> mygrep </span><span class="operator">(</span>&amp;@<span class="operator">)</span>          <span class="variable">mygrep</span> <span class="operator">{</span> <span class="regex">/foo/</span> <span class="operator">}</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">,</span> <span class="variable">$c</span>
    <span class="keyword">sub</span><span class="variable"> myrand </span><span class="operator">(</span>;$<span class="operator">)</span>          <span class="variable">myrand</span> <span class="number">42</span>
    <span class="keyword">sub</span><span class="variable"> mytime </span><span class="operator">()</span>            <span class="variable">mytime</span>
</code></code></pre>

<p>Any backslashed prototype character represents an actual argument that must start with that character (optionally preceded by <code><code>my</code></code>, <code><code>our</code></code> or <code><code>local</code></code>), with the exception of <code><code>$</code></code>, which will accept any scalar lvalue expression, such as <code><code>$foo = 7</code></code> or <code><code>my_function()-&gt;[0]</code></code>. The value passed as part of <code><code>@_</code></code> will be a reference to the actual argument given in the subroutine call, obtained by applying <code><code>\</code></code> to that argument.</p>

<p>You can use the <code><code>\[]</code></code> backslash group notation to specify more than one allowed argument type. For example:</p>

<pre><code><code>    sub myref (\[$@%&amp;*])</code></code></pre>

<p>will allow calling myref() as</p>

<pre><code><code>    myref $var
    myref @array
    myref %hash
    myref &amp;sub
    myref *glob</code></code></pre>

<p>and the first argument of myref() will be a reference to a scalar, an array, a hash, a code, or a glob.</p>

<p>Unbackslashed prototype characters have special meanings. Any unbackslashed <code><code>@</code></code> or <code><code>%</code></code> eats all remaining arguments, and forces list context. An argument represented by <code><code>$</code></code> forces scalar context. An <code><code>&amp;</code></code> requires an anonymous subroutine, which, if passed as the first argument, does not require the <code><code>sub</code></code> keyword or a subsequent comma.</p>

<p>A <code><code>*</code></code> allows the subroutine to accept a bareword, constant, scalar expression, typeglob, or a reference to a typeglob in that slot. The value will be available to the subroutine either as a simple scalar, or (in the latter two cases) as a reference to the typeglob. If you wish to always convert such arguments to a typeglob reference, use Symbol::qualify_to_ref() as follows:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Symbol</span> <span class="string">'qualify_to_ref'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> foo </span><span class="operator">(</span>*<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$fh</span> <span class="operator">=</span> <span class="variable">qualify_to_ref</span><span class="operator">(</span><span class="keyword">shift</span><span class="operator">,</span> <span class="keyword">caller</span><span class="operator">);</span>
        <span class="operator">...</span>
    <span class="operator">}</span>
</code></code></pre>

<p>The <code><code>+</code></code> prototype is a special alternative to <code><code>$</code></code> that will act like <code><code>\[@%]</code></code> when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> mypush </span><span class="operator">(</span>+@<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$aref</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">die</span> <span class="string">"Not an array or arrayref"</span> <span class="keyword">unless</span> <span class="keyword">ref</span> <span class="variable">$aref</span> <span class="keyword">eq</span> <span class="string">'ARRAY'</span><span class="operator">;</span>
        <span class="keyword">push</span> <span class="variable">@$aref</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>When using the <code><code>+</code></code> prototype, your function must check that the argument is of an acceptable type.</p>

<p>A semicolon (<code><code><span class="operator">;</span>
</code></code>) separates mandatory arguments from optional arguments. It is redundant before <code><code>@</code></code> or <code><code>%</code></code>, which gobble up everything else.</p>

<p>As the last character of a prototype, or just before a semicolon, a <code><code>@</code></code> or a <code><code>%</code></code>, you can use <code><code>_</code></code> in place of <code><code>$</code></code>: if this argument is not provided, <code><code>$_</code></code> will be used instead.</p>

<p>Note how the last three examples in the table above are treated specially by the parser. <code><code>mygrep()</code></code> is parsed as a true list operator, <code><code>myrand()</code></code> is parsed as a true unary operator with unary precedence the same as <code><code>rand()</code></code>, and <code><code>mytime()</code></code> is truly without arguments, just like <code><code>time()</code></code>. That is, if you say</p>

<pre><code><code>    <span class="variable">mytime</span> <span class="operator">+</span><span class="number">2</span><span class="operator">;</span>
</code></code></pre>

<p>you&#39;ll get <code><code>mytime() + 2</code></code>, not <code><code>mytime(2)</code></code>, which is how it would be parsed without a prototype. If you want to force a unary function to have the same precedence as a list operator, add <code><code><span class="operator">;</span>
</code></code> to the end of the prototype:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> mygetprotobynumber</span><span class="operator">(</span>$;<span class="operator">);</span>
    <span class="variable">mygetprotobynumber</span> <span class="variable">$a</span> <span class="operator">&gt;</span> <span class="variable">$b</span><span class="operator">;</span> <span class="comment"># parsed as mygetprotobynumber($a &gt; $b)</span>
</code></code></pre>

<p>The interesting thing about <code><code>&amp;</code></code> is that you can generate new syntax with it, provided it&#39;s in the initial position: </p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> try </span><span class="operator">(</span>&amp;@<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$try</span><span class="operator">,</span><span class="variable">$catch</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">eval</span> <span class="operator">{</span> <span class="operator">&amp;</span><span class="variable">$try</span> <span class="operator">};</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$@</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">local</span> <span class="variable">$_</span> <span class="operator">=</span> <span class="variable">$@</span><span class="operator">;</span>
            <span class="operator">&amp;</span><span class="variable">$catch</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> catch </span><span class="operator">(</span>&amp;<span class="operator">)</span> <span class="operator">{</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">}</span>
    
    <span class="variable">try</span> <span class="operator">{</span>
        <span class="keyword">die</span> <span class="string">"phooey"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="variable">catch</span> <span class="operator">{</span>
        <span class="regex">/phooey/</span> <span class="keyword">and</span> <span class="keyword">print</span> <span class="string">"unphooey\n"</span><span class="operator">;</span>
    <span class="operator">};</span>
</code></code></pre>

<p>That prints <code><code>&quot;unphooey&quot;</code></code>. (Yes, there are still unresolved issues having to do with visibility of <code><code>@_</code></code>. I&#39;m ignoring that question for the moment. (But note that if we make <code><code>@_</code></code> lexically scoped, those anonymous subroutines can act like closures... (Gee, is this sounding a little Lispish? (Never mind.))))</p>

<p>And here&#39;s a reimplementation of the Perl <code><code>grep</code></code> operator: </p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> mygrep </span><span class="operator">(</span>&amp;@<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$code</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@result</span><span class="operator">;</span>
        <span class="keyword">foreach</span> <span class="variable">$_</span> <span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">push</span><span class="operator">(</span><span class="variable">@result</span><span class="operator">,</span> <span class="variable">$_</span><span class="operator">)</span> <span class="keyword">if</span> <span class="operator">&amp;</span><span class="variable">$code</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="variable">@result</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Some folks would prefer full alphanumeric prototypes. Alphanumerics have been intentionally left out of prototypes for the express purpose of someday in the future adding named, formal parameters. The current mechanism&#39;s main goal is to let module writers provide better diagnostics for module users. Larry feels the notation quite understandable to Perl programmers, and that it will not intrude greatly upon the meat of the module, nor make it harder to read. The line noise is visually encapsulated into a small pill that&#39;s easy to swallow.</p>

<p>If you try to use an alphanumeric sequence in a prototype you will generate an optional warning - &quot;Illegal character in prototype...&quot;. Unfortunately earlier versions of Perl allowed the prototype to be used as long as its prefix was a valid prototype. The warning may be upgraded to a fatal error in a future version of Perl once the majority of offending code is fixed.</p>

<p>It&#39;s probably best to prototype new functions, not retrofit prototyping into older ones. That&#39;s because you must be especially careful about silent impositions of differing list versus scalar contexts. For example, if you decide that a function should take just one parameter, like this:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> func </span><span class="operator">(</span>$<span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$n</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"you gave me </span><span class="variable">$n</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>and someone has been calling it with an array or expression returning a list:</p>

<pre><code><code>    <span class="variable">func</span><span class="operator">(</span><span class="variable">@foo</span><span class="operator">);</span>
    <span class="variable">func</span><span class="operator">(</span> <span class="keyword">split</span> <span class="regex">/:/</span> <span class="operator">);</span>
</code></code></pre>

<p>Then you&#39;ve just supplied an automatic <code><code>scalar</code></code> in front of their argument, which can be more than a bit surprising. The old <code><code>@foo</code></code> which used to hold one thing doesn&#39;t get passed in. Instead, <code><code>func()</code></code> now gets passed in a <code><code>1</code></code>; that is, the number of elements in <code><code>@foo</code></code>. And the <code><code>split</code></code> gets called in scalar context so it starts scribbling on your <code><code>@_</code></code> parameter list. Ouch!</p>

<p>This is all very powerful, of course, and should be used only in moderation to make the world a better place.</p>

<h2 id="Constant-Functions">Constant Functions </h2>

<p>Functions with a prototype of <code><code>()</code></code> are potential candidates for inlining. If the result after optimization and constant folding is either a constant or a lexically-scoped scalar which has no other references, then it will be used in place of function calls made without <code><code>&amp;</code></code>. Calls made using <code><code>&amp;</code></code> are never inlined. (See <i>constant.pm</i> for an easy way to declare most constants.)</p>

<p>The following functions would all be inlined:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> pi </span><span class="operator">()</span>           <span class="operator">{</span> <span class="number">3.14159</span> <span class="operator">}</span>             <span class="comment"># Not exact, but close.</span>
    <span class="keyword">sub</span><span class="variable"> PI </span><span class="operator">()</span>           <span class="operator">{</span> <span class="number">4</span> <span class="operator">*</span> <span class="keyword">atan2</span> <span class="number">1</span><span class="operator">,</span> <span class="number">1</span> <span class="operator">}</span>      <span class="comment"># As good as it gets,</span>
                                                <span class="comment"># and it's inlined, too!</span>
    <span class="keyword">sub</span><span class="variable"> ST_DEV </span><span class="operator">()</span>       <span class="operator">{</span> <span class="number">0</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> ST_INO </span><span class="operator">()</span>       <span class="operator">{</span> <span class="number">1</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> FLAG_FOO </span><span class="operator">()</span>     <span class="operator">{</span> <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">8</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> FLAG_BAR </span><span class="operator">()</span>     <span class="operator">{</span> <span class="number">1</span> <span class="operator">&lt;&lt;</span> <span class="number">9</span> <span class="operator">}</span>
    <span class="keyword">sub</span><span class="variable"> FLAG_MASK </span><span class="operator">()</span>    <span class="operator">{</span> <span class="variable">FLAG_FOO</span> <span class="operator">|</span> <span class="variable">FLAG_BAR</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> OPT_BAZ </span><span class="operator">()</span>      <span class="operator">{</span> <span class="keyword">not</span> <span class="operator">(</span><span class="number">0x1B58</span> <span class="operator">&amp;</span> <span class="variable">FLAG_MASK</span><span class="operator">)</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> N </span><span class="operator">()</span> <span class="operator">{</span> <span class="keyword">int</span><span class="operator">(</span><span class="variable">OPT_BAZ</span><span class="operator">)</span> <span class="operator">/</span> <span class="number">3</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> FOO_SET </span><span class="operator">()</span> <span class="operator">{</span> <span class="number">1</span> <span class="keyword">if</span> <span class="variable">FLAG_MASK</span> <span class="operator">&amp;</span> <span class="variable">FLAG_FOO</span> <span class="operator">}</span>
</code></code></pre>

<p>Be aware that these will not be inlined; as they contain inner scopes, the constant folding doesn&#39;t reduce them to a single constant:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> foo_set </span><span class="operator">()</span> <span class="operator">{</span> <span class="keyword">if</span> <span class="operator">(</span><span class="variable">FLAG_MASK</span> <span class="operator">&amp;</span> <span class="variable">FLAG_FOO</span><span class="operator">)</span> <span class="operator">{</span> <span class="number">1</span> <span class="operator">}</span> <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> baz_val </span><span class="operator">()</span> <span class="operator">{</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="variable">OPT_BAZ</span><span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="number">23</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">else</span> <span class="operator">{</span>
            <span class="keyword">return</span> <span class="number">42</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>If you redefine a subroutine that was eligible for inlining, you&#39;ll get a warning by default. (You can use this warning to tell whether or not a particular subroutine is considered constant.) The warning is considered severe enough not to be affected by the <b>-w</b> switch (or its absence) because previously compiled invocations of the function will still be using the old value of the function. If you need to be able to redefine the subroutine, you need to ensure that it isn&#39;t inlined, either by dropping the <code><code>()</code></code> prototype (which changes calling semantics, so beware) or by thwarting the inlining mechanism in some other way, such as</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> not_inlined </span><span class="operator">()</span> <span class="operator">{</span>
        <span class="number">23</span> <span class="keyword">if</span> <span class="variable">$]</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="Overriding-Built-in-Functions">Overriding Built-in Functions    </h2>

<p>Many built-in functions may be overridden, though this should be tried only occasionally and for good reason. Typically this might be done by a package attempting to emulate missing built-in functionality on a non-Unix system.</p>

<p>Overriding may be done only by importing the name from a module at compile time--ordinary predeclaration isn&#39;t good enough. However, the <code><code>use subs</code></code> pragma lets you, in effect, predeclare subs via the import syntax, and these names may then override built-in ones:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">subs</span> <span class="string">'chdir'</span><span class="operator">,</span> <span class="string">'chroot'</span><span class="operator">,</span> <span class="string">'chmod'</span><span class="operator">,</span> <span class="string">'chown'</span><span class="operator">;</span>
    <span class="keyword">chdir</span> <span class="variable">$somewhere</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> chdir </span><span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</code></code></pre>

<p>To unambiguously refer to the built-in form, precede the built-in name with the special package qualifier <code><code>CORE::</code></code>. For example, saying <code><code>CORE::open()</code></code> always refers to the built-in <code><code>open()</code></code>, even if the current package has imported some other subroutine called <code><code>&amp;open()</code></code> from elsewhere. Even though it looks like a regular function call, it isn&#39;t: the CORE:: prefix in that case is part of Perl&#39;s syntax, and works for any keyword, regardless of what is in the CORE package. Taking a reference to it, that is, <code><code>\&amp;CORE::open</code></code>, only works for some keywords. See <a href="../../lib/CORE.html">CORE</a>.</p>

<p>Library modules should not in general export built-in names like <code><code>open</code></code> or <code><code>chdir</code></code> as part of their default <code><code>@EXPORT</code></code> list, because these may sneak into someone else&#39;s namespace and change the semantics unexpectedly. Instead, if the module adds that name to <code><code>@EXPORT_OK</code></code>, then it&#39;s possible for a user to import the name explicitly, but not implicitly. That is, they could say</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Module</span> <span class="string">'open'</span><span class="operator">;</span>
</code></code></pre>

<p>and it would import the <code><code>open</code></code> override. But if they said</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Module</span><span class="operator">;</span>
</code></code></pre>

<p>they would get the default imports without overrides.</p>

<p>The foregoing mechanism for overriding built-in is restricted, quite deliberately, to the package that requests the import. There is a second method that is sometimes applicable when you wish to override a built-in everywhere, without regard to namespace boundaries. This is achieved by importing a sub into the special namespace <code><code>CORE::GLOBAL::</code></code>. Here is an example that quite brazenly replaces the <code><code>glob</code></code> operator with something that understands regular expressions.</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">REGlob</span><span class="operator">;</span>
    <span class="keyword">require</span> <span class="variable">Exporter</span><span class="operator">;</span>
    <span class="variable">@ISA</span> <span class="operator">=</span> <span class="string">'Exporter'</span><span class="operator">;</span>
    <span class="variable">@EXPORT_OK</span> <span class="operator">=</span> <span class="string">'glob'</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> import </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$pkg</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="keyword">unless</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$sym</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$where</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$sym</span> <span class="operator">=~</span> <span class="regex">s/^GLOBAL_//</span> <span class="operator">?</span> <span class="string">'CORE::GLOBAL'</span> <span class="operator">:</span> <span class="keyword">caller</span><span class="operator">(</span><span class="number">0</span><span class="operator">));</span>
        <span class="variable">$pkg</span><span class="operator">-&gt;</span><span class="variable">export</span><span class="operator">(</span><span class="variable">$where</span><span class="operator">,</span> <span class="variable">$sym</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">);</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> glob </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$pat</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@got</span><span class="operator">;</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">opendir</span> <span class="keyword">my</span> <span class="variable">$d</span><span class="operator">,</span> <span class="string">'.'</span><span class="operator">)</span> <span class="operator">{</span> 
            <span class="variable">@got</span> <span class="operator">=</span> <span class="keyword">grep</span> <span class="regex">/</span><span class="variable">$pat</span><span class="regex">/</span><span class="operator">,</span> <span class="keyword">readdir</span> <span class="variable">$d</span><span class="operator">;</span> 
            <span class="keyword">closedir</span> <span class="variable">$d</span><span class="operator">;</span>   
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">@got</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>And here&#39;s how it could be (ab)used:</p>

<pre><code><code>    <span class="comment">#use REGlob 'GLOBAL_glob';      # override glob() in ALL namespaces</span>
    <span class="keyword">package</span> <span class="variable">Foo</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">REGlob</span> <span class="string">'glob'</span><span class="operator">;</span>              <span class="comment"># override glob() in Foo:: only</span>
    <span class="keyword">print</span> <span class="keyword">for</span> <span class="operator">&lt;^</span><span class="operator">[</span><span class="variable">a</span><span class="operator">-</span><span class="variable">z_</span><span class="operator">]</span><span class="operator">+\.</span><span class="variable">pm</span><span class="operator">\</span><span class="variable">$&gt;</span><span class="operator">;</span>     <span class="comment"># show all pragmatic modules</span>
</code></code></pre>

<p>The initial comment shows a contrived, even dangerous example. By overriding <code><code>glob</code></code> globally, you would be forcing the new (and subversive) behavior for the <code><code>glob</code></code> operator for <i>every</i> namespace, without the complete cognizance or cooperation of the modules that own those namespaces. Naturally, this should be done with extreme caution--if it must be done at all.</p>

<p>The <code><code>REGlob</code></code> example above does not implement all the support needed to cleanly override perl&#39;s <code><code>glob</code></code> operator. The built-in <code><code>glob</code></code> has different behaviors depending on whether it appears in a scalar or list context, but our <code><code>REGlob</code></code> doesn&#39;t. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding <code><code>glob</code></code>, study the implementation of <code><code>File::DosGlob</code></code> in the standard library.</p>

<p>When you override a built-in, your replacement should be consistent (if possible) with the built-in native syntax. You can achieve this by using a suitable prototype. To get the prototype of an overridable built-in, use the <code><code>prototype</code></code> function with an argument of <code><code>&quot;CORE::builtin_name&quot;</code></code> (see <a href="../../lib/pods/perlfunc.html#prototype">&quot;prototype&quot; in perlfunc</a>).</p>

<p>Note however that some built-ins can&#39;t have their syntax expressed by a prototype (such as <code><code>system</code></code> or <code><code>chomp</code></code>). If you override them you won&#39;t be able to fully mimic their original syntax.</p>

<p>The built-ins <code><code>do</code></code>, <code><code>require</code></code> and <code><code>glob</code></code> can also be overridden, but due to special magic, their original syntax is preserved, and you don&#39;t have to define a prototype for their replacements. (You can&#39;t override the <code><code>do BLOCK</code></code> syntax, though).</p>

<p><code><code>require</code></code> has special additional dark magic: if you invoke your <code><code>require</code></code> replacement as <code><code>require Foo::Bar</code></code>, it will actually receive the argument <code><code>&quot;Foo/Bar.pm&quot;</code></code> in @_. See <a href="../../lib/pods/perlfunc.html#require">&quot;require&quot; in perlfunc</a>.</p>

<p>And, as you&#39;ll have noticed from the previous example, if you override <code><code>glob</code></code>, the <code><code>&lt;*&gt;</code></code> glob operator is overridden as well.</p>

<p>In a similar fashion, overriding the <code><code>readline</code></code> function also overrides the equivalent I/O operator <code><code>&lt;FILEHANDLE&gt;</code></code>. Also, overriding <code><code>readpipe</code></code> also overrides the operators <code><code>``</code></code> and <code><code>qx//</code></code>.</p>

<p>Finally, some built-ins (e.g. <code><code>exists</code></code> or <code><code>grep</code></code>) can&#39;t be overridden.</p>

<h2 id="Autoloading">Autoloading  </h2>

<p>If you call a subroutine that is undefined, you would ordinarily get an immediate, fatal error complaining that the subroutine doesn&#39;t exist. (Likewise for subroutines being used as methods, when the method doesn&#39;t exist in any base class of the class&#39;s package.) However, if an <code><code>AUTOLOAD</code></code> subroutine is defined in the package or packages used to locate the original subroutine, then that <code><code>AUTOLOAD</code></code> subroutine is called with the arguments that would have been passed to the original subroutine. The fully qualified name of the original subroutine magically appears in the global $AUTOLOAD variable of the same package as the <code><code>AUTOLOAD</code></code> routine. The name is not passed as an ordinary argument because, er, well, just because, that&#39;s why. (As an exception, a method call to a nonexistent <code><code>import</code></code> or <code><code>unimport</code></code> method is just skipped instead. Also, if the AUTOLOAD subroutine is an XSUB, there are other ways to retrieve the subroutine name. See <a href="../../lib/pods/perlguts.html#Autoloading-with-XSUBs">&quot;Autoloading with XSUBs&quot; in perlguts</a> for details.)</p>

<p>Many <code><code>AUTOLOAD</code></code> routines load in a definition for the requested subroutine using eval(), then execute that subroutine using a special form of goto() that erases the stack frame of the <code><code>AUTOLOAD</code></code> routine without a trace. (See the source to the standard module documented in <a href="../../lib/AutoLoader.html">AutoLoader</a>, for example.) But an <code><code>AUTOLOAD</code></code> routine can also just emulate the routine and never define it. For example, let&#39;s pretend that a function that wasn&#39;t defined should just invoke <code><code>system</code></code> with those arguments. All you&#39;d do is:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> AUTOLOAD </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$program</span> <span class="operator">=</span> <span class="variable">$AUTOLOAD</span><span class="operator">;</span>
        <span class="variable">$program</span> <span class="operator">=~</span> <span class="regex">s/.*:://</span><span class="operator">;</span>
        <span class="keyword">system</span><span class="operator">(</span><span class="variable">$program</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">);</span>
    <span class="operator">}</span>
    <span class="variable">date</span><span class="operator">();</span>
    <span class="variable">who</span><span class="operator">(</span><span class="string">'am'</span><span class="operator">,</span> <span class="string">'i'</span><span class="operator">);</span>
    <span class="variable">ls</span><span class="operator">(</span><span class="string">'-l'</span><span class="operator">);</span>
</code></code></pre>

<p>In fact, if you predeclare functions you want to call that way, you don&#39;t even need parentheses:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">subs</span> <span class="string">qw(date who ls)</span><span class="operator">;</span>
    <span class="variable">date</span><span class="operator">;</span>
    <span class="variable">who</span> <span class="string">"am"</span><span class="operator">,</span> <span class="string">"i"</span><span class="operator">;</span>
    <span class="variable">ls</span> <span class="string">'-l'</span><span class="operator">;</span>
</code></code></pre>

<p>A more complete example of this is the Shell module on CPAN, which can treat undefined subroutine calls as calls to external programs.</p>

<p>Mechanisms are available to help modules writers split their modules into autoloadable files. See the standard AutoLoader module described in <a href="../../lib/AutoLoader.html">AutoLoader</a> and in <a href="../../lib/AutoSplit.html">AutoSplit</a>, the standard SelfLoader modules in <a href="../../lib/SelfLoader.html">SelfLoader</a>, and the document on adding C functions to Perl code in <a href="../../lib/pods/perlxs.html">perlxs</a>.</p>

<h2 id="Subroutine-Attributes">Subroutine Attributes   </h2>

<p>A subroutine declaration or definition may have a list of attributes associated with it. If such an attribute list is present, it is broken up at space or colon boundaries and treated as though a <code><code>use attributes</code></code> had been seen. See <a href="../../lib/attributes.html">attributes</a> for details about what attributes are currently supported. Unlike the limitation with the obsolescent <code><code>use attrs</code></code>, the <code><code>sub : ATTRLIST</code></code> syntax works to associate the attributes with a pre-declaration, and not just with a subroutine definition.</p>

<p>The attributes must be valid as simple identifier names (without any punctuation other than the &#39;_&#39; character). They may have a parameter list appended, which is only checked for whether its parentheses (&#39;(&#39;,&#39;)&#39;) nest properly.</p>

<p>Examples of valid syntax (even though the attributes are unknown):</p>

<pre><code><code>    sub fnord (&amp;\%) : switch(10,foo(7,3))  :  expensive;
    sub plugh () : Ugly(&#39;\(&quot;) :Bad;
    sub xyzzy : _5x5 { ... }</code></code></pre>

<p>Examples of invalid syntax:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> fnord : switch</span><span class="operator">(</span>10,foo(<span class="operator">);</span> <span class="comment"># ()-string not balanced</span>
    <span class="keyword">sub</span><span class="variable"> snoid : Ugly</span><span class="operator">(</span>'('<span class="operator">);</span>        <span class="comment"># ()-string not balanced</span>
    <span class="keyword">sub</span><span class="variable"> xyzzy : 5x5</span><span class="operator">;</span>              <span class="comment"># "5x5" not a valid identifier</span>
    <span class="keyword">sub</span><span class="variable"> plugh : Y2::north</span><span class="operator">;</span>        <span class="comment"># "Y2::north" not a simple identifier</span>
    <span class="keyword">sub</span><span class="variable"> snurt : foo + bar</span><span class="operator">;</span>        <span class="comment"># "+" not a colon or space</span>
</code></code></pre>

<p>The attribute list is passed as a list of constant strings to the code which associates them with the subroutine. In particular, the second example of valid syntax above currently looks like this in terms of how it&#39;s parsed and invoked:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">attributes</span> <span class="keyword">__PACKAGE__</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">plugh</span><span class="operator">,</span> <span class="string">q[Ugly('\(")]</span><span class="operator">,</span> <span class="string">'Bad'</span><span class="operator">;</span>
</code></code></pre>

<p>For further details on attribute lists and their manipulation, see <a href="../../lib/attributes.html">attributes</a> and <a href="../../lib/Attribute/Handlers.html">Attribute::Handlers</a>.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>See <a href="../../lib/pods/perlref.html#Function-Templates">&quot;Function Templates&quot; in perlref</a> for more about references and closures. See <a href="../../lib/pods/perlxs.html">perlxs</a> if you&#39;d like to learn about calling C subroutines from Perl. See <a href="../../lib/pods/perlembed.html">perlembed</a> if you&#39;d like to learn about calling Perl subroutines from C. See <a href="../../lib/pods/perlmod.html">perlmod</a> to learn about bundling up your functions in separate files. See <a href="../../lib/pods/perlmodlib.html">perlmodlib</a> to learn what library modules come standard on your system. See <a href="../../lib/pods/perlootut.html">perlootut</a> to learn how to make object method calls.</p>


</body>

</html>


