<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME </a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#The-dot">The dot</a></li>
      <li><a href="#Backslash-sequences">Backslash sequences               </a>
        <ul>
          <li><a href="#N">\N</a></li>
          <li><a href="#Digits">Digits</a></li>
          <li><a href="#Word-characters">Word characters</a></li>
          <li><a href="#Whitespace">Whitespace</a></li>
          <li><a href="#Unicode-Properties">Unicode Properties</a>
            <ul>
              <li><a href="#Examples">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Bracketed-Character-Classes">Bracketed Character Classes</a>
        <ul>
          <li><a href="#Special-Characters-Inside-a-Bracketed-Character-Class">Special Characters Inside a Bracketed Character Class</a></li>
          <li><a href="#Character-Ranges">Character Ranges</a></li>
          <li><a href="#Negation">Negation</a></li>
          <li><a href="#Backslash-Sequences">Backslash Sequences</a></li>
          <li><a href="#POSIX-Character-Classes">POSIX Character Classes                 </a>
            <ul>
              <li><a href="#Negation-of-POSIX-character-classes">Negation of POSIX character classes </a></li>
              <li><a href="#and-.-.-">[= =] and [. .]</a></li>
              <li><a href="#Examples1">Examples</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h1 id="NAME">NAME </h1>

<p>perlrecharclass - Perl Regular Expression Character Classes</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The top level documentation about Perl regular expressions is found in <a href="../../lib/pods/perlre.html">perlre</a>.</p>

<p>This manual page discusses the syntax and use of character classes in Perl regular expressions.</p>

<p>A character class is a way of denoting a set of characters in such a way that one character of the set is matched. It&#39;s important to remember that: matching a character class consumes exactly one character in the source string. (The source string is the string the regular expression is matched against.)</p>

<p>There are three types of character classes in Perl regular expressions: the dot, backslash sequences, and the form enclosed in square brackets. Keep in mind, though, that often the term &quot;character class&quot; is used to mean just the bracketed form. Certainly, most Perl documentation does that.</p>

<h2 id="The-dot">The dot</h2>

<p>The dot (or period), <code><code>.</code></code> is probably the most used, and certainly the most well-known character class. By default, a dot matches any character, except for the newline. That default can be changed to add matching the newline by using the <i>single line</i> modifier: either for the entire regular expression with the <code><code>/s</code></code> modifier, or locally with <code><code>(?s)</code></code>. (The experimental <code><code>\N</code></code> backslash sequence, described below, matches any character except newline without regard to the <i>single line</i> modifier.)</p>

<p>Here are some examples:</p>

<pre><code><code> &quot;a&quot;  =~  /./       # Match
 &quot;.&quot;  =~  /./       # Match
 &quot;&quot;   =~  /./       # No match (dot has to match a character)
 &quot;\n&quot; =~  /./       # No match (dot does not match a newline)
 &quot;\n&quot; =~  /./s      # Match (global &#39;single line&#39; modifier)
 &quot;\n&quot; =~  /(?s:.)/  # Match (local &#39;single line&#39; modifier)
 &quot;ab&quot; =~  /^.$/     # No match (dot matches one character)</code></code></pre>

<h2 id="Backslash-sequences">Backslash sequences               </h2>

<p>A backslash sequence is a sequence of characters, the first one of which is a backslash. Perl ascribes special meaning to many such sequences, and some of these are character classes. That is, they match a single character each, provided that the character belongs to the specific set of characters defined by the sequence.</p>

<p>Here&#39;s a list of the backslash sequences that are character classes. They are discussed in more detail below. (For the backslash sequences that aren&#39;t character classes, see <a href="../../lib/pods/perlrebackslash.html">perlrebackslash</a>.)</p>

<pre><code><code> <span class="operator">\</span><span class="variable">d</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">decimal</span> <span class="variable">digit</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">D</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">non</span><span class="operator">-</span><span class="variable">decimal</span><span class="operator">-</span><span class="variable">digit</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">w</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="string">"word"</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">W</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">non</span><span class="operator">-</span><span class="string">"word"</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="regex">s             Match a whitespace character.
 \S             Match a non-whitespace character.
 \h             Match</span> <span class="variable">a</span> <span class="variable">horizontal</span> <span class="variable">whitespace</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">H</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">character</span> <span class="variable">that</span> <span class="variable">isn't</span> <span class="variable">horizontal</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">v</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">vertical</span> <span class="variable">whitespace</span> <span class="variable">character</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">V</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">character</span> <span class="variable">that</span> <span class="variable">isn't</span> <span class="variable">vertical</span> <span class="variable">whitespace</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">N</span>             <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">character</span> <span class="variable">that</span> <span class="variable">isn't</span> <span class="variable">a</span> <span class="variable">newline</span><span class="operator">.</span>  <span class="variable">Experimental</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">pP</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Prop</span><span class="operator">}</span>  <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">character</span> <span class="variable">that</span> <span class="variable">has</span> <span class="variable">the</span> <span class="keyword">given</span> <span class="variable">Unicode</span> <span class="variable">property</span><span class="operator">.</span>
 <span class="operator">\</span><span class="variable">PP</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">Prop</span><span class="operator">}</span>  <span class="variable">Match</span> <span class="variable">a</span> <span class="variable">character</span> <span class="variable">that</span> <span class="variable">doesn't</span> <span class="variable">have</span> <span class="variable">the</span> <span class="variable">Unicode</span> <span class="variable">property</span>
</code></code></pre>

<h3 id="N">\N</h3>

<p><code><code>\N</code></code> is new in 5.12, and is experimental. It, like the dot, matches any character that is not a newline. The difference is that <code><code>\N</code></code> is not influenced by the <i>single line</i> regular expression modifier (see <a href="#The-dot">&quot;The dot&quot;</a> above). Note that the form <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{...}</span>
</code></code> may mean something completely different. When the <code><code><span class="operator">{...}</span>
</code></code> is a <a href="../../lib/pods/perlre.html#Quantifiers">quantifier</a>, it means to match a non-newline character that many times. For example, <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="number">3</span><span class="operator">}</span>
</code></code> means to match 3 non-newlines; <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="number">5</span><span class="operator">,}</span>
</code></code> means to match 5 or more non-newlines. But if <code><code><span class="operator">{...}</span>
</code></code> is not a legal quantifier, it is presumed to be a named character. See <a href="../../lib/charnames.html">charnames</a> for those. For example, none of <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">COLON</span><span class="operator">}</span>
</code></code>, <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="number">4</span><span class="variable">F</span><span class="operator">}</span>
</code></code>, and <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">F4</span><span class="operator">}</span>
</code></code> contain legal quantifiers, so Perl will try to find characters whose names are respectively <code><code>COLON</code></code>, <code><code>4F</code></code>, and <code><code>F4</code></code>.</p>

<h3 id="Digits">Digits</h3>

<p><code><code>\d</code></code> matches a single character considered to be a decimal <i>digit</i>. If the <code><code>/a</code></code> regular expression modifier is in effect, it matches [0-9]. Otherwise, it matches anything that is matched by <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Digit</span><span class="operator">}</span>
</code></code>, which includes [0-9]. (An unlikely possible exception is that under locale matching rules, the current locale might not have [0-9] matched by <code><code>\d</code></code>, and/or might match other characters whose code point is less than 256. Such a locale definition would be in violation of the C language standard, but Perl doesn&#39;t currently assume anything in regard to this.)</p>

<p>What this means is that unless the <code><code>/a</code></code> modifier is in effect <code><code>\d</code></code> not only matches the digits &#39;0&#39; - &#39;9&#39;, but also Arabic, Devanagari, and digits from other languages. This may cause some confusion, and some security issues.</p>

<p>Some digits that <code><code>\d</code></code> matches look like some of the [0-9] ones, but have different values. For example, BENGALI DIGIT FOUR (U+09EA) looks very much like an ASCII DIGIT EIGHT (U+0038). An application that is expecting only the ASCII digits might be misled, or if the match is <code><code>\d+</code></code>, the matched string might contain a mixture of digits from different writing systems that look like they signify a number different than they actually do. <a href="../../lib/Unicode/UCD.html#num-">&quot;num()&quot; in Unicode::UCD</a> can be used to safely calculate the value, returning <code><code>undef</code></code> if the input string contains such a mixture.</p>

<p>What <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Digit</span><span class="operator">}</span>
</code></code> means (and hence <code><code>\d</code></code> except under the <code><code>/a</code></code> modifier) is <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">General_Category</span><span class="operator">=</span><span class="variable">Decimal_Number</span><span class="operator">}</span>
</code></code>, or synonymously, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">General_Category</span><span class="operator">=</span><span class="variable">Digit</span><span class="operator">}</span>
</code></code>. Starting with Unicode version 4.1, this is the same set of characters matched by <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Numeric_Type</span><span class="operator">=</span><span class="variable">Decimal</span><span class="operator">}</span>
</code></code>. But Unicode also has a different property with a similar name, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Numeric_Type</span><span class="operator">=</span><span class="variable">Digit</span><span class="operator">}</span>
</code></code>, which matches a completely different set of characters. These characters are things such as <code><code>CIRCLED DIGIT ONE</code></code> or subscripts, or are from writing systems that lack all ten digits.</p>

<p>The design intent is for <code><code>\d</code></code> to exactly match the set of characters that can safely be used with &quot;normal&quot; big-endian positional decimal syntax, where, for example 123 means one &#39;hundred&#39;, plus two &#39;tens&#39;, plus three &#39;ones&#39;. This positional notation does not necessarily apply to characters that match the other type of &quot;digit&quot;, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Numeric_Type</span><span class="operator">=</span><span class="variable">Digit</span><span class="operator">}</span>
</code></code>, and so <code><code>\d</code></code> doesn&#39;t match them.</p>

<p>The Tamil digits (U+0BE6 - U+0BEF) can also legally be used in old-style Tamil numbers in which they would appear no more than one in a row, separated by characters that mean &quot;times 10&quot;, &quot;times 100&quot;, etc. (See <a href="http://www.unicode.org/notes/tn21">http://www.unicode.org/notes/tn21</a>.)</p>

<p>Any character not matched by <code><code>\d</code></code> is matched by <code><code>\D</code></code>.</p>

<h3 id="Word-characters">Word characters</h3>

<p>A <code><code>\w</code></code> matches a single alphanumeric character (an alphabetic character, or a decimal digit) or a connecting punctuation character, such as an underscore (&quot;_&quot;). It does not match a whole word. To match a whole word, use <code><code>\w+</code></code>. This isn&#39;t the same thing as matching an English word, but in the ASCII range it is the same as a string of Perl-identifier characters.</p>

<dl>

<dt id="If-the-a-modifier-is-in-effect-...">If the <code><code>/a</code></code> modifier is in effect ...</dt>
<dd>

<p><code><code>\w</code></code> matches the 63 characters [a-zA-Z0-9_].</p>

</dd>
<dt id="otherwise-...">otherwise ...</dt>
<dd>

<dl>

<dt id="For-code-points-above-255-...">For code points above 255 ...</dt>
<dd>

<p><code><code>\w</code></code> matches the same as <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Word</span><span class="operator">}</span>
</code></code> matches in this range. That is, it matches Thai letters, Greek letters, etc. This includes connector punctuation (like the underscore) which connect two words together, or diacritics, such as a <code><code>COMBINING TILDE</code></code> and the modifier letters, which are generally used to add auxiliary markings to letters.</p>

</dd>
<dt id="For-code-points-below-256-...">For code points below 256 ...</dt>
<dd>

<dl>

<dt id="if-locale-rules-are-in-effect-...">if locale rules are in effect ...</dt>
<dd>

<p><code><code>\w</code></code> matches the platform&#39;s native underscore character plus whatever the locale considers to be alphanumeric.</p>

</dd>
<dt id="if-Unicode-rules-are-in-effect-or-if-on-an-EBCDIC-platform-...">if Unicode rules are in effect or if on an EBCDIC platform ...</dt>
<dd>

<p><code><code>\w</code></code> matches exactly what <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Word</span><span class="operator">}</span>
</code></code> matches.</p>

</dd>
<dt id="otherwise-...1">otherwise ...</dt>
<dd>

<p><code><code>\w</code></code> matches [a-zA-Z0-9_].</p>

</dd>
</dl>

</dd>
</dl>

</dd>
</dl>

<p>Which rules apply are determined as described in <a href="../../lib/pods/perlre.html#Which-character-set-modifier-is-in-effect-">&quot;Which character set modifier is in effect?&quot; in perlre</a>.</p>

<p>There are a number of security issues with the full Unicode list of word characters. See <a href="http://unicode.org/reports/tr36">http://unicode.org/reports/tr36</a>.</p>

<p>Also, for a somewhat finer-grained set of characters that are in programming language identifiers beyond the ASCII range, you may wish to instead use the more customized <a href="#Unicode-Properties">&quot;Unicode Properties&quot;</a>, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">ID_Start</span><span class="operator">}</span>
</code></code>, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">ID_Continue</span><span class="operator">}</span>
</code></code>, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XID_Start</span><span class="operator">}</span>
</code></code>, and <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XID_Continue</span><span class="operator">}</span>
</code></code>. See <a href="http://unicode.org/reports/tr31">http://unicode.org/reports/tr31</a>.</p>

<p>Any character not matched by <code><code>\w</code></code> is matched by <code><code>\W</code></code>.</p>

<h3 id="Whitespace">Whitespace</h3>

<p><code><code>\s</code></code> matches any single character considered whitespace.</p>

<dl>

<dt id="If-the-a-modifier-is-in-effect-...1">If the <code><code>/a</code></code> modifier is in effect ...</dt>
<dd>

<p><code><code>\s</code></code> matches the 5 characters [\t\n\f\r ]; that is, the horizontal tab, the newline, the form feed, the carriage return, and the space. (Note that it doesn&#39;t match the vertical tab, <code><code>\cK</code></code> on ASCII platforms.)</p>

</dd>
<dt id="otherwise-...2">otherwise ...</dt>
<dd>

<dl>

<dt id="For-code-points-above-255-...1">For code points above 255 ...</dt>
<dd>

<p><code><code>\s</code></code> matches exactly the code points above 255 shown with an &quot;s&quot; column in the table below.</p>

</dd>
<dt id="For-code-points-below-256-...1">For code points below 256 ...</dt>
<dd>

<dl>

<dt id="if-locale-rules-are-in-effect-...1">if locale rules are in effect ...</dt>
<dd>

<p><code><code>\s</code></code> matches whatever the locale considers to be whitespace. Note that this is likely to include the vertical space, unlike non-locale <code><code>\s</code></code> matching.</p>

</dd>
<dt id="if-Unicode-rules-are-in-effect-or-if-on-an-EBCDIC-platform-...1">if Unicode rules are in effect or if on an EBCDIC platform ...</dt>
<dd>

<p><code><code>\s</code></code> matches exactly the characters shown with an &quot;s&quot; column in the table below.</p>

</dd>
<dt id="otherwise-...3">otherwise ...</dt>
<dd>

<p><code><code>\s</code></code> matches [\t\n\f\r ]. Note that this list doesn&#39;t include the non-breaking space.</p>

</dd>
</dl>

</dd>
</dl>

</dd>
</dl>

<p>Which rules apply are determined as described in <a href="../../lib/pods/perlre.html#Which-character-set-modifier-is-in-effect-">&quot;Which character set modifier is in effect?&quot; in perlre</a>.</p>

<p>Any character not matched by <code><code>\s</code></code> is matched by <code><code>\S</code></code>.</p>

<p><code><code>\h</code></code> matches any character considered horizontal whitespace; this includes the platform&#39;s space and tab characters and several others listed in the table below. <code><code>\H</code></code> matches any character not considered horizontal whitespace. They use the platform&#39;s native character set, and do not consider any locale that may otherwise be in use.</p>

<p><code><code>\v</code></code> matches any character considered vertical whitespace; this includes the platform&#39;s carriage return and line feed characters (newline) plus several other characters, all listed in the table below. <code><code>\V</code></code> matches any character not considered vertical whitespace. They use the platform&#39;s native character set, and do not consider any locale that may otherwise be in use.</p>

<p><code><code>\R</code></code> matches anything that can be considered a newline under Unicode rules. It&#39;s not a character class, as it can match a multi-character sequence. Therefore, it cannot be used inside a bracketed character class; use <code><code>\v</code></code> instead (vertical whitespace). It uses the platform&#39;s native character set, and does not consider any locale that may otherwise be in use. Details are discussed in <a href="../../lib/pods/perlrebackslash.html">perlrebackslash</a>.</p>

<p>Note that unlike <code><code>\s</code></code> (and <code><code>\d</code></code> and <code><code>\w</code></code>), <code><code>\h</code></code> and <code><code>\v</code></code> always match the same characters, without regard to other factors, such as the active locale or whether the source string is in UTF-8 format.</p>

<p>One might think that <code><code>\s</code></code> is equivalent to <code><code>[\h\v]</code></code>. This is not true. The difference is that the vertical tab (<code><code>&quot;\x0b&quot;</code></code>) is not matched by <code><code>\s</code></code>; it is however considered vertical whitespace.</p>

<p>The following table is a complete listing of characters matched by <code><code>\s</code></code>, <code><code>\h</code></code> and <code><code>\v</code></code> as of Unicode 6.0.</p>

<p>The first column gives the Unicode code point of the character (in hex format), the second column gives the (Unicode) name. The third column indicates by which class(es) the character is matched (assuming no locale or EBCDIC code page is in effect that changes the <code><code>\s</code></code> matching).</p>

<pre><code><code> 0x0009        CHARACTER TABULATION   h s
 0x000a              LINE FEED (LF)    vs
 0x000b             LINE TABULATION    v
 0x000c              FORM FEED (FF)    vs
 0x000d        CARRIAGE RETURN (CR)    vs
 0x0020                       SPACE   h s
 0x0085             NEXT LINE (NEL)    vs  [1]
 0x00a0              NO-BREAK SPACE   h s  [1]
 0x1680            OGHAM SPACE MARK   h s
 0x180e   MONGOLIAN VOWEL SEPARATOR   h s
 0x2000                     EN QUAD   h s
 0x2001                     EM QUAD   h s
 0x2002                    EN SPACE   h s
 0x2003                    EM SPACE   h s
 0x2004          THREE-PER-EM SPACE   h s
 0x2005           FOUR-PER-EM SPACE   h s
 0x2006            SIX-PER-EM SPACE   h s
 0x2007                FIGURE SPACE   h s
 0x2008           PUNCTUATION SPACE   h s
 0x2009                  THIN SPACE   h s
 0x200a                  HAIR SPACE   h s
 0x2028              LINE SEPARATOR    vs
 0x2029         PARAGRAPH SEPARATOR    vs
 0x202f       NARROW NO-BREAK SPACE   h s
 0x205f   MEDIUM MATHEMATICAL SPACE   h s
 0x3000           IDEOGRAPHIC SPACE   h s</code></code></pre>

<dl>

<dt id="pod-1-">[1]</dt>
<dd>

<p>NEXT LINE and NO-BREAK SPACE may or may not match <code><code>\s</code></code> depending on the rules in effect. See <a href="#Whitespace">the beginning of this section</a>.</p>

</dd>
</dl>

<h3 id="Unicode-Properties">Unicode Properties</h3>

<p><code><code>\pP</code></code> and <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Prop</span><span class="operator">}</span>
</code></code> are character classes to match characters that fit given Unicode properties. One letter property names can be used in the <code><code>\pP</code></code> form, with the property name following the <code><code>\p</code></code>, otherwise, braces are required. When using braces, there is a single form, which is just the property name enclosed in the braces, and a compound form which looks like <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">name</span><span class="operator">=</span><span class="variable">value</span><span class="operator">}</span>
</code></code>, which means to match if the property &quot;name&quot; for the character has that particular &quot;value&quot;. For instance, a match for a number can be written as <code><code>/\pN/</code></code> or as <code><code><span class="regex">/\p{Number}/</span>
</code></code>, or as <code><code><span class="regex">/\p{Number=True}/</span>
</code></code>. Lowercase letters are matched by the property <i>Lowercase_Letter</i> which has the short form <i>Ll</i>. They need the braces, so are written as <code><code><span class="regex">/\p{Ll}/</span>
</code></code> or <code><code><span class="regex">/\p{Lowercase_Letter}/</span>
</code></code>, or <code><code><span class="regex">/\p{General_Category=Lowercase_Letter}/</span>
</code></code> (the underscores are optional). <code><code>/\pLl/</code></code> is valid, but means something different. It matches a two character string: a letter (Unicode property <code><code>\pL</code></code>), followed by a lowercase <code><code>l</code></code>.</p>

<p>If neither the <code><code>/a</code></code> modifier nor locale rules are in effect, the use of a Unicode property will force the regular expression into using Unicode rules.</p>

<p>Note that almost all properties are immune to case-insensitive matching. That is, adding a <code><code>/i</code></code> regular expression modifier does not change what they match. There are two sets that are affected. The first set is <code><code>Uppercase_Letter</code></code>, <code><code>Lowercase_Letter</code></code>, and <code><code>Titlecase_Letter</code></code>, all of which match <code><code>Cased_Letter</code></code> under <code><code>/i</code></code> matching. The second set is <code><code>Uppercase</code></code>, <code><code>Lowercase</code></code>, and <code><code>Titlecase</code></code>, all of which match <code><code>Cased</code></code> under <code><code>/i</code></code> matching. (The difference between these sets is that some things, such as Roman numerals, come in both upper and lower case, so they are <code><code>Cased</code></code>, but aren&#39;t considered to be letters, so they aren&#39;t <code><code>Cased_Letter</code></code>s. They&#39;re actually <code><code>Letter_Number</code></code>s.) This set also includes its subsets <code><code>PosixUpper</code></code> and <code><code>PosixLower</code></code>, both of which under <code><code>/i</code></code> match <code><code>PosixAlpha</code></code>.</p>

<p>For more details on Unicode properties, see <a href="../../lib/pods/perlunicode.html#Unicode-Character-Properties">&quot;Unicode Character Properties&quot; in perlunicode</a>; for a complete list of possible properties, see <a href="../../lib/pods/perluniprops.html#Properties-accessible-through-p-and-P-">&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops</a>, which notes all forms that have <code><code>/i</code></code> differences. It is also possible to define your own properties. This is discussed in <a href="../../lib/pods/perlunicode.html#User-Defined-Character-Properties">&quot;User-Defined Character Properties&quot; in perlunicode</a>.</p>

<p>Unicode properties are defined (surprise!) only on Unicode code points. A warning is raised and all matches fail on non-Unicode code points (those above the legal Unicode maximum of 0x10FFFF). This can be somewhat surprising,</p>

<pre><code><code> <span class="keyword">chr</span><span class="operator">(</span><span class="number">0x110000</span><span class="operator">)</span> <span class="operator">=~</span> <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">ASCII_Hex_Digit</span><span class="operator">=</span><span class="variable">True</span><span class="operator">}</span>      <span class="comment"># Fails.</span>
 <span class="keyword">chr</span><span class="operator">(</span><span class="number">0x110000</span><span class="operator">)</span> <span class="operator">=~</span> <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">ASCII_Hex_Digit</span><span class="operator">=</span><span class="variable">False</span><span class="operator">}</span>     <span class="comment"># Also fails!</span>
</code></code></pre>

<p>Even though these two matches might be thought of as complements, they are so only on Unicode code points.</p>

<h4 id="Examples">Examples</h4>

<pre><code><code> <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\w/</span>      <span class="comment"># Match, "a" is a 'word' character.</span>
 <span class="string">"7"</span>  <span class="operator">=~</span>  <span class="regex">/\w/</span>      <span class="comment"># Match, "7" is a 'word' character as well.</span>
 <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\d/</span>      <span class="comment"># No match, "a" isn't a digit.</span>
 <span class="string">"7"</span>  <span class="operator">=~</span>  <span class="regex">/\d/</span>      <span class="comment"># Match, "7" is a digit.</span>
 <span class="string">" "</span>  <span class="operator">=~</span>  <span class="regex">/\s/</span>      <span class="comment"># Match, a space is whitespace.</span>
 <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\D/</span>      <span class="comment"># Match, "a" is a non-digit.</span>
 <span class="string">"7"</span>  <span class="operator">=~</span>  <span class="regex">/\D/</span>      <span class="comment"># No match, "7" is not a non-digit.</span>
 <span class="string">" "</span>  <span class="operator">=~</span>  <span class="regex">/\S/</span>      <span class="comment"># No match, a space is not non-whitespace.</span>
 
 <span class="string">" "</span>  <span class="operator">=~</span>  <span class="regex">/\h/</span>      <span class="comment"># Match, space is horizontal whitespace.</span>
 <span class="string">" "</span>  <span class="operator">=~</span>  <span class="regex">/\v/</span>      <span class="comment"># No match, space is not vertical whitespace.</span>
 <span class="string">"\r"</span> <span class="operator">=~</span>  <span class="regex">/\v/</span>      <span class="comment"># Match, a return is vertical whitespace.</span>
 
 <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\pL/</span>     <span class="comment"># Match, "a" is a letter.</span>
 <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\p{Lu}/</span>  <span class="comment"># No match, /\p{Lu}/ matches upper case letters.</span>
 
 <span class="string">"\x{0e0b}"</span> <span class="operator">=~</span> <span class="regex">/\p{Thai}/</span>  <span class="comment"># Match, \x{0e0b} is the character</span>
                           <span class="comment"># 'THAI CHARACTER SO SO', and that's in</span>
                           <span class="comment"># Thai Unicode class.</span>
 <span class="string">"a"</span>  <span class="operator">=~</span>  <span class="regex">/\P{Lao}/</span> <span class="comment"># Match, as "a" is not a Laotian character.</span>
</code></code></pre>

<p>It is worth emphasizing that <code><code>\d</code></code>, <code><code>\w</code></code>, etc, match single characters, not complete numbers or words. To match a number (that consists of digits), use <code><code>\d+</code></code>; to match a word, use <code><code>\w+</code></code>. But be aware of the security considerations in doing so, as mentioned above.</p>

<h2 id="Bracketed-Character-Classes">Bracketed Character Classes</h2>

<p>The third form of character class you can use in Perl regular expressions is the bracketed character class. In its simplest form, it lists the characters that may be matched, surrounded by square brackets, like this: <code><code>[aeiou]</code></code>. This matches one of <code><code>a</code></code>, <code><code>e</code></code>, <code><code>i</code></code>, <code><code>o</code></code> or <code><code>u</code></code>. Like the other character classes, exactly one character is matched.* To match a longer string consisting of characters mentioned in the character class, follow the character class with a <a href="../../lib/pods/perlre.html#Quantifiers">quantifier</a>. For instance, <code><code>[aeiou]+</code></code> matches one or more lowercase English vowels.</p>

<p>Repeating a character in a character class has no effect; it&#39;s considered to be in the set only once.</p>

<p>Examples:</p>

<pre><code><code> &quot;e&quot;  =~  /[aeiou]/        # Match, as &quot;e&quot; is listed in the class.
 &quot;p&quot;  =~  /[aeiou]/        # No match, &quot;p&quot; is not listed in the class.
 &quot;ae&quot; =~  /^[aeiou]$/      # No match, a character class only matches
                           # a single character.
 &quot;ae&quot; =~  /^[aeiou]+$/     # Match, due to the quantifier.

 -------</code></code></pre>

<p>* There is an exception to a bracketed character class matching a single character only. When the class is to match caselessly under <code><code>/i</code></code> matching rules, and a character inside the class matches a multiple-character sequence caselessly under Unicode rules, the class (when not <a href="#Negation">inverted</a>) will also match that sequence. For example, Unicode says that the letter <code><code>LATIN SMALL LETTER SHARP S</code></code> should match the sequence <code><code>ss</code></code> under <code><code>/i</code></code> rules. Thus,</p>

<pre><code><code> <span class="string">'ss'</span> <span class="operator">=~</span> <span class="regex">/\A\N{LATIN SMALL LETTER SHARP S}\z/i</span>             <span class="comment"># Matches</span>
 <span class="string">'ss'</span> <span class="operator">=~</span> <span class="regex">/\A[aeioust\N{LATIN SMALL LETTER SHARP S}]\z/i</span>    <span class="comment"># Matches</span>
</code></code></pre>

<h3 id="Special-Characters-Inside-a-Bracketed-Character-Class">Special Characters Inside a Bracketed Character Class</h3>

<p>Most characters that are meta characters in regular expressions (that is, characters that carry a special meaning like <code><code>.</code></code>, <code><code>*</code></code>, or <code><code>(</code></code>) lose their special meaning and can be used inside a character class without the need to escape them. For instance, <code><code>[()]</code></code> matches either an opening parenthesis, or a closing parenthesis, and the parens inside the character class don&#39;t group or capture.</p>

<p>Characters that may carry a special meaning inside a character class are: <code><code>\</code></code>, <code><code>^</code></code>, <code><code>-</code></code>, <code><code>[</code></code> and <code><code>]</code></code>, and are discussed below. They can be escaped with a backslash, although this is sometimes not needed, in which case the backslash may be omitted.</p>

<p>The sequence <code><code>\b</code></code> is special inside a bracketed character class. While outside the character class, <code><code>\b</code></code> is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, <code><code>\b</code></code> matches a backspace character.</p>

<p>The sequences <code><code>\a</code></code>, <code><code>\c</code></code>, <code><code>\e</code></code>, <code><code>\f</code></code>, <code><code>\n</code></code>, <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span>
</code><i><code>NAME</code></i><code>}</code></code>, <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span>
</code><i><code>hex char</code></i><code>}</code></code>, <code><code>\r</code></code>, <code><code>\t</code></code>, and <code><code>\x</code></code> are also special and have the same meanings as they do outside a bracketed character class. (However, inside a bracketed character class, if <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span>
</code><i><code>NAME</code></i><code>}</code></code> expands to a sequence of characters, only the first one in the sequence is used, with a warning.)</p>

<p>Also, a backslash followed by two or three octal digits is considered an octal number.</p>

<p>A <code><code>[</code></code> is not special inside a character class, unless it&#39;s the start of a POSIX character class (see <a href="#POSIX-Character-Classes">&quot;POSIX Character Classes&quot;</a> below). It normally does not need escaping.</p>

<p>A <code><code>]</code></code> is normally either the end of a POSIX character class (see <a href="#POSIX-Character-Classes">&quot;POSIX Character Classes&quot;</a> below), or it signals the end of the bracketed character class. If you want to include a <code><code>]</code></code> in the set of characters, you must generally escape it.</p>

<p>However, if the <code><code>]</code></code> is the <i>first</i> (or the second if the first character is a caret) character of a bracketed character class, it does not denote the end of the class (as you cannot have an empty class) and is considered part of the set of characters that can be matched without escaping.</p>

<p>Examples:</p>

<pre><code><code> &quot;+&quot;   =~ /[+?*]/     #  Match, &quot;+&quot; in a character class is not special.
 &quot;\cH&quot; =~ /[\b]/      #  Match, \b inside in a character class
                      #  is equivalent to a backspace.
 &quot;]&quot;   =~ /[][]/      #  Match, as the character class contains.
                      #  both [ and ].
 &quot;[]&quot;  =~ /[[]]/      #  Match, the pattern contains a character class
                      #  containing just ], and the character class is
                      #  followed by a ].</code></code></pre>

<h3 id="Character-Ranges">Character Ranges</h3>

<p>It is not uncommon to want to match a range of characters. Luckily, instead of listing all characters in the range, one may use the hyphen (<code><code>-</code></code>). If inside a bracketed character class you have two characters separated by a hyphen, it&#39;s treated as if all characters between the two were in the class. For instance, <code><code>[0-9]</code></code> matches any ASCII digit, and <code><code>[a-m]</code></code> matches any lowercase letter from the first half of the ASCII alphabet.</p>

<p>Note that the two characters on either side of the hyphen are not necessarily both letters or both digits. Any character is possible, although not advisable. <code><code>[&#39;-?]</code></code> contains a range of characters, but most people will not know which characters that means. Furthermore, such ranges may lead to portability problems if the code has to run on a platform that uses a different character set, such as EBCDIC.</p>

<p>If a hyphen in a character class cannot syntactically be part of a range, for instance because it is the first or the last character of the character class, or if it immediately follows a range, the hyphen isn&#39;t special, and so is considered a character to be matched literally. If you want a hyphen in your set of characters to be matched and its position in the class is such that it could be considered part of a range, you must escape that hyphen with a backslash.</p>

<p>Examples:</p>

<pre><code><code> <span class="operator">[</span><span class="variable">a</span><span class="keyword">-z</span><span class="operator">]</span>       <span class="comment">#  Matches a character that is a lower case ASCII letter.</span>
 <span class="operator">[</span><span class="variable">a</span><span class="operator">-</span><span class="variable">fz</span><span class="operator">]</span>      <span class="comment">#  Matches any letter between 'a' and 'f' (inclusive) or</span>
             <span class="comment">#  the letter 'z'.</span>
 <span class="operator">[</span><span class="keyword">-z</span><span class="operator">]</span>        <span class="comment">#  Matches either a hyphen ('-') or the letter 'z'.</span>
 <span class="operator">[</span><span class="variable">a</span><span class="keyword">-f</span><span class="operator">-</span><span class="regex">m]     #  Matches any letter between 'a' and 'f' (inclusive), the
             #  hyphen ('-'), or the letter 'm'.
 ['-?]</span>       <span class="comment">#  Matches any of the characters  '()*+,-./0123456789:;&lt;=&gt;?</span>
             <span class="comment">#  (But not on an EBCDIC platform).</span>
</code></code></pre>

<h3 id="Negation">Negation</h3>

<p>It is also possible to instead list the characters you do not want to match. You can do so by using a caret (<code><code>^</code></code>) as the first character in the character class. For instance, <code><code>[^a-z]</code></code> matches any character that is not a lowercase ASCII letter, which therefore includes more than a million Unicode code points. The class is said to be &quot;negated&quot; or &quot;inverted&quot;.</p>

<p>This syntax make the caret a special character inside a bracketed character class, but only if it is the first character of the class. So if you want the caret as one of the characters to match, either escape the caret or else don&#39;t list it first.</p>

<p>In inverted bracketed character classes, Perl ignores the Unicode rules that normally say that certain characters should match a sequence of multiple characters under caseless <code><code>/i</code></code> matching. Following those rules could lead to highly confusing situations:</p>

<pre><code><code> <span class="string">"ss"</span> <span class="operator">=~</span> <span class="regex">/^[^\xDF]+$/ui</span><span class="operator">;</span>   <span class="comment"># Matches!</span>
</code></code></pre>

<p>This should match any sequences of characters that aren&#39;t <code><code>\xDF</code></code> nor what <code><code>\xDF</code></code> matches under <code><code>/i</code></code>. <code><code>&quot;s&quot;</code></code> isn&#39;t <code><code>\xDF</code></code>, but Unicode says that <code><code>&quot;ss&quot;</code></code> is what <code><code>\xDF</code></code> matches under <code><code>/i</code></code>. So which one &quot;wins&quot;? Do you fail the match because the string has <code><code>ss</code></code> or accept it because it has an <code><code>s</code></code> followed by another <code><code>s</code></code>? Perl has chosen the latter.</p>

<p>Examples:</p>

<pre><code><code> &quot;e&quot;  =~  /[^aeiou]/   #  No match, the &#39;e&#39; is listed.
 &quot;x&quot;  =~  /[^aeiou]/   #  Match, as &#39;x&#39; isn&#39;t a lowercase vowel.
 &quot;^&quot;  =~  /[^^]/       #  No match, matches anything that isn&#39;t a caret.
 &quot;^&quot;  =~  /[x^]/       #  Match, caret is not special here.</code></code></pre>

<h3 id="Backslash-Sequences">Backslash Sequences</h3>

<p>You can put any backslash sequence character class (with the exception of <code><code>\N</code></code> and <code><code>\R</code></code>) inside a bracketed character class, and it will act just as if you had put all characters matched by the backslash sequence inside the character class. For instance, <code><code>[a-f\d]</code></code> matches any decimal digit, or any of the lowercase letters between &#39;a&#39; and &#39;f&#39; inclusive.</p>

<p><code><code>\N</code></code> within a bracketed character class must be of the forms <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span>
</code><i><code>name</code></i><code>}</code></code> or <code><code><span class="operator">\</span><span class="variable">N</span><span class="operator">{</span><span class="variable">U</span><span class="operator">+</span>
</code><i><code>hex char</code></i><code>}</code></code>, and NOT be the form that matches non-newlines, for the same reason that a dot <code><code>.</code></code> inside a bracketed character class loses its special meaning: it matches nearly anything, which generally isn&#39;t what you want to happen.</p>

<p>Examples:</p>

<pre><code><code> <span class="regex">/[\p{Thai}\d]/</span>     <span class="comment"># Matches a character that is either a Thai</span>
                    <span class="comment"># character, or a digit.</span>
 <span class="operator">/</span><span class="operator">[</span><span class="operator">^\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Arabic</span><span class="operator">}()</span><span class="operator">]</span><span class="operator">/</span>  <span class="comment"># Matches a character that is neither an Arabic</span>
                    <span class="comment"># character, nor a parenthesis.</span>
</code></code></pre>

<p>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can&#39;t say:</p>

<pre><code><code> <span class="regex">/[\p{Thai}-\d]/</span>     <span class="comment"># Wrong!</span>
</code></code></pre>

<h3 id="POSIX-Character-Classes">POSIX Character Classes                 </h3>

<p>POSIX character classes have the form <code><code>[:class:]</code></code>, where <i>class</i> is name, and the <code><code>[:</code></code> and <code><code>:]</code></code> delimiters. POSIX character classes only appear <i>inside</i> bracketed character classes, and are a convenient and descriptive way of listing a group of characters.</p>

<p>Be careful about the syntax,</p>

<pre><code><code> # Correct:
 $string =~ /[[:alpha:]]/

 # Incorrect (will warn):
 $string =~ /[:alpha:]/</code></code></pre>

<p>The latter pattern would be a character class consisting of a colon, and the letters <code><code>a</code></code>, <code><code>l</code></code>, <code><code>p</code></code> and <code><code>h</code></code>. POSIX character classes can be part of a larger bracketed character class. For example,</p>

<pre><code><code> [01[:alpha:]%]</code></code></pre>

<p>is valid and matches &#39;0&#39;, &#39;1&#39;, any alphabetic character, and the percent sign.</p>

<p>Perl recognizes the following POSIX character classes:</p>

<pre><code><code> alpha  Any alphabetical character (&quot;[A-Za-z]&quot;).
 alnum  Any alphanumeric character. (&quot;[A-Za-z0-9]&quot;)
 ascii  Any character in the ASCII character set.
 blank  A GNU extension, equal to a space or a horizontal tab (&quot;\t&quot;).
 cntrl  Any control character.  See Note [2] below.
 digit  Any decimal digit (&quot;[0-9]&quot;), equivalent to &quot;\d&quot;.
 graph  Any printable character, excluding a space.  See Note [3] below.
 lower  Any lowercase character (&quot;[a-z]&quot;).
 print  Any printable character, including a space.  See Note [4] below.
 punct  Any graphical character excluding &quot;word&quot; characters.  Note [5].
 space  Any whitespace character. &quot;\s&quot; plus the vertical tab (&quot;\cK&quot;).
 upper  Any uppercase character (&quot;[A-Z]&quot;).
 word   A Perl extension (&quot;[A-Za-z0-9_]&quot;), equivalent to &quot;\w&quot;.
 xdigit Any hexadecimal digit (&quot;[0-9a-fA-F]&quot;).</code></code></pre>

<p>Most POSIX character classes have two Unicode-style <code><code>\p</code></code> property counterparts. (They are not official Unicode properties, but Perl extensions derived from official Unicode properties.) The table below shows the relation between POSIX character classes and these counterparts.</p>

<p>One counterpart, in the column labelled &quot;ASCII-range Unicode&quot; in the table, matches only characters in the ASCII character set.</p>

<p>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Alpha</span><span class="operator">}</span>
</code></code> matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</p>

<pre><code><code> <span class="operator">[[</span><span class="operator">:...:</span><span class="operator">]]</span>      <span class="variable">ASCII</span><span class="operator">-</span><span class="variable">range</span>          <span class="variable">Full</span><span class="operator">-</span><span class="variable">range</span>  <span class="variable">backslash</span>  <span class="variable">Note</span>
                 <span class="variable">Unicode</span>              <span class="variable">Unicode</span>     <span class="variable">sequence</span>
 <span class="operator">-----------------------------------------------------</span>
   <span class="variable">alpha</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixAlpha</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixAlpha</span><span class="operator">}</span>
   <span class="variable">alnum</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixAlnum</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixAlnum</span><span class="operator">}</span>
   <span class="variable">ascii</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">ASCII</span><span class="operator">}</span>
   <span class="variable">blank</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixBlank</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixBlank</span><span class="operator">}</span>  <span class="operator">\</span><span class="variable">h</span>      <span class="operator">[</span><span class="number">1</span><span class="operator">]</span>
                                   <span class="keyword">or</span> <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">HorizSpace</span><span class="operator">}</span>        <span class="operator">[</span><span class="number">1</span><span class="operator">]</span>
   <span class="variable">cntrl</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixCntrl</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixCntrl</span><span class="operator">}</span>          <span class="operator">[</span><span class="number">2</span><span class="operator">]</span>
   <span class="variable">digit</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixDigit</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixDigit</span><span class="operator">}</span>  <span class="operator">\</span><span class="variable">d</span>
   <span class="variable">graph</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixGraph</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixGraph</span><span class="operator">}</span>          <span class="operator">[</span><span class="number">3</span><span class="operator">]</span>
   <span class="variable">lower</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixLower</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixLower</span><span class="operator">}</span>
   <span class="keyword">print</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixPrint</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixPrint</span><span class="operator">}</span>          <span class="operator">[</span><span class="number">4</span><span class="operator">]</span>
   <span class="variable">punct</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixPunct</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixPunct</span><span class="operator">}</span>          <span class="operator">[</span><span class="number">5</span><span class="operator">]</span>
              <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PerlSpace</span><span class="operator">}</span>        <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPerlSpace</span><span class="operator">}</span>   <span class="operator">\</span><span class="regex">s      [6]
   s</span><span class="variable">pace</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixSpace</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixSpace</span><span class="operator">}</span>          <span class="operator">[</span><span class="number">6</span><span class="operator">]</span>
   <span class="variable">upper</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixUpper</span><span class="operator">}</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixUpper</span><span class="operator">}</span>
   <span class="variable">word</span>       <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixWord</span><span class="operator">}</span>        <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixWord</span><span class="operator">}</span>   <span class="operator">\</span><span class="variable">w</span>
   <span class="variable">xdigit</span>     <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixXDigit</span><span class="operator">}</span>      <span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixXDigit</span><span class="operator">}</span>
</code></code></pre>

<dl>

<dt id="pod-1-1">[1]</dt>
<dd>

<p><code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Blank</span><span class="operator">}</span>
</code></code> and <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">HorizSpace</span><span class="operator">}</span>
</code></code> are synonyms.</p>

</dd>
<dt id="pod-2-">[2]</dt>
<dd>

<p>Control characters don&#39;t produce output as such, but instead usually control the terminal somehow: for example, newline and backspace are control characters. In the ASCII range, characters whose code points are between 0 and 31 inclusive, plus 127 (<code><code>DEL</code></code>) are control characters.</p>

<p>On EBCDIC platforms, it is likely that the code page will define <code><code>[[:cntrl:]]</code></code> to be the EBCDIC equivalents of the ASCII controls, plus the controls that in Unicode have code pointss from 128 through 159.</p>

</dd>
<dt id="pod-3-">[3]</dt>
<dd>

<p>Any character that is <i>graphical</i>, that is, visible. This class consists of all alphanumeric characters and all punctuation characters.</p>

</dd>
<dt id="pod-4-">[4]</dt>
<dd>

<p>All printable characters, which is the set of all graphical characters plus those whitespace characters which are not also controls.</p>

</dd>
<dt id="pod-5-">[5]</dt>
<dd>

<p><code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixPunct</span><span class="operator">}</span>
</code></code> and <code><code>[[:punct:]]</code></code> in the ASCII range match all non-controls, non-alphanumeric, non-space characters: <code><code>[-!&quot;#$%&amp;&#39;()*+,./:;&lt;=&gt;?@[\\\]^_`{|}~]</code></code> (although if a locale is in effect, it could alter the behavior of <code><code>[[:punct:]]</code></code>).</p>

<p>The similarly named property, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Punct</span><span class="operator">}</span>
</code></code>, matches a somewhat different set in the ASCII range, namely <code><code>[-!&quot;#%&amp;&#39;()*,./:;?@[\\\]_{}]</code></code>. That is, it is missing the nine characters <code><code>[$+&lt;=&gt;^`|~]</code></code>. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</p>

<p><code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">XPosixPunct</span><span class="operator">}</span>
</code></code> and (under Unicode rules) <code><code>[[:punct:]]</code></code>, match what <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixPunct</span><span class="operator">}</span>
</code></code> matches in the ASCII range, plus what <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Punct</span><span class="operator">}</span>
</code></code> matches. This is different than strictly matching according to <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Punct</span><span class="operator">}</span>
</code></code>. Another way to say it is that if Unicode rules are in effect, <code><code>[[:punct:]]</code></code> matches all characters that Unicode considers punctuation, plus all ASCII-range characters that Unicode considers symbols.</p>

</dd>
<dt id="pod-6-">[6]</dt>
<dd>

<p><code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">SpacePerl</span><span class="operator">}</span>
</code></code> and <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Space</span><span class="operator">}</span>
</code></code> differ only in that in non-locale matching, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Space</span><span class="operator">}</span>
</code></code> additionally matches the vertical tab, <code><code>\cK</code></code>. Same for the two ASCII-only range forms.</p>

</dd>
</dl>

<p>There are various other synonyms that can be used besides the names listed in the table. For example, <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">PosixAlpha</span><span class="operator">}</span>
</code></code> can be written as <code><code><span class="operator">\</span><span class="variable">p</span><span class="operator">{</span><span class="variable">Alpha</span><span class="operator">}</span>
</code></code>. All are listed in <a href="../../lib/pods/perluniprops.html#Properties-accessible-through-p-and-P-">&quot;Properties accessible through \p{} and \P{}&quot; in perluniprops</a>, plus all characters matched by each ASCII-range property.</p>

<p>Both the <code><code>\p</code></code> counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</p>

<dl>

<dt id="If-the-a-modifier-is-in-effect-...2">If the <code><code>/a</code></code> modifier, is in effect ...</dt>
<dd>

<p>Each of the POSIX classes matches exactly the same as their ASCII-range counterparts.</p>

</dd>
<dt id="otherwise-...4">otherwise ...</dt>
<dd>

<dl>

<dt id="For-code-points-above-255-...2">For code points above 255 ...</dt>
<dd>

<p>The POSIX class matches the same as its Full-range counterpart.</p>

</dd>
<dt id="For-code-points-below-256-...2">For code points below 256 ...</dt>
<dd>

<dl>

<dt id="if-locale-rules-are-in-effect-...2">if locale rules are in effect ...</dt>
<dd>

<p>The POSIX class matches according to the locale, except that <code><code>word</code></code> uses the platform&#39;s native underscore character, no matter what the locale is.</p>

</dd>
<dt id="if-Unicode-rules-are-in-effect-or-if-on-an-EBCDIC-platform-...2">if Unicode rules are in effect or if on an EBCDIC platform ...</dt>
<dd>

<p>The POSIX class matches the same as the Full-range counterpart.</p>

</dd>
<dt id="otherwise-...5">otherwise ...</dt>
<dd>

<p>The POSIX class matches the same as the ASCII range counterpart.</p>

</dd>
</dl>

</dd>
</dl>

</dd>
</dl>

<p>Which rules apply are determined as described in <a href="../../lib/pods/perlre.html#Which-character-set-modifier-is-in-effect-">&quot;Which character set modifier is in effect?&quot; in perlre</a>.</p>

<p>It is proposed to change this behavior in a future release of Perl so that whether or not Unicode rules are in effect would not change the behavior: Outside of locale or an EBCDIC code page, the POSIX classes would behave like their ASCII-range counterparts. If you wish to comment on this proposal, send email to <code><code>perl5-porters@perl.org</code></code>.</p>

<h4 id="Negation-of-POSIX-character-classes">Negation of POSIX character classes </h4>

<p>A Perl extension to the POSIX character class is the ability to negate it. This is done by prefixing the class name with a caret (<code><code>^</code></code>). Some examples:</p>

<pre><code><code>     <span class="variable">POSIX</span>         <span class="variable">ASCII</span><span class="operator">-</span><span class="variable">range</span>     <span class="variable">Full</span><span class="operator">-</span><span class="variable">range</span>  <span class="variable">backslash</span>
                    <span class="variable">Unicode</span>         <span class="variable">Unicode</span>    <span class="variable">sequence</span>
      <span class="operator">-----------------------------------------------------</span>
      <span class="operator">[[</span><span class="operator">:^</span><span class="variable">digit</span><span class="operator">:</span><span class="operator">]]</span>   <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">PosixDigit</span><span class="operator">}</span>  <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">XPosixDigit</span><span class="operator">}</span>   <span class="operator">\</span><span class="variable">D</span>
      <span class="operator">[[</span><span class="operator">:^</span><span class="variable">space</span><span class="operator">:</span><span class="operator">]]</span>   <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">PosixSpace</span><span class="operator">}</span>  <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">XPosixSpace</span><span class="operator">}</span>
                <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">PerlSpace</span><span class="operator">}</span>   <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">XPerlSpace</span><span class="operator">}</span>    <span class="operator">\</span><span class="variable">S</span>
      <span class="operator">[[</span><span class="operator">:^</span><span class="variable">word</span><span class="operator">:</span><span class="operator">]]</span>    <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">PerlWord</span><span class="operator">}</span>    <span class="operator">\</span><span class="variable">P</span><span class="operator">{</span><span class="variable">XPosixWord</span><span class="operator">}</span>    <span class="operator">\</span><span class="variable">W</span>
</code></code></pre>

<p>The backslash sequence can mean either ASCII- or Full-range Unicode, depending on various factors as described in <a href="../../lib/pods/perlre.html#Which-character-set-modifier-is-in-effect-">&quot;Which character set modifier is in effect?&quot; in perlre</a>.</p>

<h4 id="and-.-.-">[= =] and [. .]</h4>

<p>Perl recognizes the POSIX character classes <code><code>[=class=]</code></code> and <code><code>[.class.]</code></code>, but does not (yet?) support them. Any attempt to use either construct raises an exception.</p>

<h4 id="Examples1">Examples</h4>

<pre><code><code> /[[:digit:]]/            # Matches a character that is a digit.
 /[01[:lower:]]/          # Matches a character that is either a
                          # lowercase letter, or &#39;0&#39; or &#39;1&#39;.
 /[[:digit:][:^xdigit:]]/ # Matches a character that can be anything
                          # except the letters &#39;a&#39; to &#39;f&#39;.  This is
                          # because the main character class is composed
                          # of two POSIX character classes that are ORed
                          # together, one that matches any digit, and
                          # the other that matches anything that isn&#39;t a
                          # hex digit.  The result matches all
                          # characters except the letters &#39;a&#39; to &#39;f&#39; and
                          # &#39;A&#39; to &#39;F&#39;.</code></code></pre>


</body>

</html>


