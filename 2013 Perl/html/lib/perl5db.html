<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../displayToc.js"></script>
<script language="JavaScript" src="../tocParas.js"></script>
<script language="JavaScript" src="../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../scineplex.css">
<title></title>
<link rel="stylesheet" href="../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#GENERAL-NOTES">GENERAL NOTES</a>
    <ul>
      <li><a href="#Why-not-use-more-lexicals-">Why not use more lexicals?</a></li>
      <li><a href="#Automated-variable-stacking-via">Automated variable stacking via </a></li>
      <li><a href="#The-trick">The  trick</a></li>
      <li><a href="#FLAGS-FLAGS-FLAGS">FLAGS, FLAGS, FLAGS</a></li>
      <li><a href="#What-are-those-comments-for-">What are those  comments for?</a></li>
    </ul>
  </li>
  <li><a href="#DATA-STRUCTURES-MAINTAINED-BY-CORE">DATA STRUCTURES MAINTAINED BY CORE</a></li>
  <li><a href="#DEBUGGER-STARTUP">DEBUGGER STARTUP</a>
    <ul>
      <li><a href="#STARTUP-ONLY-OPTIONS">STARTUP-ONLY OPTIONS</a>
        <ul>
          <li><a href="#SAMPLE-RCFILE">SAMPLE RCFILE</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#INTERNALS-DESCRIPTION">INTERNALS DESCRIPTION</a>
    <ul>
      <li><a href="#DEBUGGER-INTERFACE-VARIABLES">DEBUGGER INTERFACE VARIABLES</a>
        <ul>
          <li><a href="#IMPORTANT-INTERNAL-VARIABLES">IMPORTANT INTERNAL VARIABLES</a>
            <ul>
              <li><a href="#"></a></li>
              <li><a href="#1"></a></li>
              <li><a href="#2"></a></li>
              <li><a href="#3"></a></li>
              <li><a href="#4"></a></li>
              <li><a href="#5"></a></li>
              <li><a href="#6"></a></li>
              <li><a href="#7"></a></li>
              <li><a href="#8"></a></li>
              <li><a href="#9"></a></li>
              <li><a href="#10"></a></li>
              <li><a href="#11"></a></li>
              <li><a href="#12"></a></li>
              <li><a href="#13"></a></li>
              <li><a href="#14"></a></li>
              <li><a href="#15"></a></li>
              <li><a href="#16"></a></li>
              <li><a href="#17"></a></li>
              <li><a href="#18"></a></li>
              <li><a href="#19"></a></li>
              <li><a href="#20"></a></li>
              <li><a href="#21"></a></li>
              <li><a href="#22"></a></li>
              <li><a href="#23"></a></li>
              <li><a href="#24"></a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#DEBUGGER-INITIALIZATION">DEBUGGER INITIALIZATION</a></li>
  <li><a href="#DEBUGGER-ROUTINES">DEBUGGER ROUTINES</a>
    <ul>
      <li><a href="#25"></a>
        <ul>
          <li><a href="#Parameters-and-variables-influencing-execution-of-DB::eval-">Parameters and variables influencing execution of DB::eval()</a></li>
          <li><a href="#The-problem-of-lexicals">The problem of lexicals</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#DEBUGGER-INITIALIZATION1">DEBUGGER INITIALIZATION</a>
    <ul>
      <li><a href="#BASIC-SETUP">BASIC SETUP</a></li>
      <li><a href="#THREADS-SUPPORT">THREADS SUPPORT</a></li>
    </ul>
  </li>
  <li><a href="#OPTION-PROCESSING">OPTION PROCESSING</a>
    <ul>
      <li><a href="#SETTING-UP-THE-DEBUGGER-GREETING">SETTING UP THE DEBUGGER GREETING</a></li>
      <li><a href="#READING-THE-RC-FILE">READING THE RC FILE</a></li>
      <li><a href="#RESTART-PROCESSING">RESTART PROCESSING</a></li>
      <li><a href="#SETTING-UP-THE-TERMINAL">SETTING UP THE TERMINAL</a></li>
      <li><a href="#SOCKET-HANDLING">SOCKET HANDLING</a></li>
    </ul>
  </li>
  <li><a href="#SUBROUTINES">SUBROUTINES</a>
    <ul>
      <li><a href="#DB">DB</a></li>
      <li><a href="#26"></a></li>
      <li><a href="#GETTING-READY-TO-EXECUTE-COMMANDS">GETTING READY TO EXECUTE COMMANDS</a></li>
      <li><a href="#WHERE-ARE-WE-">WHERE ARE WE?</a></li>
      <li><a href="#THE-COMMAND-LOOP">THE COMMAND LOOP</a>
        <ul>
          <li>
            <ul>
              <li><a href="#The-null-command">The null command</a></li>
            </ul>
          </li>
          <li><a href="#COMMAND-ALIASES">COMMAND ALIASES</a></li>
          <li><a href="#MAIN-LINE-COMMANDS">MAIN-LINE COMMANDS</a>
            <ul>
              <li><a href="#quit"> - quit</a></li>
              <li><a href="#trace-n-"> - trace [n]</a></li>
              <li><a href="#list-subroutines-matching-not-matching-a-pattern"> - list subroutines matching/not matching a pattern</a></li>
              <li><a href="#list-variables-in-current-package"> - list variables in current package</a></li>
              <li><a href="#list-variables"> - list variables</a></li>
              <li><a href="#evaluate-and-print-an-expression"> - evaluate and print an expression</a></li>
              <li><a href="#print-methods"> - print methods</a></li>
              <li><a href="#switch-files"> - switch files</a></li>
              <li><a href="#return-to-last-executed-line."> - return to last-executed line.</a></li>
              <li><a href="#back-one-window"> - back one window</a></li>
            </ul>
          </li>
          <li><a href="#PRE-580-COMMANDS-VS.-NEW-COMMANDS:">PRE-580 COMMANDS VS. NEW COMMANDS: </a>
            <ul>
              <li><a href="#List-lexicals-in-higher-scope"> - List lexicals in higher scope</a></li>
            </ul>
          </li>
          <li><a href="#COMMANDS-NOT-WORKING-AFTER-PROGRAM-ENDS">COMMANDS NOT WORKING AFTER PROGRAM ENDS</a>
            <ul>
              <li><a href="#single-step-but-dont-trace-down-into-subs"> - single step, but don&#39;t trace down into subs</a></li>
              <li><a href="#single-step-entering-subs"> - single-step, entering subs</a></li>
              <li><a href="#run-continuously-setting-an-optional-breakpoint"> - run continuously, setting an optional breakpoint</a></li>
              <li><a href="#return-from-a-subroutine"> - return from a subroutine</a></li>
              <li><a href="#stack-trace"> - stack trace</a></li>
              <li><a href="#List-window-around-current-line."> - List window around current line.</a></li>
              <li><a href="#watch-expression-processing."> - watch-expression processing.</a></li>
              <li><a href="#search-forward-for-a-string-in-the-source"> - search forward for a string in the source</a></li>
              <li><a href="#search-backward-for-a-string-in-the-source"> - search backward for a string in the source</a></li>
              <li><a href="#Recall-command"> - Recall command</a></li>
              <li><a href="#command"> -  command</a></li>
              <li><a href="#Search-command-history"> - Search command history</a></li>
              <li><a href="#Invoke-a-shell"> - Invoke a shell</a></li>
              <li><a href="#Force-execution-of-a-command-in-a-shell"> - Force execution of a command in a shell</a></li>
              <li><a href="#display-commands-in-history"> - display commands in history</a></li>
              <li><a href="#look-up-documentation"> - look up documentation</a></li>
              <li><a href="#print"> - print</a></li>
              <li><a href="#define-command-alias"> - define command alias</a></li>
              <li><a href="#read-commands-from-a-file."> - read commands from a file.</a></li>
              <li><a href="#send-current-history-to-a-file"> - send current history to a file</a></li>
              <li><a href="#restart"> - restart</a></li>
              <li><a href="#rerun-the-current-session"> - rerun the current session</a></li>
              <li><a href="#pipe-output-through-the-pager."> - pipe output through the pager.</a></li>
            </ul>
          </li>
          <li><a href="#END-OF-COMMAND-PARSING">END OF COMMAND PARSING</a></li>
          <li><a href="#POST-COMMAND-PROCESSING">POST-COMMAND PROCESSING</a></li>
          <li><a href="#COMMAND-LOOP-TERMINATION">COMMAND LOOP TERMINATION</a></li>
        </ul>
      </li>
      <li><a href="#sub">sub</a>
        <ul>
          <li><a href="#support"> support</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#EXTENDED-COMMAND-HANDLING-AND-THE-COMMAND-API">EXTENDED COMMAND HANDLING AND THE COMMAND API</a>
    <ul>
      <li><a href="#27"></a></li>
      <li><a href="#API-"> (API)</a>
        <ul>
          <li><a href="#command-"> (command)</a></li>
          <li><a href="#command-1"> (command)</a></li>
          <li><a href="#API-1"> (API)</a></li>
          <li><a href="#command-2"> (command)</a></li>
          <li><a href="#API-2"> (API)</a></li>
          <li><a href="#API-3"> (API)</a></li>
          <li><a href="#command-3"> (command)</a></li>
          <li><a href="#API-package-global-"> (API package global)</a></li>
          <li><a href="#breakable_line-from-to-API-">breakable_line(from, to) (API)</a></li>
          <li><a href="#breakable_line_in_filename-file-from-to-API-">breakable_line_in_filename(file, from, to) (API)</a></li>
          <li><a href="#break_on_line-lineno-condition-API-">break_on_line(lineno, [condition]) (API)</a></li>
          <li><a href="#cmd_b_line-line-condition-command-">cmd_b_line(line, [condition]) (command)</a></li>
          <li><a href="#cmd_b_filename_line-line-condition-command-">cmd_b_filename_line(line, [condition]) (command)</a></li>
          <li><a href="#break_on_filename_line-file-line-condition-API-">break_on_filename_line(file, line, [condition]) (API)</a></li>
          <li><a href="#break_on_filename_line_range-file-from-to-condition-API-">break_on_filename_line_range(file, from, to, [condition]) (API)</a></li>
          <li><a href="#subroutine_filename_lines-subname-condition-API-">subroutine_filename_lines(subname, [condition]) (API)</a></li>
          <li><a href="#break_subroutine-subname-API-">break_subroutine(subname) (API)</a></li>
          <li><a href="#cmd_b_sub-subname-condition-command-">cmd_b_sub(subname, [condition]) (command)</a></li>
          <li><a href="#delete-breakpoint-s-command-"> - delete breakpoint(s) (command)</a></li>
          <li><a href="#delete_breakpoint-line-API-">delete_breakpoint([line]) (API)</a></li>
          <li><a href="#cmd_stop-command-">cmd_stop (command)</a></li>
          <li><a href="#threads"> - threads</a></li>
          <li><a href="#list-of-thread-ids"> - list of thread ids</a></li>
          <li><a href="#help-command-command-"> - help command (command)</a></li>
          <li><a href="#inheritance-display"> - inheritance display</a></li>
          <li><a href="#list-lines-command-"> - list lines (command)</a></li>
          <li><a href="#list-breakpoints-actions-and-watch-expressions-command-"> - list breakpoints, actions, and watch expressions (command)</a></li>
          <li><a href="#list-modules-command-"> - list modules (command)</a></li>
          <li><a href="#options-command-"> - options (command)</a></li>
          <li><a href="#nonexistent-in-5.8.x-command-"> - nonexistent in 5.8.x (command)</a></li>
          <li><a href="#view-window-command-"> - view window (command)</a></li>
          <li><a href="#add-a-watch-expression-command-"> - add a watch expression (command)</a></li>
          <li><a href="#delete-watch-expressions-command-"> - delete watch expressions (command)</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#SUPPORT-ROUTINES">SUPPORT ROUTINES</a>
    <ul>
      <li><a href="#save">save</a></li>
      <li><a href="#show-where-we-are-now"> - show where we are now</a></li>
      <li><a href="#28"></a></li>
      <li><a href="#29"></a></li>
      <li><a href="#30"></a></li>
      <li><a href="#31"></a></li>
      <li><a href="#dump_trace-skip-count-">dump_trace(skip[,count])</a></li>
      <li><a href="#32"></a></li>
      <li><a href="#unbalanced">unbalanced</a></li>
      <li><a href="#33"></a></li>
      <li><a href="#handle-calls-tosystem-without-messing-up-the-debugger"> - handle calls to&lt;system()&gt; without messing up the debugger</a></li>
    </ul>
  </li>
  <li><a href="#TTY-MANAGEMENT">TTY MANAGEMENT</a>
    <ul>
      <li><a href="#setterm">setterm</a></li>
    </ul>
  </li>
  <li><a href="#GET_FORK_TTY-EXAMPLE-FUNCTIONS">GET_FORK_TTY EXAMPLE FUNCTIONS</a>
    <ul>
      <li>
        <ul>
          <li><a href="#34"></a></li>
          <li><a href="#35"></a></li>
          <li><a href="#36"></a></li>
          <li><a href="#37"></a></li>
        </ul>
      </li>
      <li><a href="#38"></a></li>
      <li><a href="#39"></a></li>
      <li><a href="#40"></a></li>
    </ul>
  </li>
  <li><a href="#OPTIONS-SUPPORT-ROUTINES">OPTIONS SUPPORT ROUTINES</a>
    <ul>
      <li><a href="#list-the-current-value-of-an-option-setting"> - list the current value of an option setting</a></li>
      <li><a href="#find-the-current-value-of-an-option"> - find the current value of an option</a></li>
      <li><a href="#41"></a></li>
    </ul>
  </li>
  <li><a href="#RESTART-SUPPORT">RESTART SUPPORT</a>
    <ul>
      <li><a href="#set_list">set_list</a></li>
      <li><a href="#get_list">get_list</a></li>
    </ul>
  </li>
  <li><a href="#MISCELLANEOUS-SIGNAL-AND-I-O-MANAGEMENT">MISCELLANEOUS SIGNAL AND I/O MANAGEMENT</a>
    <ul>
      <li><a href="#catch-">catch()</a></li>
      <li><a href="#42"></a></li>
    </ul>
  </li>
  <li><a href="#INITIALIZATION-TTY-SUPPORT">INITIALIZATION TTY SUPPORT</a>
    <ul>
      <li><a href="#43"></a></li>
    </ul>
  </li>
  <li><a href="#OPTION-SUPPORT-ROUTINES">OPTION SUPPORT ROUTINES</a>
    <ul>
      <li><a href="#44"></a></li>
      <li><a href="#45"></a></li>
      <li><a href="#46"></a></li>
      <li><a href="#47"></a></li>
      <li><a href="#48"></a></li>
      <li><a href="#49"></a></li>
      <li><a href="#50"></a></li>
      <li><a href="#51"></a></li>
      <li><a href="#52"></a></li>
      <li><a href="#53"></a></li>
      <li><a href="#where-the-line-number-information-goes"> - where the line number information goes</a></li>
    </ul>
  </li>
  <li><a href="#COMMAND-SUPPORT-ROUTINES">COMMAND SUPPORT ROUTINES</a>
    <ul>
      <li><a href="#54"></a></li>
      <li><a href="#55"></a>
        <ul>
          <li><a href="#HELP-MESSAGE-FORMAT">HELP MESSAGE FORMAT</a></li>
        </ul>
      </li>
      <li><a href="#56"></a></li>
      <li><a href="#57"></a></li>
    </ul>
  </li>
  <li><a href="#DIE-AND-WARN-MANAGEMENT">DIE AND WARN MANAGEMENT</a>
    <ul>
      <li><a href="#58"></a></li>
      <li><a href="#59"></a></li>
      <li><a href="#60"></a></li>
      <li><a href="#61"></a></li>
      <li><a href="#62"></a></li>
      <li><a href="#63"></a></li>
    </ul>
  </li>
  <li><a href="#SUBROUTINE-DECODING-SUPPORT">SUBROUTINE DECODING SUPPORT</a>
    <ul>
      <li><a href="#64"></a></li>
      <li><a href="#coderef"> coderef</a></li>
      <li><a href="#65"></a></li>
      <li><a href="#66"></a></li>
      <li><a href="#67"></a></li>
      <li><a href="#figure-out-which-command-to-use-to-show-documentation"> - figure out which command to use to show documentation</a></li>
      <li><a href="#run-the-appropriate-command-to-show-documentation"> - run the appropriate command to show documentation</a></li>
    </ul>
  </li>
  <li><a href="#DEBUGGER-INITIALIZATION---THE-SECOND-BEGIN-BLOCK">DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK</a></li>
  <li><a href="#READLINE-SUPPORT---COMPLETION-FUNCTION">READLINE SUPPORT - COMPLETION FUNCTION</a>
    <ul>
      <li><a href="#db_complete">db_complete</a>
        <ul>
          <li><a href="#68"></a></li>
          <li><a href="#69"></a></li>
          <li><a href="#list-variable-and-list-modules-"> (list variable) and  (list modules)</a>
            <ul>
              <li><a href="#Unqualified-package-names">Unqualified package names</a></li>
              <li><a href="#Qualified-package-names">Qualified package names</a></li>
            </ul>
          </li>
          <li><a href="#switch-files1"> - switch files</a></li>
          <li><a href="#Subroutine-name-completion">Subroutine name completion</a></li>
          <li><a href="#Scalar-array-and-hash-completion:-partially-qualified-package">Scalar, array, and hash completion: partially qualified package</a></li>
          <li><a href="#Symbol-completion:-current-package-or-package-.">Symbol completion: current package or package .</a></li>
          <li><a href="#Options">Options</a></li>
          <li><a href="#Filename-completion">Filename completion</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#MISCELLANEOUS-SUPPORT-FUNCTIONS">MISCELLANEOUS SUPPORT FUNCTIONS</a>
    <ul>
      <li><a href="#end_report">end_report</a></li>
      <li><a href="#clean_ENV">clean_ENV</a></li>
    </ul>
  </li>
  <li><a href="#END-PROCESSING---THE-BLOCK">END PROCESSING - THE  BLOCK</a></li>
  <li><a href="#PRE-5.8-COMMANDS">PRE-5.8 COMMANDS</a>
    <ul>
      <li><a href="#Null-command">Null command</a></li>
      <li><a href="#Old-command.">Old  command.</a></li>
      <li><a href="#Old-command">Old  command</a></li>
      <li><a href="#Old-command.1">Old  command.</a></li>
      <li><a href="#Old-command1">Old  command</a></li>
      <li><a href="#Old-command2">Old  command</a></li>
    </ul>
  </li>
  <li><a href="#PRE-AND-POST-PROMPT-COMMANDS-AND-ACTIONS">PRE-AND-POST-PROMPT COMMANDS AND ACTIONS</a>
    <ul>
      <li><a href="#70"></a></li>
      <li><a href="#71"></a></li>
    </ul>
  </li>
  <li><a href="#72"></a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>perl5db.pl - the perl debugger</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    perl -d  your_Perl_script</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><code><code>perl5db.pl</code></code> is the perl debugger. It is loaded automatically by Perl when you invoke a script with <code><code>perl -d</code></code>. This documentation tries to outline the structure and services provided by <code><code>perl5db.pl</code></code>, and to describe how you can use them.</p>

<h1 id="GENERAL-NOTES">GENERAL NOTES</h1>

<p>The debugger can look pretty forbidding to many Perl programmers. There are a number of reasons for this, many stemming out of the debugger&#39;s history.</p>

<p>When the debugger was first written, Perl didn&#39;t have a lot of its nicer features - no references, no lexical variables, no closures, no object-oriented programming. So a lot of the things one would normally have done using such features was done using global variables, globs and the <code><code>local()</code></code> operator in creative ways.</p>

<p>Some of these have survived into the current debugger; a few of the more interesting and still-useful idioms are noted in this section, along with notes on the comments themselves.</p>

<h2 id="Why-not-use-more-lexicals-">Why not use more lexicals?</h2>

<p>Experienced Perl programmers will note that the debugger code tends to use mostly package globals rather than lexically-scoped variables. This is done to allow a significant amount of control of the debugger from outside the debugger itself.</p>

<p>Unfortunately, though the variables are accessible, they&#39;re not well documented, so it&#39;s generally been a decision that hasn&#39;t made a lot of difference to most users. Where appropriate, comments have been added to make variables more accessible and usable, with the understanding that these <i>are</i> debugger internals, and are therefore subject to change. Future development should probably attempt to replace the globals with a well-defined API, but for now, the variables are what we&#39;ve got.</p>

<h2 id="Automated-variable-stacking-via">Automated variable stacking via <code><code>local()</code></code></h2>

<p>As you may recall from reading <code><code>perlfunc</code></code>, the <code><code>local()</code></code> operator makes a temporary copy of a variable in the current scope. When the scope ends, the old copy is restored. This is often used in the debugger to handle the automatic stacking of variables during recursive calls:</p>

<pre><code><code>     <span class="keyword">sub</span><span class="variable"> foo </span><span class="operator">{</span>
        <span class="keyword">local</span> <span class="variable">$some_global</span><span class="operator">++;</span>
     
        <span class="comment"># Do some stuff, then ...</span>
        <span class="keyword">return</span><span class="operator">;</span>
     <span class="operator">}</span>
</code></code></pre>

<p>What happens is that on entry to the subroutine, <code><code>$some_global</code></code> is localized, then altered. When the subroutine returns, Perl automatically undoes the localization, restoring the previous value. Voila, automatic stack management.</p>

<p>The debugger uses this trick a <i>lot</i>. Of particular note is <code><code>DB::eval</code></code>, which lets the debugger get control inside of <code><code>eval</code></code>&#39;ed code. The debugger localizes a saved copy of <code><code>$@</code></code> inside the subroutine, which allows it to keep <code><code>$@</code></code> safe until it <code><code>DB::eval</code></code> returns, at which point the previous value of <code><code>$@</code></code> is restored. This makes it simple (well, <i>simpler</i>) to keep track of <code><code>$@</code></code> inside <code><code>eval</code></code>s which <code><code>eval</code></code> other <code><code>eval&#39;s</code></code>.</p>

<p>In any case, watch for this pattern. It occurs fairly often.</p>

<h2 id="The-trick">The <code><code>^</code></code> trick</h2>

<p>This is used to cleverly reverse the sense of a logical test depending on the value of an auxiliary variable. For instance, the debugger&#39;s <code><code>S</code></code> (search for subroutines by pattern) allows you to negate the pattern like this:</p>

<pre><code><code>   # Find all non-&#39;foo&#39; subs:
   S !/foo/      </code></code></pre>

<p>Boolean algebra states that the truth table for XOR looks like this:</p>

<ul>

<li><p>0 ^ 0 = 0</p>

<p>(! not present and no match) --&gt; false, don&#39;t print</p>

</li>
<li><p>0 ^ 1 = 1</p>

<p>(! not present and matches) --&gt; true, print</p>

</li>
<li><p>1 ^ 0 = 1</p>

<p>(! present and no match) --&gt; true, print</p>

</li>
<li><p>1 ^ 1 = 0</p>

<p>(! present and matches) --&gt; false, don&#39;t print</p>

</li>
</ul>

<p>As you can see, the first pair applies when <code><code>!</code></code> isn&#39;t supplied, and the second pair applies when it is. The XOR simply allows us to compact a more complicated if-then-elseif-else into a more elegant (but perhaps overly clever) single test. After all, it needed this explanation...</p>

<h2 id="FLAGS-FLAGS-FLAGS">FLAGS, FLAGS, FLAGS</h2>

<p>There is a certain C programming legacy in the debugger. Some variables, such as <code><code>$single</code></code>, <code><code>$trace</code></code>, and <code><code>$frame</code></code>, have <i>magical</i> values composed of 1, 2, 4, etc. (powers of 2) OR&#39;ed together. This allows several pieces of state to be stored independently in a single scalar.</p>

<p>A test like</p>

<pre><code><code>    if ($scalar &amp; 4) ...</code></code></pre>

<p>is checking to see if the appropriate bit is on. Since each bit can be &quot;addressed&quot; independently in this way, <code><code>$scalar</code></code> is acting sort of like an array of bits. Obviously, since the contents of <code><code>$scalar</code></code> are just a bit-pattern, we can save and restore it easily (it will just look like a number).</p>

<p>The problem, is of course, that this tends to leave magic numbers scattered all over your program whenever a bit is set, cleared, or checked. So why do it?</p>

<ul>

<li><p>First, doing an arithmetical or bitwise operation on a scalar is just about the fastest thing you can do in Perl: <code><code>use constant</code></code> actually creates a subroutine call, and array and hash lookups are much slower. Is this over-optimization at the expense of readability? Possibly, but the debugger accesses these variables a <i>lot</i>. Any rewrite of the code will probably have to benchmark alternate implementations and see which is the best balance of readability and speed, and then document how it actually works.</p>

</li>
<li><p>Second, it&#39;s very easy to serialize a scalar number. This is done in the restart code; the debugger state variables are saved in <code><code>%ENV</code></code> and then restored when the debugger is restarted. Having them be just numbers makes this trivial.</p>

</li>
<li><p>Third, some of these variables are being shared with the Perl core smack in the middle of the interpreter&#39;s execution loop. It&#39;s much faster for a C program (like the interpreter) to check a bit in a scalar than to access several different variables (or a Perl array).</p>

</li>
</ul>

<h2 id="What-are-those-comments-for-">What are those <code><code>XXX</code></code> comments for?</h2>

<p>Any comment containing <code><code>XXX</code></code> means that the comment is either somewhat speculative - it&#39;s not exactly clear what a given variable or chunk of code is doing, or that it is incomplete - the basics may be clear, but the subtleties are not completely documented.</p>

<p>Send in a patch if you can clear up, fill out, or clarify an <code><code>XXX</code></code>.</p>

<h1 id="DATA-STRUCTURES-MAINTAINED-BY-CORE">DATA STRUCTURES MAINTAINED BY CORE</h1>

<p>There are a number of special data structures provided to the debugger by the Perl interpreter.</p>

<p>The array <code><code><span class="variable">@</span><span class="operator">{</span><span class="variable">$main::</span><span class="operator">{</span><span class="string">'_&lt;'</span><span class="operator">.</span><span class="variable">$filename</span><span class="operator">}}</span>
</code></code> (aliased locally to <code><code>@dbline</code></code> via glob assignment) contains the text from <code><code>$filename</code></code>, with each element corresponding to a single line of <code><code>$filename</code></code>. Additionally, breakable lines will be dualvars with the numeric component being the memory address of a COP node. Non-breakable lines are dualvar to 0.</p>

<p>The hash <code><code><span class="variable">%</span><span class="operator">{</span><span class="string">'_&lt;'</span><span class="operator">.</span><span class="variable">$filename</span><span class="operator">}</span>
</code></code> (aliased locally to <code><code>%dbline</code></code> via glob assignment) contains breakpoints and actions. The keys are line numbers; you can set individual values, but not the whole hash. The Perl interpreter uses this hash to determine where breakpoints have been set. Any true value is considered to be a breakpoint; <code><code>perl5db.pl</code></code> uses <code><code>$break_condition\0$action</code></code>. Values are magical in numeric context: 1 if the line is breakable, 0 if not.</p>

<p>The scalar <code><code><span class="variable">$</span><span class="operator">{</span><span class="string">"_&lt;</span><span class="variable">$filename</span><span class="string">"</span><span class="operator">}</span>
</code></code> simply contains the string <code><code>_&lt;$filename</code></code>. This is also the case for evaluated strings that contain subroutines, or which are currently being executed. The $filename for <code><code>eval</code></code>ed strings looks like <code><code>(eval 34)</code></code> or <code><code>(re_eval 19)</code></code>.</p>

<h1 id="DEBUGGER-STARTUP">DEBUGGER STARTUP</h1>

<p>When <code><code>perl5db.pl</code></code> starts, it reads an rcfile (<code><code>perl5db.ini</code></code> for non-interactive sessions, <code><code>.perldb</code></code> for interactive ones) that can set a number of options. In addition, this file may define a subroutine <code><code>&amp;afterinit</code></code> that will be executed (in the debugger&#39;s context) after the debugger has initialized itself.</p>

<p>Next, it checks the <code><code>PERLDB_OPTS</code></code> environment variable and treats its contents as the argument of a <code><code>o</code></code> command in the debugger.</p>

<h2 id="STARTUP-ONLY-OPTIONS">STARTUP-ONLY OPTIONS</h2>

<p>The following options can only be specified at startup. To set them in your rcfile, add a call to <code><code>&amp;parse_options(&quot;optionName=new_value&quot;)</code></code>.</p>

<ul>

<li><p>TTY</p>

<p>the TTY to use for debugging i/o.</p>

</li>
<li><p>noTTY</p>

<p>if set, goes in NonStop mode. On interrupt, if TTY is not set, uses the value of noTTY or <i>$HOME/.perldbtty$$</i> to find TTY using Term::Rendezvous. Current variant is to have the name of TTY in this file.</p>

</li>
<li><p>ReadLine</p>

<p>if false, a dummy ReadLine is used, so you can debug ReadLine applications.</p>

</li>
<li><p>NonStop</p>

<p>if true, no i/o is performed until interrupt.</p>

</li>
<li><p>LineInfo</p>

<p>file or pipe to print line number info to. If it is a pipe, a short &quot;emacs like&quot; message is used.</p>

</li>
<li><p>RemotePort</p>

<p>host:port to connect to on remote host for remote debugging.</p>

</li>
<li><p>HistFile</p>

<p>file to store session history to. There is no default and so no history file is written unless this variable is explicitly set.</p>

</li>
<li><p>HistSize</p>

<p>number of commands to store to the file specified in <code><code>HistFile</code></code>. Default is 100.</p>

</li>
</ul>

<h3 id="SAMPLE-RCFILE">SAMPLE RCFILE</h3>

<pre><code><code> <span class="operator">&amp;</span><span class="variable">parse_options</span><span class="operator">(</span><span class="string">"NonStop=1 LineInfo=db.out"</span><span class="operator">);</span>
  <span class="keyword">sub</span><span class="variable"> afterinit </span><span class="operator">{</span> <span class="variable">$trace</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span> <span class="operator">}</span>
</code></code></pre>

<p>The script will run without human intervention, putting trace information into <code><code>db.out</code></code>. (If you interrupt it, you had better reset <code><code>LineInfo</code></code> to something <i>interactive</i>!)</p>

<h1 id="INTERNALS-DESCRIPTION">INTERNALS DESCRIPTION</h1>

<h2 id="DEBUGGER-INTERFACE-VARIABLES">DEBUGGER INTERFACE VARIABLES</h2>

<p>Perl supplies the values for <code><code>%sub</code></code>. It effectively inserts a <code><code><span class="operator">&amp;</span><span class="variable">DB::DB</span><span class="operator">();</span>
</code></code> in front of each place that can have a breakpoint. At each subroutine call, it calls <code><code>&amp;DB::sub</code></code> with <code><code>$DB::sub</code></code> set to the called subroutine. It also inserts a <code><code><span class="keyword">BEGIN</span> <span class="operator">{</span><span class="keyword">require</span> <span class="string">'perl5db.pl'</span><span class="operator">}</span>
</code></code> before the first line.</p>

<p>After each <code><code>require</code></code>d file is compiled, but before it is executed, a call to <code><code><span class="operator">&amp;</span><span class="variable">DB::postponed</span><span class="operator">(</span><span class="variable">$main::</span><span class="operator">{</span><span class="string">'_&lt;'</span><span class="operator">.</span><span class="variable">$filename</span><span class="operator">}</span><span class="operator">)</span>
</code></code> is done. <code><code>$filename</code></code> is the expanded name of the <code><code>require</code></code>d file (as found via <code><code>%INC</code></code>).</p>

<h3 id="IMPORTANT-INTERNAL-VARIABLES">IMPORTANT INTERNAL VARIABLES</h3>

<h4 id=""><code><code>$CreateTTY</code></code></h4>

<p>Used to control when the debugger will attempt to acquire another TTY to be used for input.</p>

<ul>

<li><p>1 - on <code><code>fork()</code></code></p>

</li>
<li><p>2 - debugger is started inside debugger</p>

</li>
<li><p>4 - on startup</p>

</li>
</ul>

<h4 id="1"><code><code>$doret</code></code></h4>

<p>The value -2 indicates that no return value should be printed. Any other positive value causes <code><code>DB::sub</code></code> to print return values.</p>

<h4 id="2"><code><code>$evalarg</code></code></h4>

<p>The item to be eval&#39;ed by <code><code>DB::eval</code></code>. Used to prevent messing with the current contents of <code><code>@_</code></code> when <code><code>DB::eval</code></code> is called.</p>

<h4 id="3"><code><code>$frame</code></code></h4>

<p>Determines what messages (if any) will get printed when a subroutine (or eval) is entered or exited.</p>

<ul>

<li><p>0 - No enter/exit messages</p>

</li>
<li><p>1 - Print <i>entering</i> messages on subroutine entry</p>

</li>
<li><p>2 - Adds exit messages on subroutine exit. If no other flag is on, acts like 1+2.</p>

</li>
<li><p>4 - Extended messages: <code><code>&lt;in|out&gt; </code><i><code>context</code></i><code>=</code><i><code>fully-qualified sub name</code></i><code> from </code><i><code>file</code></i><code>:</code><i><code>line</code></i></code>. If no other flag is on, acts like 1+4.</p>

</li>
<li><p>8 - Adds parameter information to messages, and overloaded stringify and tied FETCH is enabled on the printed arguments. Ignored if <code><code>4</code></code> is not on.</p>

</li>
<li><p>16 - Adds <code><i><code>context</code></i><code> return from </code><i><code>subname</code></i><code>: </code><i><code>value</code></i></code> messages on subroutine/eval exit. Ignored if <code><code>4</code></code> is is not on.</p>

</li>
</ul>

<p>To get everything, use <code><code>$frame=30</code></code> (or <code><code>o f=30</code></code> as a debugger command). The debugger internally juggles the value of <code><code>$frame</code></code> during execution to protect external modules that the debugger uses from getting traced.</p>

<h4 id="4"><code><code>$level</code></code></h4>

<p>Tracks current debugger nesting level. Used to figure out how many <code><code>&lt;&gt;</code></code> pairs to surround the line number with when the debugger outputs a prompt. Also used to help determine if the program has finished during command parsing.</p>

<h4 id="5"><code><code>$onetimeDump</code></code></h4>

<p>Controls what (if anything) <code><code>DB::eval()</code></code> will print after evaluating an expression.</p>

<ul>

<li><p><code><code>undef</code></code> - don&#39;t print anything</p>

</li>
<li><p><code><code>dump</code></code> - use <code><code>dumpvar.pl</code></code> to display the value returned</p>

</li>
<li><p><code><code>methods</code></code> - print the methods callable on the first item returned</p>

</li>
</ul>

<h4 id="6"><code><code>$onetimeDumpDepth</code></code></h4>

<p>Controls how far down <code><code>dumpvar.pl</code></code> will go before printing <code><code>...</code></code> while dumping a structure. Numeric. If <code><code>undef</code></code>, print all levels.</p>

<h4 id="7"><code><code>$signal</code></code></h4>

<p>Used to track whether or not an <code><code>INT</code></code> signal has been detected. <code><code>DB::DB()</code></code>, which is called before every statement, checks this and puts the user into command mode if it finds <code><code>$signal</code></code> set to a true value.</p>

<h4 id="8"><code><code>$single</code></code></h4>

<p>Controls behavior during single-stepping. Stacked in <code><code>@stack</code></code> on entry to each subroutine; popped again at the end of each subroutine.</p>

<ul>

<li><p>0 - run continuously.</p>

</li>
<li><p>1 - single-step, go into subs. The <code><code>s</code></code> command.</p>

</li>
<li><p>2 - single-step, don&#39;t go into subs. The <code><code>n</code></code> command.</p>

</li>
<li><p>4 - print current sub depth (turned on to force this when <code><code>too much recursion</code></code> occurs.</p>

</li>
</ul>

<h4 id="9"><code><code>$trace</code></code></h4>

<p>Controls the output of trace information.</p>

<ul>

<li><p>1 - The <code><code>t</code></code> command was entered to turn on tracing (every line executed is printed)</p>

</li>
<li><p>2 - watch expressions are active</p>

</li>
<li><p>4 - user defined a <code><code>watchfunction()</code></code> in <code><code>afterinit()</code></code></p>

</li>
</ul>

<h4 id="10"><code><code>$slave_editor</code></code></h4>

<p>1 if <code><code>LINEINFO</code></code> was directed to a pipe; 0 otherwise.</p>

<h4 id="11"><code><code>@cmdfhs</code></code></h4>

<p>Stack of filehandles that <code><code>DB::readline()</code></code> will read commands from. Manipulated by the debugger&#39;s <code><code>source</code></code> command and <code><code>DB::readline()</code></code> itself.</p>

<h4 id="12"><code><code>@dbline</code></code></h4>

<p>Local alias to the magical line array, <code><code><span class="variable">@</span><span class="operator">{</span><span class="variable">$main::</span><span class="operator">{</span><span class="string">'_&lt;'</span><span class="operator">.</span><span class="variable">$filename</span><span class="operator">}}</span>
</code></code> , supplied by the Perl interpreter to the debugger. Contains the source.</p>

<h4 id="13"><code><code>@old_watch</code></code></h4>

<p>Previous values of watch expressions. First set when the expression is entered; reset whenever the watch expression changes.</p>

<h4 id="14"><code><code>@saved</code></code></h4>

<p>Saves important globals (<code><code>$@</code></code>, <code><code>$!</code></code>, <code><code>$^E</code></code>, <code><code>$,</code></code>, <code><code>$/</code></code>, <code><code>$\</code></code>, <code><code>$^W</code></code>) so that the debugger can substitute safe values while it&#39;s running, and restore them when it returns control.</p>

<h4 id="15"><code><code>@stack</code></code></h4>

<p>Saves the current value of <code><code>$single</code></code> on entry to a subroutine. Manipulated by the <code><code>c</code></code> command to turn off tracing in all subs above the current one.</p>

<h4 id="16"><code><code>@to_watch</code></code></h4>

<p>The &#39;watch&#39; expressions: to be evaluated before each line is executed.</p>

<h4 id="17"><code><code>@typeahead</code></code></h4>

<p>The typeahead buffer, used by <code><code>DB::readline</code></code>.</p>

<h4 id="18"><code><code>%alias</code></code></h4>

<p>Command aliases. Stored as character strings to be substituted for a command entered.</p>

<h4 id="19"><code><code>%break_on_load</code></code></h4>

<p>Keys are file names, values are 1 (break when this file is loaded) or undef (don&#39;t break when it is loaded).</p>

<h4 id="20"><code><code>%dbline</code></code></h4>

<p>Keys are line numbers, values are <code><code>condition\0action</code></code>. If used in numeric context, values are 0 if not breakable, 1 if breakable, no matter what is in the actual hash entry.</p>

<h4 id="21"><code><code>%had_breakpoints</code></code></h4>

<p>Keys are file names; values are bitfields:</p>

<ul>

<li><p>1 - file has a breakpoint in it.</p>

</li>
<li><p>2 - file has an action in it.</p>

</li>
</ul>

<p>A zero or undefined value means this file has neither.</p>

<h4 id="22"><code><code>%option</code></code></h4>

<p>Stores the debugger options. These are character string values.</p>

<h4 id="23"><code><code>%postponed</code></code></h4>

<p>Saves breakpoints for code that hasn&#39;t been compiled yet. Keys are subroutine names, values are:</p>

<ul>

<li><p><code><code>compile</code></code> - break when this sub is compiled</p>

</li>
<li><p><code><code>break +0 if &lt;condition&gt;</code></code> - break (conditionally) at the start of this routine. The condition will be &#39;1&#39; if no condition was specified.</p>

</li>
</ul>

<h4 id="24"><code><code>%postponed_file</code></code></h4>

<p>This hash keeps track of breakpoints that need to be set for files that have not yet been compiled. Keys are filenames; values are references to hashes. Each of these hashes is keyed by line number, and its values are breakpoint definitions (<code><code>condition\0action</code></code>).</p>

<h1 id="DEBUGGER-INITIALIZATION">DEBUGGER INITIALIZATION</h1>

<p>The debugger&#39;s initialization actually jumps all over the place inside this package. This is because there are several BEGIN blocks (which of course execute immediately) spread through the code. Why is that?</p>

<p>The debugger needs to be able to change some things and set some things up before the debugger code is compiled; most notably, the <code><code>$deep</code></code> variable that <code><code>DB::sub</code></code> uses to tell when a program has recursed deeply. In addition, the debugger has to turn off warnings while the debugger code is compiled, but then restore them to their original setting before the program being debugged begins executing.</p>

<p>The first <code><code>BEGIN</code></code> block simply turns off warnings by saving the current setting of <code><code>$^W</code></code> and then setting it to zero. The second one initializes the debugger variables that are needed before the debugger begins executing. The third one puts <code><code>$^X</code></code> back to its former value.</p>

<p>We&#39;ll detail the second <code><code>BEGIN</code></code> block later; just remember that if you need to initialize something before the debugger starts really executing, that&#39;s where it has to go.</p>

<h1 id="DEBUGGER-ROUTINES">DEBUGGER ROUTINES</h1>

<h2 id="25"><code><code>DB::eval()</code></code></h2>

<p>This function replaces straight <code><code>eval()</code></code> inside the debugger; it simplifies the process of evaluating code in the user&#39;s context.</p>

<p>The code to be evaluated is passed via the package global variable <code><code>$DB::evalarg</code></code>; this is done to avoid fiddling with the contents of <code><code>@_</code></code>.</p>

<p>Before we do the <code><code>eval()</code></code>, we preserve the current settings of <code><code>$trace</code></code>, <code><code>$single</code></code>, <code><code>$^D</code></code> and <code><code>$usercontext</code></code>. The latter contains the preserved values of <code><code>$@</code></code>, <code><code>$!</code></code>, <code><code>$^E</code></code>, <code><code>$,</code></code>, <code><code>$/</code></code>, <code><code>$\</code></code>, <code><code>$^W</code></code> and the user&#39;s current package, grabbed when <code><code>DB::DB</code></code> got control. This causes the proper context to be used when the eval is actually done. Afterward, we restore <code><code>$trace</code></code>, <code><code>$single</code></code>, and <code><code>$^D</code></code>.</p>

<p>Next we need to handle <code><code>$@</code></code> without getting confused. We save <code><code>$@</code></code> in a local lexical, localize <code><code>$saved[0]</code></code> (which is where <code><code>save()</code></code> will put <code><code>$@</code></code>), and then call <code><code>save()</code></code> to capture <code><code>$@</code></code>, <code><code>$!</code></code>, <code><code>$^E</code></code>, <code><code>$,</code></code>, <code><code>$/</code></code>, <code><code>$\</code></code>, and <code><code>$^W</code></code>) and set <code><code>$,</code></code>, <code><code>$/</code></code>, <code><code>$\</code></code>, and <code><code>$^W</code></code> to values considered sane by the debugger. If there was an <code><code>eval()</code></code> error, we print it on the debugger&#39;s output. If <code><code>$onetimedump</code></code> is defined, we call <code><code>dumpit</code></code> if it&#39;s set to &#39;dump&#39;, or <code><code>methods</code></code> if it&#39;s set to &#39;methods&#39;. Setting it to something else causes the debugger to do the eval but not print the result - handy if you want to do something else with it (the &quot;watch expressions&quot; code does this to get the value of the watch expression but not show it unless it matters).</p>

<p>In any case, we then return the list of output from <code><code>eval</code></code> to the caller, and unwinding restores the former version of <code><code>$@</code></code> in <code><code>@saved</code></code> as well (the localization of <code><code>$saved[0]</code></code> goes away at the end of this scope).</p>

<h3 id="Parameters-and-variables-influencing-execution-of-DB::eval-">Parameters and variables influencing execution of DB::eval()</h3>

<p><code><code>DB::eval</code></code> isn&#39;t parameterized in the standard way; this is to keep the debugger&#39;s calls to <code><code>DB::eval()</code></code> from mucking with <code><code>@_</code></code>, among other things. The variables listed below influence <code><code>DB::eval()</code></code>&#39;s execution directly.</p>

<dl>

<dt id="evalarg---the-thing-to-actually-be-evaled"><code><code>$evalarg</code></code> - the thing to actually be eval&#39;ed</dt>
<dd>

</dd>
<dt id="trace---Current-state-of-execution-tracing"><code><code>$trace</code></code> - Current state of execution tracing</dt>
<dd>

</dd>
<dt id="single---Current-state-of-single-stepping"><code><code>$single</code></code> - Current state of single-stepping</dt>
<dd>

</dd>
<dt id="onetimeDump---what-is-to-be-displayed-after-the-evaluation"><code><code>$onetimeDump</code></code> - what is to be displayed after the evaluation</dt>
<dd>

</dd>
<dt id="onetimeDumpDepth---how-deep-dumpit-should-go-when-dumping-results"><code><code>$onetimeDumpDepth</code></code> - how deep <code><code>dumpit()</code></code> should go when dumping results</dt>
<dd>

</dd>
</dl>

<p>The following variables are altered by <code><code>DB::eval()</code></code> during its execution. They are &quot;stacked&quot; via <code><code>local()</code></code>, enabling recursive calls to <code><code>DB::eval()</code></code>.</p>

<dl>

<dt id="res---used-to-capture-output-from-actual-eval."><code><code>@res</code></code> - used to capture output from actual <code><code>eval</code></code>.</dt>
<dd>

</dd>
<dt id="otrace---saved-value-of-trace."><code><code>$otrace</code></code> - saved value of <code><code>$trace</code></code>.</dt>
<dd>

</dd>
<dt id="osingle---saved-value-of-single."><code><code>$osingle</code></code> - saved value of <code><code>$single</code></code>.</dt>
<dd>

</dd>
<dt id="od---saved-value-of-D."><code><code>$od</code></code> - saved value of <code><code>$^D</code></code>.</dt>
<dd>

</dd>
<dt id="saved-0---saved-value-of-."><code><code>$saved[0]</code></code> - saved value of <code><code>$@</code></code>.</dt>
<dd>

</dd>
<dt id="for-output-of-if-there-is-an-evaluation-error.">$\ - for output of <code><code>$@</code></code> if there is an evaluation error.</dt>
<dd>

</dd>
</dl>

<h3 id="The-problem-of-lexicals">The problem of lexicals</h3>

<p>The context of <code><code>DB::eval()</code></code> presents us with some problems. Obviously, we want to be &#39;sandboxed&#39; away from the debugger&#39;s internals when we do the eval, but we need some way to control how punctuation variables and debugger globals are used.</p>

<p>We can&#39;t use local, because the code inside <code><code>DB::eval</code></code> can see localized variables; and we can&#39;t use <code><code>my</code></code> either for the same reason. The code in this routine compromises and uses <code><code>my</code></code>.</p>

<p>After this routine is over, we don&#39;t have user code executing in the debugger&#39;s context, so we can use <code><code>my</code></code> freely.</p>

<h1 id="DEBUGGER-INITIALIZATION1">DEBUGGER INITIALIZATION</h1>

<p>The debugger starts up in phases.</p>

<h2 id="BASIC-SETUP">BASIC SETUP</h2>

<p>First, it initializes the environment it wants to run in: turning off warnings during its own compilation, defining variables which it will need to avoid warnings later, setting itself up to not exit when the program terminates, and defaulting to printing return values for the <code><code>r</code></code> command.</p>

<h2 id="THREADS-SUPPORT">THREADS SUPPORT</h2>

<p>If we are running under a threaded Perl, we require threads and threads::shared if the environment variable <code><code>PERL5DB_THREADED</code></code> is set, to enable proper threaded debugger control. <code><code>-dt</code></code> can also be used to set this.</p>

<p>Each new thread will be announced and the debugger prompt will always inform you of each new thread created. It will also indicate the thread id in which we are currently running within the prompt like this:</p>

<pre><code><code>        [tid] DB&lt;$i&gt;</code></code></pre>

<p>Where <code><code>[tid]</code></code> is an integer thread id and <code><code>$i</code></code> is the familiar debugger command prompt. The prompt will show: <code><code>[0]</code></code> when running under threads, but not actually in a thread. <code><code>[tid]</code></code> is consistent with <code><code>gdb</code></code> usage.</p>

<p>While running under threads, when you set or delete a breakpoint (etc.), this will apply to all threads, not just the currently running one. When you are in a currently executing thread, you will stay there until it completes. With the current implementation it is not currently possible to hop from one thread to another.</p>

<p>The <code><code>e</code></code> and <code><code>E</code></code> commands are currently fairly minimal - see <code><code>h e</code></code> and <code><code>h E</code></code>.</p>

<p>Note that threading support was built into the debugger as of Perl version <code><code>5.8.6</code></code> and debugger version <code><code>1.2.8</code></code>.</p>

<h1 id="OPTION-PROCESSING">OPTION PROCESSING</h1>

<p>The debugger&#39;s options are actually spread out over the debugger itself and <code><code>dumpvar.pl</code></code>; some of these are variables to be set, while others are subs to be called with a value. To try to make this a little easier to manage, the debugger uses a few data structures to define what options are legal and how they are to be processed.</p>

<p>First, the <code><code>@options</code></code> array defines the <i>names</i> of all the options that are to be accepted.</p>

<p>Second, <code><code>optionVars</code></code> lists the variables that each option uses to save its state.</p>

<p>Third, <code><code>%optionAction</code></code> defines the subroutine to be called to process each option.</p>

<p>Last, the <code><code>%optionRequire</code></code> notes modules that must be <code><code>require</code></code>d if an option is used.</p>

<p>There are a number of initialization-related variables which can be set by putting code to set them in a BEGIN block in the <code><code>PERL5DB</code></code> environment variable. These are:</p>

<dl>

<dt id="rl---readline-control-XXX-needs-more-explanation"><code><code>$rl</code></code> - readline control XXX needs more explanation</dt>
<dd>

</dd>
<dt id="warnLevel---whether-or-not-debugger-takes-over-warning-handling"><code><code>$warnLevel</code></code> - whether or not debugger takes over warning handling</dt>
<dd>

</dd>
<dt id="dieLevel---whether-or-not-debugger-takes-over-die-handling"><code><code>$dieLevel</code></code> - whether or not debugger takes over die handling</dt>
<dd>

</dd>
<dt id="signalLevel---whether-or-not-debugger-takes-over-signal-handling"><code><code>$signalLevel</code></code> - whether or not debugger takes over signal handling</dt>
<dd>

</dd>
<dt id="pre---preprompt-actions-array-reference-"><code><code>$pre</code></code> - preprompt actions (array reference)</dt>
<dd>

</dd>
<dt id="post---postprompt-actions-array-reference-"><code><code>$post</code></code> - postprompt actions (array reference)</dt>
<dd>

</dd>
<dt id="pretype"><code><code>$pretype</code></code></dt>
<dd>

</dd>
<dt id="CreateTTY---whether-or-not-to-create-a-new-TTY-for-this-debugger"><code><code>$CreateTTY</code></code> - whether or not to create a new TTY for this debugger</dt>
<dd>

</dd>
<dt id="CommandSet---which-command-set-to-use-defaults-to-new-documented-set-"><code><code>$CommandSet</code></code> - which command set to use (defaults to new, documented set)</dt>
<dd>

</dd>
</dl>

<p>The default <code><code>die</code></code>, <code><code>warn</code></code>, and <code><code>signal</code></code> handlers are set up.</p>

<p>The pager to be used is needed next. We try to get it from the environment first. If it&#39;s not defined there, we try to find it in the Perl <code><code>Config.pm</code></code>. If it&#39;s not there, we default to <code><code>more</code></code>. We then call the <code><code>pager()</code></code> function to save the pager name.</p>

<p>We set up the command to be used to access the man pages, the command recall character (<code><code>!</code></code> unless otherwise defined) and the shell escape character (<code><code>!</code></code> unless otherwise defined). Yes, these do conflict, and neither works in the debugger at the moment.</p>

<p>We then set up the gigantic string containing the debugger help. We also set the limit on the number of arguments we&#39;ll display during a trace.</p>

<h2 id="SETTING-UP-THE-DEBUGGER-GREETING">SETTING UP THE DEBUGGER GREETING</h2>

<p>The debugger <i>greeting</i> helps to inform the user how many debuggers are running, and whether the current debugger is the primary or a child.</p>

<p>If we are the primary, we just hang onto our pid so we&#39;ll have it when or if we start a child debugger. If we are a child, we&#39;ll set things up so we&#39;ll have a unique greeting and so the parent will give us our own TTY later.</p>

<p>We save the current contents of the <code><code>PERLDB_PIDS</code></code> environment variable because we mess around with it. We&#39;ll also need to hang onto it because we&#39;ll need it if we restart.</p>

<p>Child debuggers make a label out of the current PID structure recorded in PERLDB_PIDS plus the new PID. They also mark themselves as not having a TTY yet so the parent will give them one later via <code><code>resetterm()</code></code>.</p>

<h2 id="READING-THE-RC-FILE">READING THE RC FILE</h2>

<p>The debugger will read a file of initialization options if supplied. If running interactively, this is <code><code>.perldb</code></code>; if not, it&#39;s <code><code>perldb.ini</code></code>.</p>

<p>The debugger does a safety test of the file to be read. It must be owned either by the current user or root, and must only be writable by the owner.</p>

<p>The last thing we do during initialization is determine which subroutine is to be used to obtain a new terminal when a new debugger is started. Right now, the debugger only handles TCP sockets, X11, OS/2, amd Mac OS X (darwin).</p>

<h2 id="RESTART-PROCESSING">RESTART PROCESSING</h2>

<p>This section handles the restart command. When the <code><code>R</code></code> command is invoked, it tries to capture all of the state it can into environment variables, and then sets <code><code>PERLDB_RESTART</code></code>. When we start executing again, we check to see if <code><code>PERLDB_RESTART</code></code> is there; if so, we reload all the information that the R command stuffed into the environment variables.</p>

<pre><code><code>  PERLDB_RESTART   - flag only, contains no restart data itself.       
  PERLDB_HIST      - command history, if it&#39;s available
  PERLDB_ON_LOAD   - breakpoints set by the rc file
  PERLDB_POSTPONE  - subs that have been loaded/not executed, and have actions
  PERLDB_VISITED   - files that had breakpoints
  PERLDB_FILE_...  - breakpoints for a file
  PERLDB_OPT       - active options
  PERLDB_INC       - the original @INC
  PERLDB_PRETYPE   - preprompt debugger actions
  PERLDB_PRE       - preprompt Perl code
  PERLDB_POST      - post-prompt Perl code
  PERLDB_TYPEAHEAD - typeahead captured by readline()</code></code></pre>

<p>We chug through all these variables and plug the values saved in them back into the appropriate spots in the debugger.</p>

<h2 id="SETTING-UP-THE-TERMINAL">SETTING UP THE TERMINAL</h2>

<p>Now, we&#39;ll decide how the debugger is going to interact with the user. If there&#39;s no TTY, we set the debugger to run non-stop; there&#39;s not going to be anyone there to enter commands.</p>

<p>If there is a TTY, we have to determine who it belongs to before we can proceed. If this is a slave editor or graphical debugger (denoted by the first command-line switch being &#39;-emacs&#39;), we shift this off and set <code><code>$rl</code></code> to 0 (XXX ostensibly to do straight reads).</p>

<p>We then determine what the console should be on various systems:</p>

<ul>

<li><p>Cygwin - We use <code><code>stdin</code></code> instead of a separate device.</p>

</li>
<li><p>Unix - use <code><code>/dev/tty</code></code>.</p>

</li>
<li><p>Windows or MSDOS - use <code><code>con</code></code>.</p>

</li>
<li><p>VMS - use <code><code>sys$command</code></code>.</p>

</li>
</ul>

<p>Several other systems don&#39;t use a specific console. We <code><code>undef $console</code></code> for those (Windows using a slave editor/graphical debugger, NetWare, OS/2 with a slave editor, Epoc).</p>

<p>If there is a TTY hanging around from a parent, we use that as the console.</p>

<h2 id="SOCKET-HANDLING">SOCKET HANDLING</h2>

<p>The debugger is capable of opening a socket and carrying out a debugging session over the socket.</p>

<p>If <code><code>RemotePort</code></code> was defined in the options, the debugger assumes that it should try to start a debugging session on that port. It builds the socket and then tries to connect the input and output filehandles to it.</p>

<p>If no <code><code>RemotePort</code></code> was defined, and we want to create a TTY on startup, this is probably a situation where multiple debuggers are running (for example, a backticked command that starts up another debugger). We create a new IN and OUT filehandle, and do the necessary mojo to create a new TTY if we know how and if we can.</p>

<p>To finish initialization, we show the debugger greeting, and then call the <code><code>afterinit()</code></code> subroutine if there is one.</p>

<h1 id="SUBROUTINES">SUBROUTINES</h1>

<h2 id="DB">DB</h2>

<p>This gigantic subroutine is the heart of the debugger. Called before every statement, its job is to determine if a breakpoint has been reached, and stop if so; read commands from the user, parse them, and execute them, and then send execution off to the next statement.</p>

<p>Note that the order in which the commands are processed is very important; some commands earlier in the loop will actually alter the <code><code>$cmd</code></code> variable to create other commands to be executed later. This is all highly <i>optimized</i> but can be confusing. Check the comments for each <code><code><span class="variable">$cmd</span> <span class="operator">...</span> <span class="operator">&amp;&amp;</span> <span class="keyword">do</span> <span class="operator">{}</span>
</code></code> to see what&#39;s happening in any given command.</p>

<h2 id="26"><code><code>watchfunction()</code></code></h2>

<p><code><code>watchfunction()</code></code> is a function that can be defined by the user; it is a function which will be run on each entry to <code><code>DB::DB</code></code>; it gets the current package, filename, and line as its parameters.</p>

<p>The watchfunction can do anything it likes; it is executing in the debugger&#39;s context, so it has access to all of the debugger&#39;s internal data structures and functions.</p>

<p><code><code>watchfunction()</code></code> can control the debugger&#39;s actions. Any of the following will cause the debugger to return control to the user&#39;s program after <code><code>watchfunction()</code></code> executes:</p>

<ul>

<li><p>Returning a false value from the <code><code>watchfunction()</code></code> itself.</p>

</li>
<li><p>Altering <code><code>$single</code></code> to a false value.</p>

</li>
<li><p>Altering <code><code>$signal</code></code> to a false value.</p>

</li>
<li><p>Turning off the <code><code>4</code></code> bit in <code><code>$trace</code></code> (this also disables the check for <code><code>watchfunction()</code></code>. This can be done with</p>

<pre><code><code>    <span class="variable">$trace</span> <span class="operator">&amp;=</span> <span class="operator">~</span><span class="number">4</span><span class="operator">;</span>
</code></code></pre>

</li>
</ul>

<h2 id="GETTING-READY-TO-EXECUTE-COMMANDS">GETTING READY TO EXECUTE COMMANDS</h2>

<p>The debugger decides to take control if single-step mode is on, the <code><code>t</code></code> command was entered, or the user generated a signal. If the program has fallen off the end, we set things up so that entering further commands won&#39;t cause trouble, and we say that the program is over.</p>

<p>Special check: if we&#39;re in package <code><code>DB::fake</code></code>, we&#39;ve gone through the <code><code>END</code></code> block at least once. We set up everything so that we can continue to enter commands and have a valid context to be in.</p>

<p>If the program hasn&#39;t finished executing, we scan forward to the next executable line, print that out, build the prompt from the file and line number information, and print that.</p>

<p>If there&#39;s an action to be executed for the line we stopped at, execute it. If there are any preprompt actions, execute those as well.</p>

<h2 id="WHERE-ARE-WE-">WHERE ARE WE?</h2>

<p>XXX Relocate this section?</p>

<p>The debugger normally shows the line corresponding to the current line of execution. Sometimes, though, we want to see the next line, or to move elsewhere in the file. This is done via the <code><code>$incr</code></code>, <code><code>$start</code></code>, and <code><code>$max</code></code> variables.</p>

<p><code><code>$incr</code></code> controls by how many lines the <i>current</i> line should move forward after a command is executed. If set to -1, this indicates that the <i>current</i> line shouldn&#39;t change.</p>

<p><code><code>$start</code></code> is the <i>current</i> line. It is used for things like knowing where to move forwards or backwards from when doing an <code><code>L</code></code> or <code><code>-</code></code> command.</p>

<p><code><code>$max</code></code> tells the debugger where the last line of the current file is. It&#39;s used to terminate loops most often.</p>

<h2 id="THE-COMMAND-LOOP">THE COMMAND LOOP</h2>

<p>Most of <code><code>DB::DB</code></code> is actually a command parsing and dispatch loop. It comes in two parts:</p>

<ul>

<li><p>The outer part of the loop, starting at the <code><code>CMD</code></code> label. This loop reads a command and then executes it.</p>

</li>
<li><p>The inner part of the loop, starting at the <code><code>PIPE</code></code> label. This part is wholly contained inside the <code><code>CMD</code></code> block and only executes a command. Used to handle commands running inside a pager.</p>

</li>
</ul>

<p>So why have two labels to restart the loop? Because sometimes, it&#39;s easier to have a command <i>generate</i> another command and then re-execute the loop to do the new command. This is faster, but perhaps a bit more convoluted.</p>

<h4 id="The-null-command">The null command</h4>

<p>A newline entered by itself means <i>re-execute the last command</i>. We grab the command out of <code><code>$laststep</code></code> (where it was recorded previously), and copy it back into <code><code>$cmd</code></code> to be executed below. If there wasn&#39;t any previous command, we&#39;ll do nothing below (no command will match). If there was, we also save it in the command history and fall through to allow the command parsing to pick it up.</p>

<h3 id="COMMAND-ALIASES">COMMAND ALIASES</h3>

<p>The debugger can create aliases for commands (these are stored in the <code><code>%alias</code></code> hash). Before a command is executed, the command loop looks it up in the alias hash and substitutes the contents of the alias for the command, completely replacing it.</p>

<h3 id="MAIN-LINE-COMMANDS">MAIN-LINE COMMANDS</h3>

<p>All of these commands work up to and after the program being debugged has terminated.</p>

<h4 id="quit"><code><code>q</code></code> - quit</h4>

<p>Quit the debugger. This entails setting the <code><code>$fall_off_end</code></code> flag, so we don&#39;t try to execute further, cleaning any restart-related stuff out of the environment, and executing with the last value of <code><code>$?</code></code>.</p>

<h4 id="trace-n-"><code><code>t</code></code> - trace [n]</h4>

<p>Turn tracing on or off. Inverts the appropriate bit in <code><code>$trace</code></code> (q.v.). If level is specified, set <code><code>$trace_to_depth</code></code>.</p>

<h4 id="list-subroutines-matching-not-matching-a-pattern"><code><code>S</code></code> - list subroutines matching/not matching a pattern</h4>

<p>Walks through <code><code>%sub</code></code>, checking to see whether or not to print the name.</p>

<h4 id="list-variables-in-current-package"><code><code>X</code></code> - list variables in current package</h4>

<p>Since the <code><code>V</code></code> command actually processes this, just change this to the appropriate <code><code>V</code></code> command and fall through.</p>

<h4 id="list-variables"><code><code>V</code></code> - list variables</h4>

<p>Uses <code><code>dumpvar.pl</code></code> to dump out the current values for selected variables.</p>

<h4 id="evaluate-and-print-an-expression"><code><code>x</code></code> - evaluate and print an expression</h4>

<p>Hands the expression off to <code><code>DB::eval</code></code>, setting it up to print the value via <code><code>dumpvar.pl</code></code> instead of just printing it directly.</p>

<h4 id="print-methods"><code><code>m</code></code> - print methods</h4>

<p>Just uses <code><code>DB::methods</code></code> to determine what methods are available.</p>

<h4 id="switch-files"><code><code>f</code></code> - switch files</h4>

<h4 id="return-to-last-executed-line."><code><code>.</code></code> - return to last-executed line.</h4>

<p>We set <code><code>$incr</code></code> to -1 to indicate that the debugger shouldn&#39;t move ahead, and then we look up the line in the magical <code><code>%dbline</code></code> hash.</p>

<h4 id="back-one-window"><code><code>-</code></code> - back one window</h4>

<p>We change <code><code>$start</code></code> to be one window back; if we go back past the first line, we set it to be the first line. We ser <code><code>$incr</code></code> to put us back at the currently-executing line, and then put a <code><code>l $start +</code></code> (list one window from <code><code>$start</code></code>) in <code><code>$cmd</code></code> to be executed later.</p>

<h3 id="PRE-580-COMMANDS-VS.-NEW-COMMANDS:">PRE-580 COMMANDS VS. NEW COMMANDS: <code><code><span class="variable">a</span><span class="operator">,</span> <span class="variable">A</span><span class="operator">,</span> <span class="variable">b</span><span class="operator">,</span> <span class="variable">B</span><span class="operator">,</span> <span class="variable">h</span><span class="operator">,</span> <span class="variable">l</span><span class="operator">,</span> <span class="variable">L</span><span class="operator">,</span> <span class="variable">M</span><span class="operator">,</span> <span class="variable">o</span><span class="operator">,</span> <span class="variable">O</span><span class="operator">,</span> <span class="variable">P</span><span class="operator">,</span> <span class="variable">v</span><span class="operator">,</span> <span class="variable">w</span><span class="operator">,</span> <span class="variable">W</span><span class="operator">,</span> <span class="operator">&lt;,</span> <span class="operator">&lt;&lt;,</span> <span class="operator">{</span><span class="operator">,</span> <span class="operator">{{</span>
</code></code></h3>

<p>In Perl 5.8.0, a realignment of the commands was done to fix up a number of problems, most notably that the default case of several commands destroying the user&#39;s work in setting watchpoints, actions, etc. We wanted, however, to retain the old commands for those who were used to using them or who preferred them. At this point, we check for the new commands and call <code><code>cmd_wrapper</code></code> to deal with them instead of processing them in-line.</p>

<h4 id="List-lexicals-in-higher-scope"><code><code>y</code></code> - List lexicals in higher scope</h4>

<p>Uses <code><code>PadWalker</code></code> to find the lexicals supplied as arguments in a scope above the current one and then displays then using <code><code>dumpvar.pl</code></code>.</p>

<h3 id="COMMANDS-NOT-WORKING-AFTER-PROGRAM-ENDS">COMMANDS NOT WORKING AFTER PROGRAM ENDS</h3>

<p>All of the commands below this point don&#39;t work after the program being debugged has ended. All of them check to see if the program has ended; this allows the commands to be relocated without worrying about a &#39;line of demarcation&#39; above which commands can be entered anytime, and below which they can&#39;t.</p>

<h4 id="single-step-but-dont-trace-down-into-subs"><code><code>n</code></code> - single step, but don&#39;t trace down into subs</h4>

<p>Done by setting <code><code>$single</code></code> to 2, which forces subs to execute straight through when entered (see <code><code>DB::sub</code></code>). We also save the <code><code>n</code></code> command in <code><code>$laststep</code></code>, so a null command knows what to re-execute.</p>

<h4 id="single-step-entering-subs"><code><code>s</code></code> - single-step, entering subs</h4>

<p>Sets <code><code>$single</code></code> to 1, which causes <code><code>DB::sub</code></code> to continue tracing inside subs. Also saves <code><code>s</code></code> as <code><code>$lastcmd</code></code>.</p>

<h4 id="run-continuously-setting-an-optional-breakpoint"><code><code>c</code></code> - run continuously, setting an optional breakpoint</h4>

<p>Most of the code for this command is taken up with locating the optional breakpoint, which is either a subroutine name or a line number. We set the appropriate one-time-break in <code><code>@dbline</code></code> and then turn off single-stepping in this and all call levels above this one.</p>

<h4 id="return-from-a-subroutine"><code><code>r</code></code> - return from a subroutine</h4>

<p>For <code><code>r</code></code> to work properly, the debugger has to stop execution again immediately after the return is executed. This is done by forcing single-stepping to be on in the call level above the current one. If we are printing return values when a <code><code>r</code></code> is executed, set <code><code>$doret</code></code> appropriately, and force us out of the command loop.</p>

<h4 id="stack-trace"><code><code>T</code></code> - stack trace</h4>

<p>Just calls <code><code>DB::print_trace</code></code>.</p>

<h4 id="List-window-around-current-line."><code><code>w</code></code> - List window around current line.</h4>

<p>Just calls <code><code>DB::cmd_w</code></code>.</p>

<h4 id="watch-expression-processing."><code><code>W</code></code> - watch-expression processing.</h4>

<p>Just calls <code><code>DB::cmd_W</code></code>.</p>

<h4 id="search-forward-for-a-string-in-the-source"><code><code>/</code></code> - search forward for a string in the source</h4>

<p>We take the argument and treat it as a pattern. If it turns out to be a bad one, we return the error we got from trying to <code><code>eval</code></code> it and exit. If not, we create some code to do the search and <code><code>eval</code></code> it so it can&#39;t mess us up.</p>

<h4 id="search-backward-for-a-string-in-the-source"><code><code>?</code></code> - search backward for a string in the source</h4>

<p>Same as for <code><code>/</code></code>, except the loop runs backwards.</p>

<h4 id="Recall-command"><code><code>$rc</code></code> - Recall command</h4>

<p>Manages the commands in <code><code>@hist</code></code> (which is created if <code><code>Term::ReadLine</code></code> reports that the terminal supports history). It find the the command required, puts it into <code><code>$cmd</code></code>, and redoes the loop to execute it.</p>

<h4 id="command"><code><code>$sh$sh</code></code> - <code><code>system()</code></code> command</h4>

<p>Calls the <code><code>DB::system()</code></code> to handle the command. This keeps the <code><code>STDIN</code></code> and <code><code>STDOUT</code></code> from getting messed up.</p>

<h4 id="Search-command-history"><code><code>$rc </code><i><code>pattern</code></i><code> $rc</code></code> - Search command history</h4>

<p>Another command to manipulate <code><code>@hist</code></code>: this one searches it with a pattern. If a command is found, it is placed in <code><code>$cmd</code></code> and executed via <code><code>redo</code></code>.</p>

<h4 id="Invoke-a-shell"><code><code>$sh</code></code> - Invoke a shell</h4>

<p>Uses <code><code>DB::system</code></code> to invoke a shell.</p>

<h4 id="Force-execution-of-a-command-in-a-shell"><code><code>$sh </code><i><code>command</code></i></code> - Force execution of a command in a shell</h4>

<p>Like the above, but the command is passed to the shell. Again, we use <code><code>DB::system</code></code> to avoid problems with <code><code>STDIN</code></code> and <code><code>STDOUT</code></code>.</p>

<h4 id="display-commands-in-history"><code><code>H</code></code> - display commands in history</h4>

<p>Prints the contents of <code><code>@hist</code></code> (if any).</p>

<h4 id="look-up-documentation"><code><code>man, doc, perldoc</code></code> - look up documentation</h4>

<p>Just calls <code><code>runman()</code></code> to print the appropriate document.</p>

<h4 id="print"><code><code>p</code></code> - print</h4>

<p>Builds a <code><code>print EXPR</code></code> expression in the <code><code>$cmd</code></code>; this will get executed at the bottom of the loop.</p>

<h4 id="define-command-alias"><code><code>=</code></code> - define command alias</h4>

<p>Manipulates <code><code>%alias</code></code> to add or list command aliases.</p>

<h4 id="read-commands-from-a-file."><code><code>source</code></code> - read commands from a file.</h4>

<p>Opens a lexical filehandle and stacks it on <code><code>@cmdfhs</code></code>; <code><code>DB::readline</code></code> will pick it up.</p>

<h4 id="send-current-history-to-a-file"><code><code>save</code></code> - send current history to a file</h4>

<p>Takes the complete history, (not the shrunken version you see with <code><code>H</code></code>), and saves it to the given filename, so it can be replayed using <code><code>source</code></code>.</p>

<p>Note that all <code><code>^(save|source)</code></code>&#39;s are commented out with a view to minimise recursion.</p>

<h4 id="restart"><code><code>R</code></code> - restart</h4>

<p>Restart the debugger session.</p>

<h4 id="rerun-the-current-session"><code><code>rerun</code></code> - rerun the current session</h4>

<p>Return to any given position in the <b>true</b>-history list</p>

<h4 id="pipe-output-through-the-pager."><code><code>|, ||</code></code> - pipe output through the pager.</h4>

<p>For <code><code>|</code></code>, we save <code><code>OUT</code></code> (the debugger&#39;s output filehandle) and <code><code>STDOUT</code></code> (the program&#39;s standard output). For <code><code>||</code></code>, we only save <code><code>OUT</code></code>. We open a pipe to the pager (restoring the output filehandles if this fails). If this is the <code><code>|</code></code> command, we also set up a <code><code>SIGPIPE</code></code> handler which will simply set <code><code>$signal</code></code>, sending us back into the debugger.</p>

<p>We then trim off the pipe symbols and <code><code>redo</code></code> the command loop at the <code><code>PIPE</code></code> label, causing us to evaluate the command in <code><code>$cmd</code></code> without reading another.</p>

<h3 id="END-OF-COMMAND-PARSING">END OF COMMAND PARSING</h3>

<p>Anything left in <code><code>$cmd</code></code> at this point is a Perl expression that we want to evaluate. We&#39;ll always evaluate in the user&#39;s context, and fully qualify any variables we might want to address in the <code><code>DB</code></code> package.</p>

<h3 id="POST-COMMAND-PROCESSING">POST-COMMAND PROCESSING</h3>

<p>After each command, we check to see if the command output was piped anywhere. If so, we go through the necessary code to unhook the pipe and go back to our standard filehandles for input and output.</p>

<h3 id="COMMAND-LOOP-TERMINATION">COMMAND LOOP TERMINATION</h3>

<p>When commands have finished executing, we come here. If the user closed the input filehandle, we turn on <code><code>$fall_off_end</code></code> to emulate a <code><code>q</code></code> command. We evaluate any post-prompt items. We restore <code><code>$@</code></code>, <code><code>$!</code></code>, <code><code>$^E</code></code>, <code><code>$,</code></code>, <code><code>$/</code></code>, <code><code>$\</code></code>, and <code><code>$^W</code></code>, and return a null list as expected by the Perl interpreter. The interpreter will then execute the next line and then return control to us again.</p>

<h2 id="sub">sub</h2>

<p><code><code>sub</code></code> is called whenever a subroutine call happens in the program being debugged. The variable <code><code>$DB::sub</code></code> contains the name of the subroutine being called.</p>

<p>The core function of this subroutine is to actually call the sub in the proper context, capturing its output. This of course causes <code><code>DB::DB</code></code> to get called again, repeating until the subroutine ends and returns control to <code><code>DB::sub</code></code> again. Once control returns, <code><code>DB::sub</code></code> figures out whether or not to dump the return value, and returns its captured copy of the return value as its own return value. The value then feeds back into the program being debugged as if <code><code>DB::sub</code></code> hadn&#39;t been there at all.</p>

<p><code><code>sub</code></code> does all the work of printing the subroutine entry and exit messages enabled by setting <code><code>$frame</code></code>. It notes what sub the autoloader got called for, and also prints the return value if needed (for the <code><code>r</code></code> command and if the 16 bit is set in <code><code>$frame</code></code>).</p>

<p>It also tracks the subroutine call depth by saving the current setting of <code><code>$single</code></code> in the <code><code>@stack</code></code> package global; if this exceeds the value in <code><code>$deep</code></code>, <code><code>sub</code></code> automatically turns on printing of the current depth by setting the <code><code>4</code></code> bit in <code><code>$single</code></code>. In any case, it keeps the current setting of stop/don&#39;t stop on entry to subs set as it currently is set.</p>

<h3 id="support"><code><code>caller()</code></code> support</h3>

<p>If <code><code>caller()</code></code> is called from the package <code><code>DB</code></code>, it provides some additional data, in the following order:</p>

<ul>

<li><p><code><code>$package</code></code></p>

<p>The package name the sub was in</p>

</li>
<li><p><code><code>$filename</code></code></p>

<p>The filename it was defined in</p>

</li>
<li><p><code><code>$line</code></code></p>

<p>The line number it was defined on</p>

</li>
<li><p><code><code>$subroutine</code></code></p>

<p>The subroutine name; <code><code>(eval)</code></code> if an <code><code>eval</code></code>().</p>

</li>
<li><p><code><code>$hasargs</code></code></p>

<p>1 if it has arguments, 0 if not</p>

</li>
<li><p><code><code>$wantarray</code></code></p>

<p>1 if array context, 0 if scalar context</p>

</li>
<li><p><code><code>$evaltext</code></code></p>

<p>The <code><code>eval</code></code>() text, if any (undefined for <code><code>eval BLOCK</code></code>)</p>

</li>
<li><p><code><code>$is_require</code></code></p>

<p>frame was created by a <code><code>use</code></code> or <code><code>require</code></code> statement</p>

</li>
<li><p><code><code>$hints</code></code></p>

<p>pragma information; subject to change between versions</p>

</li>
<li><p><code><code>$bitmask</code></code></p>

<p>pragma information; subject to change between versions</p>

</li>
<li><p><code><code>@DB::args</code></code></p>

<p>arguments with which the subroutine was invoked</p>

</li>
</ul>

<h1 id="EXTENDED-COMMAND-HANDLING-AND-THE-COMMAND-API">EXTENDED COMMAND HANDLING AND THE COMMAND API</h1>

<p>In Perl 5.8.0, there was a major realignment of the commands and what they did, Most of the changes were to systematize the command structure and to eliminate commands that threw away user input without checking.</p>

<p>The following sections describe the code added to make it easy to support multiple command sets with conflicting command names. This section is a start at unifying all command processing to make it simpler to develop commands.</p>

<p>Note that all the cmd_[a-zA-Z] subroutines require the command name, a line number, and <code><code>$dbline</code></code> (the current line) as arguments.</p>

<p>Support functions in this section which have multiple modes of failure <code><code>die</code></code> on error; the rest simply return a false value.</p>

<p>The user-interface functions (all of the <code><code>cmd_*</code></code> functions) just output error messages.</p>

<h2 id="27"><code><code>%set</code></code></h2>

<p>The <code><code>%set</code></code> hash defines the mapping from command letter to subroutine name suffix.</p>

<p><code><code>%set</code></code> is a two-level hash, indexed by set name and then by command name. Note that trying to set the CommandSet to <code><code>foobar</code></code> simply results in the 5.8.0 command set being used, since there&#39;s no top-level entry for <code><code>foobar</code></code>.</p>

<h2 id="API-"><code><code>cmd_wrapper()</code></code> (API)</h2>

<p><code><code>cmd_wrapper()</code></code> allows the debugger to switch command sets depending on the value of the <code><code>CommandSet</code></code> option.</p>

<p>It tries to look up the command in the <code><code>%set</code></code> package-level <i>lexical</i> (which means external entities can&#39;t fiddle with it) and create the name of the sub to call based on the value found in the hash (if it&#39;s there). <i>All</i> of the commands to be handled in a set have to be added to <code><code>%set</code></code>; if they aren&#39;t found, the 5.8.0 equivalent is called (if there is one).</p>

<p>This code uses symbolic references.</p>

<h3 id="command-"><code><code>cmd_a</code></code> (command)</h3>

<p>The <code><code>a</code></code> command handles pre-execution actions. These are associated with a particular line, so they&#39;re stored in <code><code>%dbline</code></code>. We default to the current line if none is specified.</p>

<h3 id="command-1"><code><code>cmd_A</code></code> (command)</h3>

<p>Delete actions. Similar to above, except the delete code is in a separate subroutine, <code><code>delete_action</code></code>.</p>

<h3 id="API-1"><code><code>delete_action</code></code> (API)</h3>

<p><code><code>delete_action</code></code> accepts either a line number or <code><code>undef</code></code>. If a line number is specified, we check for the line being executable (if it&#39;s not, it couldn&#39;t have had an action). If it is, we just take the action off (this will get any kind of an action, including breakpoints).</p>

<h3 id="command-2"><code><code>cmd_b</code></code> (command)</h3>

<p>Set breakpoints. Since breakpoints can be set in so many places, in so many ways, conditionally or not, the breakpoint code is kind of complex. Mostly, we try to parse the command type, and then shuttle it off to an appropriate subroutine to actually do the work of setting the breakpoint in the right place.</p>

<h3 id="API-2"><code><code>break_on_load</code></code> (API)</h3>

<p>We want to break when this file is loaded. Mark this file in the <code><code>%break_on_load</code></code> hash, and note that it has a breakpoint in <code><code>%had_breakpoints</code></code>.</p>

<h3 id="API-3"><code><code>report_break_on_load</code></code> (API)</h3>

<p>Gives us an array of filenames that are set to break on load. Note that only files with break-on-load are in here, so simply showing the keys suffices.</p>

<h3 id="command-3"><code><code>cmd_b_load</code></code> (command)</h3>

<p>We take the file passed in and try to find it in <code><code>%INC</code></code> (which maps modules to files they came from). We mark those files for break-on-load via <code><code>break_on_load</code></code> and then report that it was done.</p>

<h3 id="API-package-global-"><code><code>$filename_error</code></code> (API package global)</h3>

<p>Several of the functions we need to implement in the API need to work both on the current file and on other files. We don&#39;t want to duplicate code, so <code><code>$filename_error</code></code> is used to contain the name of the file that&#39;s being worked on (if it&#39;s not the current one).</p>

<p>We can now build functions in pairs: the basic function works on the current file, and uses <code><code>$filename_error</code></code> as part of its error message. Since this is initialized to <code><code>&quot;&quot;</code></code>, no filename will appear when we are working on the current file.</p>

<p>The second function is a wrapper which does the following:</p>

<ul>

<li><p>Localizes <code><code>$filename_error</code></code> and sets it to the name of the file to be processed.</p>

</li>
<li><p>Localizes the <code><code>*dbline</code></code> glob and reassigns it to point to the file we want to process.</p>

</li>
<li><p>Calls the first function.</p>

<p>The first function works on the <i>current</i> file (i.e., the one we changed to), and prints <code><code>$filename_error</code></code> in the error message (the name of the other file) if it needs to. When the functions return, <code><code>*dbline</code></code> is restored to point to the actual current file (the one we&#39;re executing in) and <code><code>$filename_error</code></code> is restored to <code><code>&quot;&quot;</code></code>. This restores everything to the way it was before the second function was called at all.</p>

<p>See the comments in <code><code>breakable_line</code></code> and <code><code>breakable_line_in_file</code></code> for more details.</p>

</li>
</ul>

<h3 id="breakable_line-from-to-API-">breakable_line(from, to) (API)</h3>

<p>The subroutine decides whether or not a line in the current file is breakable. It walks through <code><code>@dbline</code></code> within the range of lines specified, looking for the first line that is breakable.</p>

<p>If <code><code>$to</code></code> is greater than <code><code>$from</code></code>, the search moves forwards, finding the first line <i>after</i> <code><code>$to</code></code> that&#39;s breakable, if there is one.</p>

<p>If <code><code>$from</code></code> is greater than <code><code>$to</code></code>, the search goes <i>backwards</i>, finding the first line <i>before</i> <code><code>$to</code></code> that&#39;s breakable, if there is one.</p>

<h3 id="breakable_line_in_filename-file-from-to-API-">breakable_line_in_filename(file, from, to) (API)</h3>

<p>Like <code><code>breakable_line</code></code>, but look in another file.</p>

<h3 id="break_on_line-lineno-condition-API-">break_on_line(lineno, [condition]) (API)</h3>

<p>Adds a breakpoint with the specified condition (or 1 if no condition was specified) to the specified line. Dies if it can&#39;t.</p>

<h3 id="cmd_b_line-line-condition-command-">cmd_b_line(line, [condition]) (command)</h3>

<p>Wrapper for <code><code>break_on_line</code></code>. Prints the failure message if it doesn&#39;t work.</p>

<h3 id="cmd_b_filename_line-line-condition-command-">cmd_b_filename_line(line, [condition]) (command)</h3>

<p>Wrapper for <code><code>break_on_filename_line</code></code>. Prints the failure message if it doesn&#39;t work.</p>

<h3 id="break_on_filename_line-file-line-condition-API-">break_on_filename_line(file, line, [condition]) (API)</h3>

<p>Switches to the file specified and then calls <code><code>break_on_line</code></code> to set the breakpoint.</p>

<h3 id="break_on_filename_line_range-file-from-to-condition-API-">break_on_filename_line_range(file, from, to, [condition]) (API)</h3>

<p>Switch to another file, search the range of lines specified for an executable one, and put a breakpoint on the first one you find.</p>

<h3 id="subroutine_filename_lines-subname-condition-API-">subroutine_filename_lines(subname, [condition]) (API)</h3>

<p>Search for a subroutine within a given file. The condition is ignored. Uses <code><code>find_sub</code></code> to locate the desired subroutine.</p>

<h3 id="break_subroutine-subname-API-">break_subroutine(subname) (API)</h3>

<p>Places a break on the first line possible in the specified subroutine. Uses <code><code>subroutine_filename_lines</code></code> to find the subroutine, and <code><code>break_on_filename_line_range</code></code> to place the break.</p>

<h3 id="cmd_b_sub-subname-condition-command-">cmd_b_sub(subname, [condition]) (command)</h3>

<p>We take the incoming subroutine name and fully-qualify it as best we can.</p>

<dl>

<dt id="If-its-already-fully-qualified-leave-it-alone.">1. If it&#39;s already fully-qualified, leave it alone.</dt>
<dd>

</dd>
<dt id="Try-putting-it-in-the-current-package.">2. Try putting it in the current package.</dt>
<dd>

</dd>
<dt id="If-its-not-there-try-putting-it-in-CORE::GLOBAL-if-it-exists-there.">3. If it&#39;s not there, try putting it in CORE::GLOBAL if it exists there.</dt>
<dd>

</dd>
<dt id="If-it-starts-with-::-put-it-in-main::.">4. If it starts with &#39;::&#39;, put it in &#39;main::&#39;.</dt>
<dd>

</dd>
</dl>

<p>After all this cleanup, we call <code><code>break_subroutine</code></code> to try to set the breakpoint.</p>

<h3 id="delete-breakpoint-s-command-"><code><code>cmd_B</code></code> - delete breakpoint(s) (command)</h3>

<p>The command mostly parses the command line and tries to turn the argument into a line spec. If it can&#39;t, it uses the current line. It then calls <code><code>delete_breakpoint</code></code> to actually do the work.</p>

<p>If <code><code>*</code></code> is specified, <code><code>cmd_B</code></code> calls <code><code>delete_breakpoint</code></code> with no arguments, thereby deleting all the breakpoints.</p>

<h3 id="delete_breakpoint-line-API-">delete_breakpoint([line]) (API)</h3>

<p>This actually does the work of deleting either a single breakpoint, or all of them.</p>

<p>For a single line, we look for it in <code><code>@dbline</code></code>. If it&#39;s nonbreakable, we just drop out with a message saying so. If it is, we remove the condition part of the &#39;condition\0action&#39; that says there&#39;s a breakpoint here. If, after we&#39;ve done that, there&#39;s nothing left, we delete the corresponding line in <code><code>%dbline</code></code> to signal that no action needs to be taken for this line.</p>

<p>For all breakpoints, we iterate through the keys of <code><code>%had_breakpoints</code></code>, which lists all currently-loaded files which have breakpoints. We then look at each line in each of these files, temporarily switching the <code><code>%dbline</code></code> and <code><code>@dbline</code></code> structures to point to the files in question, and do what we did in the single line case: delete the condition in <code><code>@dbline</code></code>, and delete the key in <code><code>%dbline</code></code> if nothing&#39;s left.</p>

<p>We then wholesale delete <code><code>%postponed</code></code>, <code><code>%postponed_file</code></code>, and <code><code>%break_on_load</code></code>, because these structures contain breakpoints for files and code that haven&#39;t been loaded yet. We can just kill these off because there are no magical debugger structures associated with them.</p>

<h3 id="cmd_stop-command-">cmd_stop (command)</h3>

<p>This is meant to be part of the new command API, but it isn&#39;t called or used anywhere else in the debugger. XXX It is probably meant for use in development of new commands.</p>

<h3 id="threads"><code><code>cmd_e</code></code> - threads</h3>

<p>Display the current thread id:</p>

<pre><code><code>        e</code></code></pre>

<p>This could be how (when implemented) to send commands to this thread id (e cmd) or that thread id (e tid cmd).</p>

<h3 id="list-of-thread-ids"><code><code>cmd_E</code></code> - list of thread ids</h3>

<p>Display the list of available thread ids:</p>

<pre><code><code>        E</code></code></pre>

<p>This could be used (when implemented) to send commands to all threads (E cmd).</p>

<h3 id="help-command-command-"><code><code>cmd_h</code></code> - help command (command)</h3>

<p>Does the work of either</p>

<ul>

<li><p>Showing all the debugger help</p>

</li>
<li><p>Showing help for a specific command</p>

</li>
</ul>

<h3 id="inheritance-display"><code><code>cmd_i</code></code> - inheritance display</h3>

<p>Display the (nested) parentage of the module or object given.</p>

<h3 id="list-lines-command-"><code><code>cmd_l</code></code> - list lines (command)</h3>

<p>Most of the command is taken up with transforming all the different line specification syntaxes into &#39;start-stop&#39;. After that is done, the command runs a loop over <code><code>@dbline</code></code> for the specified range of lines. It handles the printing of each line and any markers (<code><code>==&gt;</code></code> for current line, <code><code>b</code></code> for break on this line, <code><code>a</code></code> for action on this line, <code><code>:</code></code> for this line breakable).</p>

<p>We save the last line listed in the <code><code>$start</code></code> global for further listing later.</p>

<h3 id="list-breakpoints-actions-and-watch-expressions-command-"><code><code>cmd_L</code></code> - list breakpoints, actions, and watch expressions (command)</h3>

<p>To list breakpoints, the command has to look determine where all of them are first. It starts a <code><code>%had_breakpoints</code></code>, which tells us what all files have breakpoints and/or actions. For each file, we switch the <code><code>*dbline</code></code> glob (the magic source and breakpoint data structures) to the file, and then look through <code><code>%dbline</code></code> for lines with breakpoints and/or actions, listing them out. We look through <code><code>%postponed</code></code> not-yet-compiled subroutines that have breakpoints, and through <code><code>%postponed_file</code></code> for not-yet-<code><code>require</code></code>&#39;d files that have breakpoints.</p>

<p>Watchpoints are simpler: we just list the entries in <code><code>@to_watch</code></code>.</p>

<h3 id="list-modules-command-"><code><code>cmd_M</code></code> - list modules (command)</h3>

<p>Just call <code><code>list_modules</code></code>.</p>

<h3 id="options-command-"><code><code>cmd_o</code></code> - options (command)</h3>

<p>If this is just <code><code>o</code></code> by itself, we list the current settings via <code><code>dump_option</code></code>. If there&#39;s a nonblank value following it, we pass that on to <code><code>parse_options</code></code> for processing.</p>

<h3 id="nonexistent-in-5.8.x-command-"><code><code>cmd_O</code></code> - nonexistent in 5.8.x (command)</h3>

<p>Advises the user that the O command has been renamed.</p>

<h3 id="view-window-command-"><code><code>cmd_v</code></code> - view window (command)</h3>

<p>Uses the <code><code>$preview</code></code> variable set in the second <code><code>BEGIN</code></code> block (q.v.) to move back a few lines to list the selected line in context. Uses <code><code>cmd_l</code></code> to do the actual listing after figuring out the range of line to request.</p>

<h3 id="add-a-watch-expression-command-"><code><code>cmd_w</code></code> - add a watch expression (command)</h3>

<p>The 5.8 version of this command adds a watch expression if one is specified; it does nothing if entered with no operands.</p>

<p>We extract the expression, save it, evaluate it in the user&#39;s context, and save the value. We&#39;ll re-evaluate it each time the debugger passes a line, and will stop (see the code at the top of the command loop) if the value of any of the expressions changes.</p>

<h3 id="delete-watch-expressions-command-"><code><code>cmd_W</code></code> - delete watch expressions (command)</h3>

<p>This command accepts either a watch expression to be removed from the list of watch expressions, or <code><code>*</code></code> to delete them all.</p>

<p>If <code><code>*</code></code> is specified, we simply empty the watch expression list and the watch expression value list. We also turn off the bit that says we&#39;ve got watch expressions.</p>

<p>If an expression (or partial expression) is specified, we pattern-match through the expressions and remove the ones that match. We also discard the corresponding values. If no watch expressions are left, we turn off the <i>watching expressions</i> bit.</p>

<h1 id="SUPPORT-ROUTINES">SUPPORT ROUTINES</h1>

<p>These are general support routines that are used in a number of places throughout the debugger.</p>

<h2 id="save">save</h2>

<p>save() saves the user&#39;s versions of globals that would mess us up in <code><code>@saved</code></code>, and installs the versions we like better.</p>

<h2 id="show-where-we-are-now"><code><code>print_lineinfo</code></code> - show where we are now</h2>

<p>print_lineinfo prints whatever it is that it is handed; it prints it to the <code><code>$LINEINFO</code></code> filehandle instead of just printing it to STDOUT. This allows us to feed line information to a slave editor without messing up the debugger output.</p>

<h2 id="28"><code><code>postponed_sub</code></code></h2>

<p>Handles setting postponed breakpoints in subroutines once they&#39;re compiled. For breakpoints, we use <code><code>DB::find_sub</code></code> to locate the source file and line range for the subroutine, then mark the file as having a breakpoint, temporarily switch the <code><code>*dbline</code></code> glob over to the source file, and then search the given range of lines to find a breakable line. If we find one, we set the breakpoint on it, deleting the breakpoint from <code><code>%postponed</code></code>.</p>

<h2 id="29"><code><code>postponed</code></code></h2>

<p>Called after each required file is compiled, but before it is executed; also called if the name of a just-compiled subroutine is a key of <code><code>%postponed</code></code>. Propagates saved breakpoints (from <code><code>b compile</code></code>, <code><code>b load</code></code>, etc.) into the just-compiled code.</p>

<p>If this is a <code><code>require</code></code>&#39;d file, the incoming parameter is the glob <code><code><span class="variable">*</span><span class="operator">{</span><span class="string">"_&lt;</span><span class="variable">$filename</span><span class="string">"</span><span class="operator">}</span>
</code></code>, with <code><code>$filename</code></code> the name of the <code><code>require</code></code>&#39;d file.</p>

<p>If it&#39;s a subroutine, the incoming parameter is the subroutine name.</p>

<h2 id="30"><code><code>dumpit</code></code></h2>

<p><code><code>dumpit</code></code> is the debugger&#39;s wrapper around dumpvar.pl.</p>

<p>It gets a filehandle (to which <code><code>dumpvar.pl</code></code>&#39;s output will be directed) and a reference to a variable (the thing to be dumped) as its input.</p>

<p>The incoming filehandle is selected for output (<code><code>dumpvar.pl</code></code> is printing to the currently-selected filehandle, thank you very much). The current values of the package globals <code><code>$single</code></code> and <code><code>$trace</code></code> are backed up in lexicals, and they are turned off (this keeps the debugger from trying to single-step through <code><code>dumpvar.pl</code></code> (I think.)). <code><code>$frame</code></code> is localized to preserve its current value and it is set to zero to prevent entry/exit messages from printing, and <code><code>$doret</code></code> is localized as well and set to -2 to prevent return values from being shown.</p>

<p><code><code>dumpit()</code></code> then checks to see if it needs to load <code><code>dumpvar.pl</code></code> and tries to load it (note: if you have a <code><code>dumpvar.pl</code></code> ahead of the installed version in <code><code>@INC</code></code>, yours will be used instead. Possible security problem?).</p>

<p>It then checks to see if the subroutine <code><code>main::dumpValue</code></code> is now defined (it should have been defined by <code><code>dumpvar.pl</code></code>). If it has, <code><code>dumpit()</code></code> localizes the globals necessary for things to be sane when <code><code>main::dumpValue()</code></code> is called, and picks up the variable to be dumped from the parameter list.</p>

<p>It checks the package global <code><code>%options</code></code> to see if there&#39;s a <code><code>dumpDepth</code></code> specified. If not, -1 is assumed; if so, the supplied value gets passed on to <code><code>dumpvar.pl</code></code>. This tells <code><code>dumpvar.pl</code></code> where to leave off when dumping a structure: -1 means dump everything.</p>

<p><code><code>dumpValue()</code></code> is then called if possible; if not, <code><code>dumpit()</code></code>just prints a warning.</p>

<p>In either case, <code><code>$single</code></code>, <code><code>$trace</code></code>, <code><code>$frame</code></code>, and <code><code>$doret</code></code> are restored and we then return to the caller.</p>

<h2 id="31"><code><code>print_trace</code></code></h2>

<p><code><code>print_trace</code></code>&#39;s job is to print a stack trace. It does this via the <code><code>dump_trace</code></code> routine, which actually does all the ferreting-out of the stack trace data. <code><code>print_trace</code></code> takes care of formatting it nicely and printing it to the proper filehandle.</p>

<p>Parameters:</p>

<ul>

<li><p>The filehandle to print to.</p>

</li>
<li><p>How many frames to skip before starting trace.</p>

</li>
<li><p>How many frames to print.</p>

</li>
<li><p>A flag: if true, print a <i>short</i> trace without filenames, line numbers, or arguments</p>

</li>
</ul>

<p>The original comment below seems to be noting that the traceback may not be correct if this routine is called in a tied method.</p>

<h2 id="dump_trace-skip-count-">dump_trace(skip[,count])</h2>

<p>Actually collect the traceback information available via <code><code>caller()</code></code>. It does some filtering and cleanup of the data, but mostly it just collects it to make <code><code>print_trace()</code></code>&#39;s job easier.</p>

<p><code><code>skip</code></code> defines the number of stack frames to be skipped, working backwards from the most current. <code><code>count</code></code> determines the total number of frames to be returned; all of them (well, the first 10^9) are returned if <code><code>count</code></code> is omitted.</p>

<p>This routine returns a list of hashes, from most-recent to least-recent stack frame. Each has the following keys and values:</p>

<ul>

<li><p><code><code>context</code></code> - <code><code>.</code></code> (null), <code><code>$</code></code> (scalar), or <code><code>@</code></code> (array)</p>

</li>
<li><p><code><code>sub</code></code> - subroutine name, or <code><code>eval</code></code> information</p>

</li>
<li><p><code><code>args</code></code> - undef, or a reference to an array of arguments</p>

</li>
<li><p><code><code>file</code></code> - the file in which this item was defined (if any)</p>

</li>
<li><p><code><code>line</code></code> - the line on which it was defined</p>

</li>
</ul>

<h2 id="32"><code><code>action()</code></code></h2>

<p><code><code>action()</code></code> takes input provided as the argument to an add-action command, either pre- or post-, and makes sure it&#39;s a complete command. It doesn&#39;t do any fancy parsing; it just keeps reading input until it gets a string without a trailing backslash.</p>

<h2 id="unbalanced">unbalanced</h2>

<p>This routine mostly just packages up a regular expression to be used to check that the thing it&#39;s being matched against has properly-matched curly braces.</p>

<p>Of note is the definition of the <code><code>$balanced_brace_re</code></code> global via <code><code>||=</code></code>, which speeds things up by only creating the qr//&#39;ed expression once; if it&#39;s already defined, we don&#39;t try to define it again. A speed hack.</p>

<h2 id="33"><code><code>gets()</code></code></h2>

<p><code><code>gets()</code></code> is a primitive (very primitive) routine to read continuations. It was devised for reading continuations for actions. it just reads more input with <code><code>readline()</code></code> and returns it.</p>

<h2 id="handle-calls-tosystem-without-messing-up-the-debugger"><code><code>DB::system()</code></code> - handle calls to&lt;system()&gt; without messing up the debugger</h2>

<p>The <code><code>system()</code></code> function assumes that it can just go ahead and use STDIN and STDOUT, but under the debugger, we want it to use the debugger&#39;s input and outout filehandles.</p>

<p><code><code>DB::system()</code></code> socks away the program&#39;s STDIN and STDOUT, and then substitutes the debugger&#39;s IN and OUT filehandles for them. It does the <code><code>system()</code></code> call, and then puts everything back again.</p>

<h1 id="TTY-MANAGEMENT">TTY MANAGEMENT</h1>

<p>The subs here do some of the terminal management for multiple debuggers.</p>

<h2 id="setterm">setterm</h2>

<p>Top-level function called when we want to set up a new terminal for use by the debugger.</p>

<p>If the <code><code>noTTY</code></code> debugger option was set, we&#39;ll either use the terminal supplied (the value of the <code><code>noTTY</code></code> option), or we&#39;ll use <code><code>Term::Rendezvous</code></code> to find one. If we&#39;re a forked debugger, we call <code><code>resetterm</code></code> to try to get a whole new terminal if we can.</p>

<p>In either case, we set up the terminal next. If the <code><code>ReadLine</code></code> option was true, we&#39;ll get a <code><code>Term::ReadLine</code></code> object for the current terminal and save the appropriate attributes. We then</p>

<h1 id="GET_FORK_TTY-EXAMPLE-FUNCTIONS">GET_FORK_TTY EXAMPLE FUNCTIONS</h1>

<p>When the process being debugged forks, or the process invokes a command via <code><code>system()</code></code> which starts a new debugger, we need to be able to get a new <code><code>IN</code></code> and <code><code>OUT</code></code> filehandle for the new debugger. Otherwise, the two processes fight over the terminal, and you can never quite be sure who&#39;s going to get the input you&#39;re typing.</p>

<p><code><code>get_fork_TTY</code></code> is a glob-aliased function which calls the real function that is tasked with doing all the necessary operating system mojo to get a new TTY (and probably another window) and to direct the new debugger to read and write there.</p>

<p>The debugger provides <code><code>get_fork_TTY</code></code> functions which work for TCP socket servers, X11, OS/2, and Mac OS X. Other systems are not supported. You are encouraged to write <code><code>get_fork_TTY</code></code> functions which work for <i>your</i> platform and contribute them.</p>

<h3 id="34"><code><code>socket_get_fork_TTY</code></code></h3>

<h3 id="35"><code><code>xterm_get_fork_TTY</code></code></h3>

<p>This function provides the <code><code>get_fork_TTY</code></code> function for X11. If a program running under the debugger forks, a new &lt;xterm&gt; window is opened and the subsidiary debugger is directed there.</p>

<p>The <code><code>open()</code></code> call is of particular note here. We have the new <code><code>xterm</code></code> we&#39;re spawning route file number 3 to STDOUT, and then execute the <code><code>tty</code></code> command (which prints the device name of the TTY we&#39;ll want to use for input and output to STDOUT, then <code><code>sleep</code></code> for a very long time, routing this output to file number 3. This way we can simply read from the &lt;XT&gt; filehandle (which is STDOUT from the <i>commands</i> we ran) to get the TTY we want to use.</p>

<p>Only works if <code><code>xterm</code></code> is in your path and <code><code><span class="variable">$ENV</span><span class="operator">{</span><span class="string">DISPLAY</span><span class="operator">}</span>
</code></code>, etc. are properly set up.</p>

<h3 id="36"><code><code>os2_get_fork_TTY</code></code></h3>

<p>XXX It behooves an OS/2 expert to write the necessary documentation for this!</p>

<h3 id="37"><code><code>macosx_get_fork_TTY</code></code></h3>

<p>The Mac OS X version uses AppleScript to tell Terminal.app to create a new window.</p>

<h2 id="38"><code><code>create_IN_OUT($flags)</code></code></h2>

<p>Create a new pair of filehandles, pointing to a new TTY. If impossible, try to diagnose why.</p>

<p>Flags are:</p>

<ul>

<li><p>1 - Don&#39;t know how to create a new TTY.</p>

</li>
<li><p>2 - Debugger has forked, but we can&#39;t get a new TTY.</p>

</li>
<li><p>4 - standard debugger startup is happening.</p>

</li>
</ul>

<h2 id="39"><code><code>resetterm</code></code></h2>

<p>Handles rejiggering the prompt when we&#39;ve forked off a new debugger.</p>

<p>If the new debugger happened because of a <code><code>system()</code></code> that invoked a program under the debugger, the arrow between the old pid and the new in the prompt has <i>two</i> dashes instead of one.</p>

<p>We take the current list of pids and add this one to the end. If there isn&#39;t any list yet, we make one up out of the initial pid associated with the terminal and our new pid, sticking an arrow (either one-dashed or two dashed) in between them.</p>

<p>If <code><code>CreateTTY</code></code> is off, or <code><code>resetterm</code></code> was called with no arguments, we don&#39;t try to create a new IN and OUT filehandle. Otherwise, we go ahead and try to do that.</p>

<h2 id="40"><code><code>readline</code></code></h2>

<p>First, we handle stuff in the typeahead buffer. If there is any, we shift off the next line, print a message saying we got it, add it to the terminal history (if possible), and return it.</p>

<p>If there&#39;s nothing in the typeahead buffer, check the command filehandle stack. If there are any filehandles there, read from the last one, and return the line if we got one. If not, we pop the filehandle off and close it, and try the next one up the stack.</p>

<p>If we&#39;ve emptied the filehandle stack, we check to see if we&#39;ve got a socket open, and we read that and return it if we do. If we don&#39;t, we just call the core <code><code>readline()</code></code> and return its value.</p>

<h1 id="OPTIONS-SUPPORT-ROUTINES">OPTIONS SUPPORT ROUTINES</h1>

<p>These routines handle listing and setting option values.</p>

<h2 id="list-the-current-value-of-an-option-setting"><code><code>dump_option</code></code> - list the current value of an option setting</h2>

<p>This routine uses <code><code>option_val</code></code> to look up the value for an option. It cleans up escaped single-quotes and then displays the option and its value.</p>

<h2 id="find-the-current-value-of-an-option"><code><code>option_val</code></code> - find the current value of an option</h2>

<p>This can&#39;t just be a simple hash lookup because of the indirect way that the option values are stored. Some are retrieved by calling a subroutine, some are just variables.</p>

<p>You must supply a default value to be used in case the option isn&#39;t set.</p>

<h2 id="41"><code><code>parse_options</code></code></h2>

<p>Handles the parsing and execution of option setting/displaying commands.</p>

<p>An option entered by itself is assumed to be <i>set me to 1</i> (the default value) if the option is a boolean one. If not, the user is prompted to enter a valid value or to query the current value (via <code><code>option? </code></code>).</p>

<p>If <code><code>option=value</code></code> is entered, we try to extract a quoted string from the value (if it is quoted). If it&#39;s not, we just use the whole value as-is.</p>

<p>We load any modules required to service this option, and then we set it: if it just gets stuck in a variable, we do that; if there&#39;s a subroutine to handle setting the option, we call that.</p>

<p>Finally, if we&#39;re running in interactive mode, we display the effect of the user&#39;s command back to the terminal, skipping this if we&#39;re setting things during initialization.</p>

<h1 id="RESTART-SUPPORT">RESTART SUPPORT</h1>

<p>These routines are used to store (and restore) lists of items in environment variables during a restart.</p>

<h2 id="set_list">set_list</h2>

<p>Set_list packages up items to be stored in a set of environment variables (VAR_n, containing the number of items, and VAR_0, VAR_1, etc., containing the values). Values outside the standard ASCII charset are stored by encoding then as hexadecimal values.</p>

<h2 id="get_list">get_list</h2>

<p>Reverse the set_list operation: grab VAR_n to see how many we should be getting back, and then pull VAR_0, VAR_1. etc. back out.</p>

<h1 id="MISCELLANEOUS-SIGNAL-AND-I-O-MANAGEMENT">MISCELLANEOUS SIGNAL AND I/O MANAGEMENT</h1>

<h2 id="catch-">catch()</h2>

<p>The <code><code>catch()</code></code> subroutine is the essence of fast and low-impact. We simply set an already-existing global scalar variable to a constant value. This avoids allocating any memory possibly in the middle of something that will get all confused if we do, particularly under <i>unsafe signals</i>.</p>

<h2 id="42"><code><code>warn()</code></code></h2>

<p><code><code>warn</code></code> emits a warning, by joining together its arguments and printing them, with couple of fillips.</p>

<p>If the composited message <i>doesn&#39;t</i> end with a newline, we automatically add <code><code>$!</code></code> and a newline to the end of the message. The subroutine expects $OUT to be set to the filehandle to be used to output warnings; it makes no assumptions about what filehandles are available.</p>

<h1 id="INITIALIZATION-TTY-SUPPORT">INITIALIZATION TTY SUPPORT</h1>

<h2 id="43"><code><code>reset_IN_OUT</code></code></h2>

<p>This routine handles restoring the debugger&#39;s input and output filehandles after we&#39;ve tried and failed to move them elsewhere. In addition, it assigns the debugger&#39;s output filehandle to $LINEINFO if it was already open there.</p>

<h1 id="OPTION-SUPPORT-ROUTINES">OPTION SUPPORT ROUTINES</h1>

<p>The following routines are used to process some of the more complicated debugger options.</p>

<h2 id="44"><code><code>TTY</code></code></h2>

<p>Sets the input and output filehandles to the specified files or pipes. If the terminal supports switching, we go ahead and do it. If not, and there&#39;s already a terminal in place, we save the information to take effect on restart.</p>

<p>If there&#39;s no terminal yet (for instance, during debugger initialization), we go ahead and set <code><code>$console</code></code> and <code><code>$tty</code></code> to the file indicated.</p>

<h2 id="45"><code><code>noTTY</code></code></h2>

<p>Sets the <code><code>$notty</code></code> global, controlling whether or not the debugger tries to get a terminal to read from. If called after a terminal is already in place, we save the value to use it if we&#39;re restarted.</p>

<h2 id="46"><code><code>ReadLine</code></code></h2>

<p>Sets the <code><code>$rl</code></code> option variable. If 0, we use <code><code>Term::ReadLine::Stub</code></code> (essentially, no <code><code>readline</code></code> processing on this <i>terminal</i>). Otherwise, we use <code><code>Term::ReadLine</code></code>. Can&#39;t be changed after a terminal&#39;s in place; we save the value in case a restart is done so we can change it then.</p>

<h2 id="47"><code><code>RemotePort</code></code></h2>

<p>Sets the port that the debugger will try to connect to when starting up. If the terminal&#39;s already been set up, we can&#39;t do it, but we remember the setting in case the user does a restart.</p>

<h2 id="48"><code><code>tkRunning</code></code></h2>

<p>Checks with the terminal to see if <code><code>Tk</code></code> is running, and returns true or false. Returns false if the current terminal doesn&#39;t support <code><code>readline</code></code>.</p>

<h2 id="49"><code><code>NonStop</code></code></h2>

<p>Sets nonstop mode. If a terminal&#39;s already been set up, it&#39;s too late; the debugger remembers the setting in case you restart, though.</p>

<h2 id="50"><code><code>pager</code></code></h2>

<p>Set up the <code><code>$pager</code></code> variable. Adds a pipe to the front unless there&#39;s one there already.</p>

<h2 id="51"><code><code>shellBang</code></code></h2>

<p>Sets the shell escape command, and generates a printable copy to be used in the help.</p>

<h2 id="52"><code><code>ornaments</code></code></h2>

<p>If the terminal has its own ornaments, fetch them. Otherwise accept whatever was passed as the argument. (This means you can&#39;t override the terminal&#39;s ornaments.)</p>

<h2 id="53"><code><code>recallCommand</code></code></h2>

<p>Sets the recall command, and builds a printable version which will appear in the help text.</p>

<h2 id="where-the-line-number-information-goes"><code><code>LineInfo</code></code> - where the line number information goes</h2>

<p>Called with no arguments, returns the file or pipe that line info should go to.</p>

<p>Called with an argument (a file or a pipe), it opens that onto the <code><code>LINEINFO</code></code> filehandle, unbuffers the filehandle, and then returns the file or pipe again to the caller.</p>

<h1 id="COMMAND-SUPPORT-ROUTINES">COMMAND SUPPORT ROUTINES</h1>

<p>These subroutines provide functionality for various commands.</p>

<h2 id="54"><code><code>list_modules</code></code></h2>

<p>For the <code><code>M</code></code> command: list modules loaded and their versions. Essentially just runs through the keys in %INC, picks each package&#39;s <code><code>$VERSION</code></code> variable, gets the file name, and formats the information for output.</p>

<h2 id="55"><code><code>sethelp()</code></code></h2>

<p>Sets up the monster string used to format and print the help.</p>

<h3 id="HELP-MESSAGE-FORMAT">HELP MESSAGE FORMAT</h3>

<p>The help message is a peculiar format unto itself; it mixes <code><code>pod</code></code> <i>ornaments</i> (<code><b><code>
</code></b></code> <code><i><code>
</code></i></code>) with tabs to come up with a format that&#39;s fairly easy to parse and portable, but which still allows the help to be a little nicer than just plain text.</p>

<p>Essentially, you define the command name (usually marked up with <code><b><code>
</code></b></code> and <code><i><code>
</code></i></code>), followed by a tab, and then the descriptive text, ending in a newline. The descriptive text can also be marked up in the same way. If you need to continue the descriptive text to another line, start that line with just tabs and then enter the marked-up text.</p>

<p>If you are modifying the help text, <i>be careful</i>. The help-string parser is not very sophisticated, and if you don&#39;t follow these rules it will mangle the help beyond hope until you fix the string.</p>

<h2 id="56"><code><code>print_help()</code></code></h2>

<p>Most of what <code><code>print_help</code></code> does is just text formatting. It finds the <code><code>B</code></code> and <code><code>I</code></code> ornaments, cleans them off, and substitutes the proper terminal control characters to simulate them (courtesy of <code><code>Term::ReadLine::TermCap</code></code>).</p>

<h2 id="57"><code><code>fix_less</code></code></h2>

<p>This routine does a lot of gyrations to be sure that the pager is <code><code>less</code></code>. It checks for <code><code>less</code></code> masquerading as <code><code>more</code></code> and records the result in <code><code>$fixed_less</code></code> so we don&#39;t have to go through doing the stats again.</p>

<h1 id="DIE-AND-WARN-MANAGEMENT">DIE AND WARN MANAGEMENT</h1>

<h2 id="58"><code><code>diesignal</code></code></h2>

<p><code><code>diesignal</code></code> is a just-drop-dead <code><code>die</code></code> handler. It&#39;s most useful when trying to debug a debugger problem.</p>

<p>It does its best to report the error that occurred, and then forces the program, debugger, and everything to die.</p>

<h2 id="59"><code><code>dbwarn</code></code></h2>

<p>The debugger&#39;s own default <code><code><span class="variable">$SIG</span><span class="operator">{</span><span class="string">__WARN__</span><span class="operator">}</span>
</code></code> handler. We load <code><code>Carp</code></code> to be able to get a stack trace, and output the warning message vi <code><code>DB::dbwarn()</code></code>.</p>

<h2 id="60"><code><code>dbdie</code></code></h2>

<p>The debugger&#39;s own <code><code><span class="variable">$SIG</span><span class="operator">{</span><span class="string">__DIE__</span><span class="operator">}</span>
</code></code> handler. Handles providing a stack trace by loading <code><code>Carp</code></code> and calling <code><code>Carp::longmess()</code></code> to get it. We turn off single stepping and tracing during the call to <code><code>Carp::longmess</code></code> to avoid debugging it - we just want to use it.</p>

<p>If <code><code>dieLevel</code></code> is zero, we let the program being debugged handle the exceptions. If it&#39;s 1, you get backtraces for any exception. If it&#39;s 2, the debugger takes over all exception handling, printing a backtrace and displaying the exception via its <code><code>dbwarn()</code></code> routine.</p>

<h2 id="61"><code><code>warnlevel()</code></code></h2>

<p>Set the <code><code>$DB::warnLevel</code></code> variable that stores the value of the <code><code>warnLevel</code></code> option. Calling <code><code>warnLevel()</code></code> with a positive value results in the debugger taking over all warning handlers. Setting <code><code>warnLevel</code></code> to zero leaves any warning handlers set up by the program being debugged in place.</p>

<h2 id="62"><code><code>dielevel</code></code></h2>

<p>Similar to <code><code>warnLevel</code></code>. Non-zero values for <code><code>dieLevel</code></code> result in the <code><code>DB::dbdie()</code></code> function overriding any other <code><code>die()</code></code> handler. Setting it to zero lets you use your own <code><code>die()</code></code> handler.</p>

<h2 id="63"><code><code>signalLevel</code></code></h2>

<p>Number three in a series: set <code><code>signalLevel</code></code> to zero to keep your own signal handler for <code><code>SIGSEGV</code></code> and/or <code><code>SIGBUS</code></code>. Otherwise, the debugger takes over and handles them with <code><code>DB::diesignal()</code></code>.</p>

<h1 id="SUBROUTINE-DECODING-SUPPORT">SUBROUTINE DECODING SUPPORT</h1>

<p>These subroutines are used during the <code><code>x</code></code> and <code><code>X</code></code> commands to try to produce as much information as possible about a code reference. They use <a href="../lib/Devel/Peek.html">Devel::Peek</a> to try to find the glob in which this code reference lives (if it does) - this allows us to actually code references which correspond to named subroutines (including those aliased via glob assignment).</p>

<h2 id="64"><code><code>CvGV_name()</code></code></h2>

<p>Wrapper for <code><code>CvGV_name_or_bust</code></code>; tries to get the name of a reference via that routine. If this fails, return the reference again (when the reference is stringified, it&#39;ll come out as <code><code>SOMETHING(0x...)</code></code>).</p>

<h2 id="coderef"><code><code>CvGV_name_or_bust</code></code> <i>coderef</i></h2>

<p>Calls <a href="../lib/Devel/Peek.html">Devel::Peek</a> to try to find the glob the ref lives in; returns <code><code>undef</code></code> if <a href="../lib/Devel/Peek.html">Devel::Peek</a> can&#39;t be loaded, or if <code><code>Devel::Peek::CvGV</code></code> can&#39;t find a glob for this ref.</p>

<p>Returns <code><i><code>package</code></i><code>::</code><i><code>glob name</code></i></code> if the code ref is found in a glob.</p>

<h2 id="65"><code><code>find_sub</code></code></h2>

<p>A utility routine used in various places; finds the file where a subroutine was defined, and returns that filename and a line-number range.</p>

<p>Tries to use <code><code>@sub</code></code> first; if it can&#39;t find it there, it tries building a reference to the subroutine and uses <code><code>CvGV_name_or_bust</code></code> to locate it, loading it into <code><code>@sub</code></code> as a side effect (XXX I think). If it can&#39;t find it this way, it brute-force searches <code><code>%sub</code></code>, checking for identical references.</p>

<h2 id="66"><code><code>methods</code></code></h2>

<p>A subroutine that uses the utility function <code><code>methods_via</code></code> to find all the methods in the class corresponding to the current reference and in <code><code>UNIVERSAL</code></code>.</p>

<h2 id="67"><code><code>methods_via($class, $prefix, $crawl_upward)</code></code></h2>

<p><code><code>methods_via</code></code> does the work of crawling up the <code><code>@ISA</code></code> tree and reporting all the parent class methods. <code><code>$class</code></code> is the name of the next class to try; <code><code>$prefix</code></code> is the message prefix, which gets built up as we go up the <code><code>@ISA</code></code> tree to show parentage; <code><code>$crawl_upward</code></code> is 1 if we should try to go higher in the <code><code>@ISA</code></code> tree, 0 if we should stop.</p>

<h2 id="figure-out-which-command-to-use-to-show-documentation"><code><code>setman</code></code> - figure out which command to use to show documentation</h2>

<p>Just checks the contents of <code><code>$^O</code></code> and sets the <code><code>$doccmd</code></code> global accordingly.</p>

<h2 id="run-the-appropriate-command-to-show-documentation"><code><code>runman</code></code> - run the appropriate command to show documentation</h2>

<p>Accepts a man page name; runs the appropriate command to display it (set up during debugger initialization). Uses <code><code>DB::system</code></code> to avoid mucking up the program&#39;s STDIN and STDOUT.</p>

<h1 id="DEBUGGER-INITIALIZATION---THE-SECOND-BEGIN-BLOCK">DEBUGGER INITIALIZATION - THE SECOND BEGIN BLOCK</h1>

<p>Because of the way the debugger interface to the Perl core is designed, any debugger package globals that <code><code>DB::sub()</code></code> requires have to be defined before any subroutines can be called. These are defined in the second <code><code>BEGIN</code></code> block.</p>

<p>This block sets things up so that (basically) the world is sane before the debugger starts executing. We set up various variables that the debugger has to have set up before the Perl core starts running:</p>

<ul>

<li><p>The debugger&#39;s own filehandles (copies of STD and STDOUT for now).</p>

</li>
<li><p>Characters for shell escapes, the recall command, and the history command.</p>

</li>
<li><p>The maximum recursion depth.</p>

</li>
<li><p>The size of a <code><code>w</code></code> command&#39;s window.</p>

</li>
<li><p>The before-this-line context to be printed in a <code><code>v</code></code> (view a window around this line) command.</p>

</li>
<li><p>The fact that we&#39;re not in a sub at all right now.</p>

</li>
<li><p>The default SIGINT handler for the debugger.</p>

</li>
<li><p>The appropriate value of the flag in <code><code>$^D</code></code> that says the debugger is running</p>

</li>
<li><p>The current debugger recursion level</p>

</li>
<li><p>The list of postponed items and the <code><code>$single</code></code> stack (XXX define this)</p>

</li>
<li><p>That we want no return values and no subroutine entry/exit trace.</p>

</li>
</ul>

<h1 id="READLINE-SUPPORT---COMPLETION-FUNCTION">READLINE SUPPORT - COMPLETION FUNCTION</h1>

<h2 id="db_complete">db_complete</h2>

<p><code><code>readline</code></code> support - adds command completion to basic <code><code>readline</code></code>.</p>

<p>Returns a list of possible completions to <code><code>readline</code></code> when invoked. <code><code>readline</code></code> will print the longest common substring following the text already entered.</p>

<p>If there is only a single possible completion, <code><code>readline</code></code> will use it in full.</p>

<p>This code uses <code><code>map</code></code> and <code><code>grep</code></code> heavily to create lists of possible completion. Think LISP in this section.</p>

<h3 id="68"><code><code>b postpone|compile</code></code></h3>

<ul>

<li><p>Find all the subroutines that might match in this package</p>

</li>
<li><p>Add <code><code>postpone</code></code>, <code><code>load</code></code>, and <code><code>compile</code></code> as possibles (we may be completing the keyword itself)</p>

</li>
<li><p>Include all the rest of the subs that are known</p>

</li>
<li><p><code><code>grep</code></code> out the ones that match the text we have so far</p>

</li>
<li><p>Return this as the list of possible completions</p>

</li>
</ul>

<h3 id="69"><code><code>b load</code></code></h3>

<p>Get all the possible files from <code><code>@INC</code></code> as it currently stands and select the ones that match the text so far.</p>

<h3 id="list-variable-and-list-modules-"><code><code>V</code></code> (list variable) and <code><code>m</code></code> (list modules)</h3>

<p>There are two entry points for these commands:</p>

<h4 id="Unqualified-package-names">Unqualified package names</h4>

<p>Get the top-level packages and grab everything that matches the text so far. For each match, recursively complete the partial packages to get all possible matching packages. Return this sorted list.</p>

<h4 id="Qualified-package-names">Qualified package names</h4>

<p>Take a partially-qualified package and find all subpackages for it by getting all the subpackages for the package so far, matching all the subpackages against the text, and discarding all of them which start with &#39;main::&#39;. Return this list.</p>

<h3 id="switch-files1"><code><code>f</code></code> - switch files</h3>

<p>Here, we want to get a fully-qualified filename for the <code><code>f</code></code> command. Possibilities are:</p>

<dl>

<dt id="The-original-source-file-itself">1. The original source file itself</dt>
<dd>

</dd>
<dt id="A-file-from-INC">2. A file from <code><code>@INC</code></code></dt>
<dd>

</dd>
<dt id="An-eval-the-debugger-gets-a-eval-N-fake-file-for-each-eval-.">3. An <code><code>eval</code></code> (the debugger gets a <code><code>(eval N)</code></code> fake file for each <code><code>eval</code></code>).</dt>
<dd>

</dd>
</dl>

<p>Under the debugger, source files are represented as <code><code>_&lt;/fullpath/to/file</code></code> (<code><code>eval</code></code>s are <code><code>_&lt;(eval NNN)</code></code>) keys in <code><code>%main::</code></code>. We pull all of these out of <code><code>%main::</code></code>, add the initial source file, and extract the ones that match the completion text so far.</p>

<h3 id="Subroutine-name-completion">Subroutine name completion</h3>

<p>We look through all of the defined subs (the keys of <code><code>%sub</code></code>) and return both all the possible matches to the subroutine name plus all the matches qualified to the current package.</p>

<h3 id="Scalar-array-and-hash-completion:-partially-qualified-package">Scalar, array, and hash completion: partially qualified package</h3>

<p>Much like the above, except we have to do a little more cleanup:</p>

<ul>

<li><p>Determine the package that the symbol is in. Put it in <code><code>::</code></code> (effectively <code><code>main::</code></code>) if no package is specified.</p>

</li>
<li><p>Figure out the prefix vs. what needs completing.</p>

</li>
<li><p>Look through all the symbols in the package. <code><code>grep</code></code> out all the possible hashes/arrays/scalars, and then <code><code>grep</code></code> the possible matches out of those. <code><code>map</code></code> the prefix onto all the possibilities.</p>

</li>
<li><p>If there&#39;s only one hit, and it&#39;s a package qualifier, and it&#39;s not equal to the initial text, re-complete it using the symbol we actually found.</p>

</li>
</ul>

<h3 id="Symbol-completion:-current-package-or-package-.">Symbol completion: current package or package <code><code>main</code></code>.</h3>

<ul>

<li><p>If it&#39;s <code><code>main</code></code>, delete main to just get <code><code>::</code></code> leading.</p>

</li>
<li><p>We set the prefix to the item&#39;s sigil, and trim off the sigil to get the text to be completed.</p>

</li>
<li><p>We look for the lexical scope above DB::DB and auto-complete lexical variables if PadWalker could be loaded.</p>

</li>
<li><p>If the package is <code><code>::</code></code> (<code><code>main</code></code>), create an empty list; if it&#39;s something else, create a list of all the packages known. Append whichever list to a list of all the possible symbols in the current package. <code><code>grep</code></code> out the matches to the text entered so far, then <code><code>map</code></code> the prefix back onto the symbols.</p>

</li>
<li><p>If there&#39;s only one hit, it&#39;s a package qualifier, and it&#39;s not equal to the initial text, recomplete using this symbol.</p>

</li>
</ul>

<h3 id="Options">Options</h3>

<p>We use <code><code>option_val()</code></code> to look up the current value of the option. If there&#39;s only a single value, we complete the command in such a way that it is a complete command for setting the option in question. If there are multiple possible values, we generate a command consisting of the option plus a trailing question mark, which, if executed, will list the current value of the option.</p>

<h3 id="Filename-completion">Filename completion</h3>

<p>For entering filenames. We simply call <code><code>readline</code></code>&#39;s <code><code>filename_list()</code></code> method with the completion text to get the possible completions.</p>

<h1 id="MISCELLANEOUS-SUPPORT-FUNCTIONS">MISCELLANEOUS SUPPORT FUNCTIONS</h1>

<p>Functions that possibly ought to be somewhere else.</p>

<h2 id="end_report">end_report</h2>

<p>Say we&#39;re done.</p>

<h2 id="clean_ENV">clean_ENV</h2>

<p>If we have $ini_pids, save it in the environment; else remove it from the environment. Used by the <code><code>R</code></code> (restart) command.</p>

<dl>

<dt id="rerun">rerun</dt>
<dd>

<p>Rerun the current session to:</p>

<pre><code><code>    rerun        current position

    rerun 4      command number 4

    rerun -4     current command minus 4 (go back 4 steps)</code></code></pre>

<p>Whether this always makes sense, in the current context is unknowable, and is in part left as a useful exercise for the reader. This sub returns the appropriate arguments to rerun the current session.</p>

</dd>
<dt id="restart1">restart</dt>
<dd>

<p>Restarting the debugger is a complex operation that occurs in several phases. First, we try to reconstruct the command line that was used to invoke Perl and the debugger.</p>

<p>After the command line has been reconstructed, the next step is to save the debugger&#39;s status in environment variables. The <code><code>DB::set_list</code></code> routine is used to save aggregate variables (both hashes and arrays); scalars are just popped into environment variables directly.</p>

<p>The most complex part of this is the saving of all of the breakpoints. They can live in an awful lot of places, and we have to go through all of them, find the breakpoints, and then save them in the appropriate environment variable via <code><code>DB::set_list</code></code>.</p>

<p>After all the debugger status has been saved, we take the command we built up and then return it, so we can <code><code>exec()</code></code> it. The debugger will spot the <code><code>PERLDB_RESTART</code></code> environment variable and realize it needs to reload its state from the environment.</p>

</dd>
</dl>

<h1 id="END-PROCESSING---THE-BLOCK">END PROCESSING - THE <code><code>END</code></code> BLOCK</h1>

<p>Come here at the very end of processing. We want to go into a loop where we allow the user to enter commands and interact with the debugger, but we don&#39;t want anything else to execute.</p>

<p>First we set the <code><code>$finished</code></code> variable, so that some commands that shouldn&#39;t be run after the end of program quit working.</p>

<p>We then figure out whether we&#39;re truly done (as in the user entered a <code><code>q</code></code> command, or we finished execution while running nonstop). If we aren&#39;t, we set <code><code>$single</code></code> to 1 (causing the debugger to get control again).</p>

<p>We then call <code><code>DB::fake::at_exit()</code></code>, which returns the <code><code>Use &#39;q&#39; to quit ...</code></code> message and returns control to the debugger. Repeat.</p>

<p>When the user finally enters a <code><code>q</code></code> command, <code><code>$fall_off_end</code></code> is set to 1 and the <code><code>END</code></code> block simply exits with <code><code>$single</code></code> set to 0 (don&#39;t break, run to completion.).</p>

<h1 id="PRE-5.8-COMMANDS">PRE-5.8 COMMANDS</h1>

<p>Some of the commands changed function quite a bit in the 5.8 command realignment, so much so that the old code had to be replaced completely. Because we wanted to retain the option of being able to go back to the former command set, we moved the old code off to this section.</p>

<p>There&#39;s an awful lot of duplicated code here. We&#39;ve duplicated the comments to keep things clear.</p>

<h2 id="Null-command">Null command</h2>

<p>Does nothing. Used to <i>turn off</i> commands.</p>

<h2 id="Old-command.">Old <code><code>a</code></code> command.</h2>

<p>This version added actions if you supplied them, and deleted them if you didn&#39;t.</p>

<h2 id="Old-command">Old <code><code>b</code></code> command</h2>

<p>Add breakpoints.</p>

<h2 id="Old-command.1">Old <code><code>D</code></code> command.</h2>

<p>Delete all breakpoints unconditionally.</p>

<h2 id="Old-command1">Old <code><code>h</code></code> command</h2>

<p>Print help. Defaults to printing the long-form help; the 5.8 version prints the summary by default.</p>

<h2 id="Old-command2">Old <code><code>W</code></code> command</h2>

<p><code><code>W &lt;expr&gt;</code></code> adds a watch expression, <code><code>W</code></code> deletes them all.</p>

<h1 id="PRE-AND-POST-PROMPT-COMMANDS-AND-ACTIONS">PRE-AND-POST-PROMPT COMMANDS AND ACTIONS</h1>

<p>The debugger used to have a bunch of nearly-identical code to handle the pre-and-post-prompt action commands. <code><code>cmd_pre590_prepost</code></code> and <code><code>cmd_prepost</code></code> unify all this into one set of code to handle the appropriate actions.</p>

<h2 id="70"><code><code>cmd_pre590_prepost</code></code></h2>

<p>A small wrapper around <code><code>cmd_prepost</code></code>; it makes sure that the default doesn&#39;t do something destructive. In pre 5.8 debuggers, the default action was to delete all the actions.</p>

<h2 id="71"><code><code>cmd_prepost</code></code></h2>

<p>Actually does all the handling for <code><code>&lt;</code></code>, <code><code>&gt;</code></code>, <code><code><span class="operator">{{</span>
</code></code>, <code><code><span class="operator">{</span>
</code></code>, etc. Since the lists of actions are all held in arrays that are pointed to by references anyway, all we have to do is pick the right array reference and then use generic code to all, delete, or list actions.</p>

<h1 id="72"><code><code>DB::fake</code></code></h1>

<p>Contains the <code><code>at_exit</code></code> routine that the debugger uses to issue the <code><code>Debugged program terminated ...</code></code> message after the program completes. See the <code><code>END</code></code> block documentation for more details.</p>


</body>

</html>


