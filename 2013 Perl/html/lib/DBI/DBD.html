<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a>
    <ul>
      <li><a href="#Version-and-volatility">Version and volatility</a></li>
    </ul>
  </li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#CREATING-A-NEW-DRIVER">CREATING A NEW DRIVER</a>
    <ul>
      <li><a href="#URLs-and-mailing-lists">URLs and mailing lists</a></li>
      <li><a href="#The-Cheetah-book">The Cheetah book</a></li>
      <li><a href="#Locating-drivers">Locating drivers</a></li>
      <li><a href="#Registering-a-new-driver">Registering a new driver</a></li>
      <li><a href="#Two-styles-of-database-driver">Two styles of database driver</a></li>
      <li><a href="#What-code-will-you-write-">What code will you write?</a>
        <ul>
          <li><a href="#Files-common-to-pure-Perl-and-C-XS-drivers">Files common to pure Perl and C/XS drivers</a></li>
          <li><a href="#Extra-files-needed-by-C-XS-drivers">Extra files needed by C/XS drivers</a></li>
        </ul>
      </li>
      <li><a href="#Requirements-on-a-driver-and-driver-writer">Requirements on a driver and driver writer</a></li>
    </ul>
  </li>
  <li><a href="#CREATING-A-PURE-PERL-DRIVER">CREATING A PURE PERL DRIVER</a>
    <ul>
      <li><a href="#Pure-Perl-version-of-Makefile.PL">Pure Perl version of Makefile.PL</a></li>
      <li><a href="#README">README</a></li>
      <li><a href="#MANIFEST">MANIFEST</a></li>
      <li><a href="#lib-Bundle-DBD-Driver.pm">lib/Bundle/DBD/Driver.pm</a></li>
      <li><a href="#lib-DBD-Driver-Summary.pm">lib/DBD/Driver/Summary.pm</a></li>
      <li><a href="#Pure-Perl-version-of-Driver.pm">Pure Perl version of Driver.pm</a>
        <ul>
          <li><a href="#The-DBD::Driver-package">The DBD::Driver package</a>
            <ul>
              <li><a href="#The-header">The header</a></li>
              <li><a href="#The-driver-constructor">The driver constructor</a></li>
              <li><a href="#Using-install_method-to-expose-driver-private-methods">Using install_method() to expose driver-private methods</a></li>
              <li><a href="#The-CLONE-special-subroutine">The CLONE special subroutine</a></li>
            </ul>
          </li>
          <li><a href="#The-DBD::Driver::dr-package">The DBD::Driver::dr package</a>
            <ul>
              <li><a href="#The-database-handle-constructor">The database handle constructor</a></li>
              <li><a href="#The-data_sources-method">The data_sources() method</a></li>
              <li><a href="#The-disconnect_all-method">The disconnect_all() method</a></li>
              <li><a href="#Other-driver-handle-methods">Other driver handle methods</a></li>
              <li><a href="#Error-handling">Error handling</a></li>
            </ul>
          </li>
          <li><a href="#The-DBD::Driver::db-package">The DBD::Driver::db package</a>
            <ul>
              <li><a href="#The-statement-handle-constructor">The statement handle constructor</a></li>
              <li><a href="#Transaction-handling">Transaction handling</a></li>
              <li><a href="#The-STORE-and-FETCH-methods">The STORE() and FETCH() methods</a></li>
              <li><a href="#Other-database-handle-methods">Other database handle methods</a></li>
            </ul>
          </li>
          <li><a href="#The-DBD::Driver::st-package">The DBD::Driver::st package</a>
            <ul>
              <li><a href="#The-execute-and-bind_param-methods">The execute() and bind_param() methods</a></li>
              <li><a href="#The-execute_array-execute_for_fetch-and-bind_param_array-methods">The execute_array(), execute_for_fetch() and bind_param_array() methods</a></li>
              <li><a href="#Fetching-data">Fetching data</a></li>
              <li><a href="#The-more_results-method">The more_results method</a></li>
              <li><a href="#Statement-attributes">Statement attributes</a></li>
              <li><a href="#Other-statement-methods">Other statement methods</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#Tests">Tests</a></li>
    </ul>
  </li>
  <li><a href="#CREATING-A-C-XS-DRIVER">CREATING A C/XS DRIVER</a>
    <ul>
      <li><a href="#C-XS-version-of-Driver.pm">C/XS version of Driver.pm</a>
        <ul>
          <li><a href="#The-connect-method">The connect method</a></li>
          <li><a href="#The-disconnect_all-method1">The disconnect_all method</a></li>
          <li><a href="#The-data_sources-method1">The data_sources method</a></li>
          <li><a href="#The-prepare-method">The prepare method</a></li>
          <li><a href="#The-execute-method">The execute method</a></li>
          <li><a href="#The-fetchrow_arrayref-method">The fetchrow_arrayref method</a></li>
          <li><a href="#Other-methods-">Other methods?</a></li>
        </ul>
      </li>
      <li><a href="#Driver.xs">Driver.xs</a></li>
      <li><a href="#Driver.h">Driver.h</a></li>
      <li><a href="#Implementation-header-dbdimp.h">Implementation header dbdimp.h</a></li>
      <li><a href="#Implementation-source-dbdimp.c">Implementation source dbdimp.c</a>
        <ul>
          <li><a href="#The-dbd_init-method">The dbd_init method</a></li>
          <li><a href="#The-dbd_drv_error-method">The dbd_drv_error method</a></li>
          <li><a href="#The-dbd_dr_data_sources-method">The dbd_dr_data_sources method</a></li>
          <li><a href="#The-dbd_db_login6-method">The dbd_db_login6 method</a></li>
          <li><a href="#The-dbd_db_commit-and-dbd_db_rollback-methods">The dbd_db_commit and dbd_db_rollback methods</a></li>
          <li><a href="#The-dbd_db_disconnect-method">The dbd_db_disconnect method</a></li>
          <li><a href="#The-dbd_db_discon_all-method">The dbd_db_discon_all method</a></li>
          <li><a href="#The-dbd_db_destroy-method">The dbd_db_destroy method</a></li>
          <li><a href="#The-dbd_db_STORE_attrib-method">The dbd_db_STORE_attrib method</a></li>
          <li><a href="#The-dbd_db_FETCH_attrib-method">The dbd_db_FETCH_attrib method</a></li>
          <li><a href="#The-dbd_st_prepare-method">The dbd_st_prepare method</a></li>
          <li><a href="#The-dbd_st_execute-method">The dbd_st_execute method</a></li>
          <li><a href="#The-dbd_st_fetch-method">The dbd_st_fetch method</a></li>
          <li><a href="#The-dbd_st_finish3-method">The dbd_st_finish3 method</a></li>
          <li><a href="#The-dbd_st_destroy-method">The dbd_st_destroy method</a></li>
          <li><a href="#The-dbd_st_STORE_attrib-and-dbd_st_FETCH_attrib-methods">The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods</a></li>
          <li><a href="#The-dbd_bind_ph-method">The dbd_bind_ph method</a></li>
          <li><a href="#Implementing-bind_param_inout-support">Implementing bind_param_inout support</a></li>
        </ul>
      </li>
      <li><a href="#C-XS-version-of-Makefile.PL">C/XS version of Makefile.PL</a></li>
      <li><a href="#Methods-which-do-not-need-to-be-written">Methods which do not need to be written</a></li>
    </ul>
  </li>
  <li><a href="#METADATA-METHODS">METADATA METHODS</a>
    <ul>
      <li><a href="#Using-DBI::DBD::Metadata">Using DBI::DBD::Metadata</a>
        <ul>
          <li><a href="#Generating-the-get_info-method">Generating the get_info method</a></li>
          <li><a href="#Generating-the-type_info-method">Generating the type_info method</a></li>
        </ul>
      </li>
      <li><a href="#Writing-DBD::Driver::db::get_info">Writing DBD::Driver::db::get_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::type_info_all">Writing DBD::Driver::db::type_info_all</a></li>
      <li><a href="#Writing-DBD::Driver::db::type_info">Writing DBD::Driver::db::type_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::table_info">Writing DBD::Driver::db::table_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::column_info">Writing DBD::Driver::db::column_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::primary_key_info">Writing DBD::Driver::db::primary_key_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::primary_key">Writing DBD::Driver::db::primary_key</a></li>
      <li><a href="#Writing-DBD::Driver::db::foreign_key_info">Writing DBD::Driver::db::foreign_key_info</a></li>
      <li><a href="#Writing-DBD::Driver::db::tables">Writing DBD::Driver::db::tables</a></li>
      <li><a href="#Writing-DBD::Driver::db::quote">Writing DBD::Driver::db::quote</a></li>
      <li><a href="#Writing-DBD::Driver::db::quote_identifier">Writing DBD::Driver::db::quote_identifier</a></li>
    </ul>
  </li>
  <li><a href="#TRACING">TRACING</a>
    <ul>
      <li><a href="#Trace-Level">Trace Level</a></li>
      <li><a href="#Trace-Flags">Trace Flags</a></li>
      <li><a href="#Trace-Macros">Trace Macros</a></li>
    </ul>
  </li>
  <li><a href="#WRITING-AN-EMULATION-LAYER-FOR-AN-OLD-PERL-INTERFACE">WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE</a>
    <ul>
      <li><a href="#Setting-emulation-perl-variables">Setting emulation perl variables</a></li>
    </ul>
  </li>
  <li><a href="#OTHER-MISCELLANEOUS-INFORMATION">OTHER MISCELLANEOUS INFORMATION</a>
    <ul>
      <li><a href="#The-imp_xyz_t-types">The imp_xyz_t types</a></li>
      <li><a href="#Using-DBIc_IMPSET_on">Using DBIc_IMPSET_on</a></li>
      <li><a href="#Using-DBIc_is-DBIc_has-DBIc_on-and-DBIc_off-">Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()</a></li>
      <li><a href="#Using-the-get_fbav-method">Using the get_fbav() method</a></li>
      <li><a href="#Casting-strings-to-Perl-types-based-on-a-SQL-type">Casting strings to Perl types based on a SQL type</a></li>
    </ul>
  </li>
  <li><a href="#SUBCLASSING-DBI-DRIVERS">SUBCLASSING DBI DRIVERS</a>
    <ul>
      <li><a href="#Overwriting-methods">Overwriting methods</a></li>
      <li><a href="#Attribute-handling">Attribute handling</a></li>
    </ul>
  </li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBI::DBD - Perl DBI Database Driver Writer&#39;s Guide</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  perldoc DBI::DBD</code></code></pre>

<h2 id="Version-and-volatility">Version and volatility</h2>

<p>This document is <i>still</i> a minimal draft which is in need of further work.</p>

<p>The changes will occur both because the <b>DBI</b> specification is changing and hence the requirements on <b>DBD</b> drivers change, and because feedback from people reading this document will suggest improvements to it.</p>

<p>Please read the <b>DBI</b> documentation first and fully, including the <b>DBI</b> FAQ. Then reread the <b>DBI</b> specification again as you&#39;re reading this. It&#39;ll help.</p>

<p>This document is a patchwork of contributions from various authors. More contributions (preferably as patches) are very welcome.</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This document is primarily intended to help people writing new database drivers for the Perl Database Interface (Perl DBI). It may also help others interested in discovering why the internals of a <b>DBD</b> driver are written the way they are.</p>

<p>This is a guide. Few (if any) of the statements in it are completely authoritative under all possible circumstances. This means you will need to use judgement in applying the guidelines in this document. If in <i>any</i> doubt at all, please do contact the <i>dbi-dev</i> mailing list (details given below) where Tim Bunce and other driver authors can help.</p>

<h1 id="CREATING-A-NEW-DRIVER">CREATING A NEW DRIVER</h1>

<p>The first rule for creating a new database driver for the Perl DBI is very simple: <b>DON&#39;T!</b></p>

<p>There is usually a driver already available for the database you want to use, almost regardless of which database you choose. Very often, the database will provide an ODBC driver interface, so you can often use <b>DBD::ODBC</b> to access the database. This is typically less convenient on a Unix box than on a Microsoft Windows box, but there are numerous options for ODBC driver managers on Unix too, and very often the ODBC driver is provided by the database supplier.</p>

<p>Before deciding that you need to write a driver, do your homework to ensure that you are not wasting your energies.</p>

<p>[As of December 2002, the consensus is that if you need an ODBC driver manager on Unix, then the unixODBC driver (available from <a href="http://www.unixodbc.org/">http://www.unixodbc.org/</a>) is the way to go.]</p>

<p>The second rule for creating a new database driver for the Perl DBI is also very simple: <b>Don&#39;t -- get someone else to do it for you!</b></p>

<p>Nevertheless, there are occasions when it is necessary to write a new driver, often to use a proprietary language or API to access the database more swiftly, or more comprehensively, than an ODBC driver can. Then you should read this document very carefully, but with a suitably sceptical eye.</p>

<p>If there is something in here that does not make any sense, question it. You might be right that the information is bogus, but don&#39;t come to that conclusion too quickly.</p>

<h2 id="URLs-and-mailing-lists">URLs and mailing lists</h2>

<p>The primary web-site for locating <b>DBI</b> software and information is</p>

<pre><code><code>  http://dbi.perl.org/</code></code></pre>

<p>There are two main and one auxiliary mailing lists for people working with <b>DBI</b>. The primary lists are <i>dbi-users@perl.org</i> for general users of <b>DBI</b> and <b>DBD</b> drivers, and <i>dbi-dev@perl.org</i> mainly for <b>DBD</b> driver writers (don&#39;t join the <i>dbi-dev</i> list unless you have a good reason). The auxiliary list is <i>dbi-announce@perl.org</i> for announcing new releases of <b>DBI</b> or <b>DBD</b> drivers.</p>

<p>You can join these lists by accessing the web-site <a href="http://dbi.perl.org/">http://dbi.perl.org/</a>. The lists are closed so you cannot send email to any of the lists unless you join the list first.</p>

<p>You should also consider monitoring the <i>comp.lang.perl.*</i> newsgroups, especially <i>comp.lang.perl.modules</i>.</p>

<h2 id="The-Cheetah-book">The Cheetah book</h2>

<p>The definitive book on Perl DBI is the Cheetah book, so called because of the picture on the cover. Its proper title is &#39;<i>Programming the Perl DBI: Database programming with Perl</i>&#39; by Alligator Descartes and Tim Bunce, published by O&#39;Reilly Associates, February 2000, ISBN 1-56592-699-4. Buy it now if you have not already done so, and read it.</p>

<h2 id="Locating-drivers">Locating drivers</h2>

<p>Before writing a new driver, it is in your interests to find out whether there already is a driver for your database. If there is such a driver, it would be much easier to make use of it than to write your own!</p>

<p>The primary web-site for locating Perl software is <a href="http://search.cpan.org/">http://search.cpan.org/</a>. You should look under the various modules listings for the software you are after. For example:</p>

<pre><code><code>  http://search.cpan.org/modlist/Database_Interfaces</code></code></pre>

<p>Follow the <b>DBD::</b> and <b>DBIx::</b> links at the top to see those subsets.</p>

<p>See the <b>DBI</b> docs for information on <b>DBI</b> web sites and mailing lists.</p>

<h2 id="Registering-a-new-driver">Registering a new driver</h2>

<p>Before going through any official registration process, you will need to establish that there is no driver already in the works. You&#39;ll do that by asking the <b>DBI</b> mailing lists whether there is such a driver available, or whether anybody is working on one.</p>

<p>When you get the go ahead, you will need to establish the name of the driver and a prefix for the driver. Typically, the name is based on the name of the database software it uses, and the prefix is a contraction of that. Hence, <b>DBD::Oracle</b> has the name <i>Oracle</i> and the prefix &#39;<i>ora_</i>&#39;. The prefix must be lowercase and contain no underscores other than the one at the end.</p>

<p>This information will be recorded in the <b>DBI</b> module. Apart from documentation purposes, registration is a prerequisite for <a href="../../lib/DBI.html#install_method">installing private methods</a>.</p>

<p>If you are writing a driver which will not be distributed on CPAN, then you should choose a prefix beginning with &#39;<i>x_</i>&#39;, to avoid potential prefix collisions with drivers registered in the future. Thus, if you wrote a non-CPAN distributed driver called <b>DBD::CustomDB</b>, the prefix might be &#39;<i>x_cdb_</i>&#39;.</p>

<p>This document assumes you are writing a driver called <b>DBD::Driver</b>, and that the prefix &#39;<i>drv_</i>&#39; is assigned to the driver.</p>

<h2 id="Two-styles-of-database-driver">Two styles of database driver</h2>

<p>There are two distinct styles of database driver that can be written to work with the Perl DBI.</p>

<p>Your driver can be written in pure Perl, requiring no C compiler. When feasible, this is the best solution, but most databases are not written in such a way that this can be done. Some examples of pure Perl drivers are <b>DBD::File</b> and <b>DBD::CSV</b>.</p>

<p>Alternatively, and most commonly, your driver will need to use some C code to gain access to the database. This will be classified as a C/XS driver.</p>

<h2 id="What-code-will-you-write-">What code will you write?</h2>

<p>There are a number of files that need to be written for either a pure Perl driver or a C/XS driver. There are no extra files needed only by a pure Perl driver, but there are several extra files needed only by a C/XS driver.</p>

<h3 id="Files-common-to-pure-Perl-and-C-XS-drivers">Files common to pure Perl and C/XS drivers</h3>

<p>Assuming that your driver is called <b>DBD::Driver</b>, these files are:</p>

<ul>

<li><p><i>Makefile.PL</i></p>

</li>
<li><p><i>META.yml</i></p>

</li>
<li><p><i>README</i></p>

</li>
<li><p><i>MANIFEST</i></p>

</li>
<li><p><i>Driver.pm</i></p>

</li>
<li><p><i>lib/Bundle/DBD/Driver.pm</i></p>

</li>
<li><p><i>lib/DBD/Driver/Summary.pm</i></p>

</li>
<li><p><i>t/*.t</i></p>

</li>
</ul>

<p>The first four files are mandatory. <i>Makefile.PL</i> is used to control how the driver is built and installed. The <i>README</i> file tells people who download the file about how to build the module and any prerequisite software that must be installed. The <i>MANIFEST</i> file is used by the standard Perl module distribution mechanism. It lists all the source files that need to be distributed with your module. <i>Driver.pm</i> is what is loaded by the <b>DBI</b> code; it contains the methods peculiar to your driver.</p>

<p>Although the <i>META.yml</i> file is not <b>required</b> you are advised to create one. Of particular importance are the <i>build_requires</i> and <i>configure_requires</i> attributes which newer CPAN modules understand. You use these to tell the CPAN module (and CPANPLUS) that your build and configure mechanisms require DBI. The best reference for META.yml (at the time of writing) is <a href="http://module-build.sourceforge.net/META-spec-v1.4.html">http://module-build.sourceforge.net/META-spec-v1.4.html</a>. You can find a reasonable example of a <i>META.yml</i> in DBD::ODBC.</p>

<p>The <i>lib/Bundle/DBD/Driver.pm</i> file allows you to specify other Perl modules on which yours depends in a format that allows someone to type a simple command and ensure that all the pre-requisites are in place as well as building your driver.</p>

<p>The <i>lib/DBD/Driver/Summary.pm</i> file contains (an updated version of) the information that was included - or that would have been included - in the appendices of the Cheetah book as a summary of the abilities of your driver and the associated database.</p>

<p>The files in the <i>t</i> subdirectory are unit tests for your driver. You should write your tests as stringently as possible, while taking into account the diversity of installations that you can encounter:</p>

<ul>

<li><p>Your tests should not casually modify operational databases.</p>

</li>
<li><p>You should never damage existing tables in a database.</p>

</li>
<li><p>You should code your tests to use a constrained name space within the database. For example, the tables (and all other named objects) that are created could all begin with &#39;<i>dbd_drv_</i>&#39;.</p>

</li>
<li><p>At the end of a test run, there should be no testing objects left behind in the database.</p>

</li>
<li><p>If you create any databases, you should remove them.</p>

</li>
<li><p>If your database supports temporary tables that are automatically removed at the end of a session, then exploit them as often as possible.</p>

</li>
<li><p>Try to make your tests independent of each other. If you have a test <i>t/t11dowhat.t</i> that depends upon the successful running of <i>t/t10thingamy.t</i>, people cannot run the single test case <i>t/t11dowhat.t</i>. Further, running <i>t/t11dowhat.t</i> twice in a row is likely to fail (at least, if <i>t/t11dowhat.t</i> modifies the database at all) because the database at the start of the second run is not what you saw at the start of the first run.</p>

</li>
<li><p>Document in your <i>README</i> file what you do, and what privileges people need to do it.</p>

</li>
<li><p>You can, and probably should, sequence your tests by including a test number before an abbreviated version of the test name; the tests are run in the order in which the names are expanded by shell-style globbing.</p>

</li>
<li><p>It is in your interests to ensure that your tests work as widely as possible.</p>

</li>
</ul>

<p>Many drivers also install sub-modules <b>DBD::Driver::SubModule</b> for any of a variety of different reasons, such as to support the metadata methods (see the discussion of <a href="#METADATA-METHODS">&quot;METADATA METHODS&quot;</a> below). Such sub-modules are conventionally stored in the directory <i>lib/DBD/Driver</i>. The module itself would usually be in a file <i>SubModule.pm</i>. All such sub-modules should themselves be version stamped (see the discussions far below).</p>

<h3 id="Extra-files-needed-by-C-XS-drivers">Extra files needed by C/XS drivers</h3>

<p>The software for a C/XS driver will typically contain at least four extra files that are not relevant to a pure Perl driver.</p>

<ul>

<li><p><i>Driver.xs</i></p>

</li>
<li><p><i>Driver.h</i></p>

</li>
<li><p><i>dbdimp.h</i></p>

</li>
<li><p><i>dbdimp.c</i></p>

</li>
</ul>

<p>The <i>Driver.xs</i> file is used to generate C code that Perl can call to gain access to the C functions you write that will, in turn, call down onto your database software.</p>

<p>The <i>Driver.h</i> header is a stylized header that ensures you can access the necessary Perl and <b>DBI</b> macros, types, and function declarations.</p>

<p>The <i>dbdimp.h</i> is used to specify which functions have been implemented by your driver.</p>

<p>The <i>dbdimp.c</i> file is where you write the C code that does the real work of translating between Perl-ish data types and what the database expects to use and return.</p>

<p>There are some (mainly small, but very important) differences between the contents of <i>Makefile.PL</i> and <i>Driver.pm</i> for pure Perl and C/XS drivers, so those files are described both in the section on creating a pure Perl driver and in the section on creating a C/XS driver.</p>

<p>Obviously, you can add extra source code files to the list.</p>

<h2 id="Requirements-on-a-driver-and-driver-writer">Requirements on a driver and driver writer</h2>

<p>To be remotely useful, your driver must be implemented in a format that allows it to be distributed via CPAN, the Comprehensive Perl Archive Network (<a href="http://www.cpan.org/">http://www.cpan.org/</a> and <a href="http://search.cpan.org">http://search.cpan.org</a>). Of course, it is easier if you do not have to meet this criterion, but you will not be able to ask for much help if you do not do so, and no-one is likely to want to install your module if they have to learn a new installation mechanism.</p>

<h1 id="CREATING-A-PURE-PERL-DRIVER">CREATING A PURE PERL DRIVER</h1>

<p>Writing a pure Perl driver is surprisingly simple. However, there are some problems you should be aware of. The best option is of course picking up an existing driver and carefully modifying one method after the other.</p>

<p>Also look carefully at <b>DBD::AnyData</b> and <b>DBD::Template</b>.</p>

<p>As an example we take a look at the <b>DBD::File</b> driver, a driver for accessing plain files as tables, which is part of the <b>DBD::CSV</b> package.</p>

<p>The minimal set of files we have to implement are <i>Makefile.PL</i>, <i>README</i>, <i>MANIFEST</i> and <i>Driver.pm</i>.</p>

<h2 id="Pure-Perl-version-of-Makefile.PL">Pure Perl version of Makefile.PL</h2>

<p>You typically start with writing <i>Makefile.PL</i>, a Makefile generator. The contents of this file are described in detail in the <a href="../../lib/ExtUtils/MakeMaker.html">ExtUtils::MakeMaker</a> man pages. It is definitely a good idea if you start reading them. At least you should know about the variables <i>CONFIGURE</i>, <i>DEFINED</i>, <i>PM</i>, <i>DIR</i>, <i>EXE_FILES</i>, <i>INC</i>, <i>LIBS</i>, <i>LINKTYPE</i>, <i>NAME</i>, <i>OPTIMIZE</i>, <i>PL_FILES</i>, <i>VERSION</i>, <i>VERSION_FROM</i>, <i>clean</i>, <i>depend</i>, <i>realclean</i> from the <a href="../../lib/ExtUtils/MakeMaker.html">ExtUtils::MakeMaker</a> man page: these are used in almost any <i>Makefile.PL</i>.</p>

<p>Additionally read the section on <i>Overriding MakeMaker Methods</i> and the descriptions of the <i>distcheck</i>, <i>disttest</i> and <i>dist</i> targets: They will definitely be useful for you.</p>

<p>Of special importance for <b>DBI</b> drivers is the <i>postamble</i> method from the <a href="../../lib/ExtUtils/MM_Unix.html">ExtUtils::MM_Unix</a> man page.</p>

<p>For Emacs users, I recommend the <i>libscan</i> method, which removes Emacs backup files (file names which end with a tilde &#39;~&#39;) from lists of files.</p>

<p>Now an example, I use the word <code><code>Driver</code></code> wherever you should insert your driver&#39;s name:</p>

<pre><code><code>  <span class="comment"># -*- perl -*-</span>
  
  <span class="keyword">use</span> <span class="variable">ExtUtils::MakeMaker</span><span class="operator">;</span>
  
  <span class="variable">WriteMakefile</span><span class="operator">(</span>
      <span class="variable">dbd_edit_mm_attribs</span><span class="operator">(</span> <span class="operator">{</span>
          <span class="string">'NAME'</span>         <span class="operator">=&gt;</span> <span class="string">'DBD::Driver'</span><span class="operator">,</span>
          <span class="string">'VERSION_FROM'</span> <span class="operator">=&gt;</span> <span class="string">'Driver.pm'</span><span class="operator">,</span>
          <span class="string">'INC'</span>          <span class="operator">=&gt;</span> <span class="string">''</span><span class="operator">,</span>
          <span class="string">'dist'</span>         <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">'SUFFIX'</span>   <span class="operator">=&gt;</span> <span class="string">'.gz'</span><span class="operator">,</span>
                              <span class="string">'COMPRESS'</span> <span class="operator">=&gt;</span> <span class="string">'gzip -9f'</span> <span class="operator">}</span><span class="operator">,</span>
          <span class="string">'realclean'</span>    <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">FILES</span> <span class="operator">=&gt;</span> <span class="string">'*.xsi'</span> <span class="operator">}</span><span class="operator">,</span>
          <span class="string">'PREREQ_PM'</span>    <span class="operator">=&gt;</span> <span class="string">'1.03'</span><span class="operator">,</span>
          <span class="string">'CONFIGURE'</span>    <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span>
              <span class="keyword">eval</span> <span class="operator">{</span><span class="keyword">require</span> <span class="variable">DBI::DBD</span><span class="operator">;};</span>
              <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$@</span><span class="operator">)</span> <span class="operator">{</span>
                  <span class="keyword">warn</span> <span class="variable">$@</span><span class="operator">;</span>
                  <span class="keyword">exit</span> <span class="number">0</span><span class="operator">;</span>
              <span class="operator">}</span>
              <span class="keyword">my</span> <span class="variable">$dbi_arch_dir</span> <span class="operator">=</span> <span class="variable">dbd_dbi_arch_dir</span><span class="operator">();</span>
              <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">exists</span><span class="operator">(</span><span class="variable">$opts</span><span class="operator">{</span><span class="string">INC</span><span class="operator">}</span><span class="operator">))</span> <span class="operator">{</span>
                  <span class="keyword">return</span> <span class="operator">{</span><span class="string">INC</span> <span class="operator">=&gt;</span> <span class="string">"</span><span class="variable">$opts</span><span class="string">{INC} -I</span><span class="variable">$dbi_arch_dir</span><span class="string">"</span><span class="operator">}</span><span class="operator">;</span>
              <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
                  <span class="keyword">return</span> <span class="operator">{</span><span class="string">INC</span> <span class="operator">=&gt;</span> <span class="string">"-I</span><span class="variable">$dbi_arch_dir</span><span class="string">"</span><span class="operator">}</span><span class="operator">;</span>
              <span class="operator">}</span>
          <span class="operator">}</span>
      <span class="operator">}</span><span class="operator">,</span>
      <span class="operator">{</span> <span class="string">create_pp_tests</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">)</span>
  <span class="operator">);</span>
  
  <span class="keyword">package</span> <span class="variable">MY</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> postamble </span><span class="operator">{</span> <span class="keyword">return</span> <span class="variable">main::dbd_postamble</span><span class="operator">(</span><span class="variable">@_</span><span class="operator">);</span> <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> libscan </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span> <span class="variable">$path</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="operator">(</span><span class="variable">$path</span> <span class="operator">=~</span> <span class="regex">m/\~$/</span><span class="operator">)</span> <span class="operator">?</span> <span class="keyword">undef</span> <span class="operator">:</span> <span class="variable">$path</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Note the calls to <code><code>dbd_edit_mm_attribs()</code></code> and <code><code>dbd_postamble()</code></code>.</p>

<p>The second hash reference in the call to <code><code>dbd_edit_mm_attribs()</code></code> (containing <code><code>create_pp_tests()</code></code>) is optional; you should not use it unless your driver is a pure Perl driver (that is, it does not use C and XS code). Therefore, the call to <code><code>dbd_edit_mm_attribs()</code></code> is not relevant for C/XS drivers and may be omitted; simply use the (single) hash reference containing NAME etc as the only argument to <code><code>WriteMakefile()</code></code>.</p>

<p>Note that the <code><code>dbd_edit_mm_attribs()</code></code> code will fail if you do not have a <i>t</i> sub-directory containing at least one test case.</p>

<p><i>PREREQ_PM</i> tells MakeMaker that DBI (version 1.03 in this case) is required for this module. This will issue a warning that DBI 1.03 is missing if someone attempts to install your DBD without DBI 1.03. See <i>CONFIGURE</i> below for why this does not work reliably in stopping cpan testers failing your module if DBI is not installed.</p>

<p><i>CONFIGURE</i> is a subroutine called by MakeMaker during <code><code>WriteMakefile</code></code>. By putting the <code><code>require DBI::DBD</code></code> in this section we can attempt to load DBI::DBD but if it is missing we exit with success. As we exit successfully without creating a Makefile when DBI::DBD is missing cpan testers will not report a failure. This may seem at odds with <i>PREREQ_PM</i> but <i>PREREQ_PM</i> does not cause <code><code>WriteMakefile</code></code> to fail (unless you also specify PREREQ_FATAL which is strongly discouraged by MakeMaker) so <code><code>WriteMakefile</code></code> would continue to call <code><code>dbd_dbi_arch_dir</code></code> and fail.</p>

<p>All drivers must use <code><code>dbd_postamble()</code></code> or risk running into problems.</p>

<p>Note the specification of <i>VERSION_FROM</i>; the named file (<i>Driver.pm</i>) will be scanned for the first line that looks like an assignment to <i>$VERSION</i>, and the subsequent text will be used to determine the version number. Note the commentary in <a href="../../lib/ExtUtils/MakeMaker.html">ExtUtils::MakeMaker</a> on the subject of correctly formatted version numbers.</p>

<p>If your driver depends upon external software (it usually will), you will need to add code to ensure that your environment is workable before the call to <code><code>WriteMakefile()</code></code>. If you need to check for the existence of an external library and perhaps modify <i>INC</i> to include the paths to where the external library header files are located and you cannot find the library or header files make sure you output a message saying they cannot be found but <code><code>exit 0</code></code> (success) <b>before</b> calling <code><code>WriteMakefile</code></code> or CPAN testers will fail your module if the external library is not found.</p>

<p>A full-fledged <i>Makefile.PL</i> can be quite large (for example, the files for <b>DBD::Oracle</b> and <b>DBD::Informix</b> are both over 1000 lines long, and the Informix one uses - and creates - auxiliary modules too).</p>

<p>See also <a href="../../lib/ExtUtils/MakeMaker.html">ExtUtils::MakeMaker</a> and <a href="../../lib/ExtUtils/MM_Unix.html">ExtUtils::MM_Unix</a>. Consider using <a>CPAN::MakeMaker</a> in place of <i>ExtUtils::MakeMaker</i>.</p>

<h2 id="README">README</h2>

<p>The <a>README</a> file should describe what the driver is for, the pre-requisites for the build process, the actual build process, how to report errors, and who to report them to.</p>

<p>Users will find ways of breaking the driver build and test process which you would never even have dreamed to be possible in your worst nightmares. Therefore, you need to write this document defensively, precisely and concisely.</p>

<p>As always, use the <i>README</i> from one of the established drivers as a basis for your own; the version in <b>DBD::Informix</b> is worth a look as it has been quite successful in heading off problems.</p>

<ul>

<li><p>Note that users will have versions of Perl and <b>DBI</b> that are both older and newer than you expected, but this will seldom cause much trouble. When it does, it will be because you are using features of <b>DBI</b> that are not supported in the version they are using.</p>

</li>
<li><p>Note that users will have versions of the database software that are both older and newer than you expected. You will save yourself time in the long run if you can identify the range of versions which have been tested and warn about versions which are not known to be OK.</p>

</li>
<li><p>Note that many people trying to install your driver will not be experts in the database software.</p>

</li>
<li><p>Note that many people trying to install your driver will not be experts in C or Perl.</p>

</li>
</ul>

<h2 id="MANIFEST">MANIFEST</h2>

<p>The <i>MANIFEST</i> will be used by the Makefile&#39;s dist target to build the distribution tar file that is uploaded to CPAN. It should list every file that you want to include in your distribution, one per line.</p>

<h2 id="lib-Bundle-DBD-Driver.pm">lib/Bundle/DBD/Driver.pm</h2>

<p>The CPAN module provides an extremely powerful bundle mechanism that allows you to specify pre-requisites for your driver.</p>

<p>The primary pre-requisite is <b>Bundle::DBI</b>; you may want or need to add some more. With the bundle set up correctly, the user can type:</p>

<pre><code><code>        perl -MCPAN -e &#39;install Bundle::DBD::Driver&#39;</code></code></pre>

<p>and Perl will download, compile, test and install all the Perl modules needed to build your driver.</p>

<p>The prerequisite modules are listed in the <code><code>CONTENTS</code></code> section, with the official name of the module followed by a dash and an informal name or description.</p>

<ul>

<li><p>Listing <b>Bundle::DBI</b> as the main pre-requisite simplifies life.</p>

</li>
<li><p>Don&#39;t forget to list your driver.</p>

</li>
<li><p>Note that unless the DBMS is itself a Perl module, you cannot list it as a pre-requisite in this file.</p>

</li>
<li><p>You should keep the version of the bundle the same as the version of your driver.</p>

</li>
<li><p>You should add configuration management, copyright, and licencing information at the top.</p>

</li>
</ul>

<p>A suitable skeleton for this file is shown below.</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">Bundle::DBD::Driver</span><span class="operator">;</span>
  
  <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="string">'0.01'</span><span class="operator">;</span>
  
  <span class="number">1</span><span class="operator">;</span>
  
  <span class="comment">__END__
  
  =head1 NAME
  
  Bundle::DBD::Driver - A bundle to install all DBD::Driver related modules
  
  =head1 SYNOPSIS
  
  C&lt;perl -MCPAN -e 'install Bundle::DBD::Driver'&gt;
  
  =head1 CONTENTS
  
  Bundle::DBI  - Bundle for DBI by TIMB (Tim Bunce)
  
  DBD::Driver  - DBD::Driver by YOU (Your Name)
  
  =head1 DESCRIPTION
  
  This bundle includes all the modules used by the Perl Database
  Interface (DBI) driver for Driver (DBD::Driver), assuming the
  use of DBI version 1.13 or later, created by Tim Bunce.
  
  If you've not previously used the CPAN module to install any
  bundles, you will be interrogated during its setup phase.
  But when you've done it once, it remembers what you told it.
  You could start by running:
  
    C&lt;perl -MCPAN -e 'install Bundle::CPAN'&gt;
  
  =head1 SEE ALSO
  
  Bundle::DBI
  
  =head1 AUTHOR
  
  Your Name E&lt;lt&gt;F&lt;you@yourdomain.com&gt;E&lt;gt&gt;
  
  =head1 THANKS
  
  This bundle was created by ripping off Bundle::libnet created by
  Graham Barr E&lt;lt&gt;F&lt;gbarr@ti.com&gt;E&lt;gt&gt;, and radically simplified
  with some information from Jochen Wiedmann E&lt;lt&gt;F&lt;joe@ispsoft.de&gt;E&lt;gt&gt;.
  The template was then included in the DBI::DBD documentation by
  Jonathan Leffler E&lt;lt&gt;F&lt;jleffler@informix.com&gt;E&lt;gt&gt;.
  
  =cut
  </span>
</code></code></pre>

<h2 id="lib-DBD-Driver-Summary.pm">lib/DBD/Driver/Summary.pm</h2>

<p>There is no substitute for taking the summary file from a driver that was documented in the Perl book (such as <b>DBD::Oracle</b> or <b>DBD::Informix</b> or <b>DBD::ODBC</b>, to name but three), and adapting it to describe the facilities available via <b>DBD::Driver</b> when accessing the Driver database.</p>

<h2 id="Pure-Perl-version-of-Driver.pm">Pure Perl version of Driver.pm</h2>

<p>The <i>Driver.pm</i> file defines the Perl module <b>DBD::Driver</b> for your driver. It will define a package <b>DBD::Driver</b> along with some version information, some variable definitions, and a function <code><code>driver()</code></code> which will have a more or less standard structure.</p>

<p>It will also define three sub-packages of <b>DBD::Driver</b>:</p>

<dl>

<dt id="DBD::Driver::dr">DBD::Driver::dr</dt>
<dd>

<p>with methods <code><code>connect()</code></code>, <code><code>data_sources()</code></code> and <code><code>disconnect_all()</code></code>;</p>

</dd>
<dt id="DBD::Driver::db">DBD::Driver::db</dt>
<dd>

<p>with methods such as <code><code>prepare()</code></code>;</p>

</dd>
<dt id="DBD::Driver::st">DBD::Driver::st</dt>
<dd>

<p>with methods such as <code><code>execute()</code></code> and <code><code>fetch()</code></code>.</p>

</dd>
</dl>

<p>The <i>Driver.pm</i> file will also contain the documentation specific to <b>DBD::Driver</b> in the format used by perldoc.</p>

<p>In a pure Perl driver, the <i>Driver.pm</i> file is the core of the implementation. You will need to provide all the key methods needed by <b>DBI</b>.</p>

<p>Now let&#39;s take a closer look at an excerpt of <i>File.pm</i> as an example. We ignore things that are common to any module (even non-DBI modules) or really specific to the <b>DBD::File</b> package.</p>

<h3 id="The-DBD::Driver-package">The DBD::Driver package</h3>

<h4 id="The-header">The header</h4>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">DBD::File</span><span class="operator">;</span>
  
  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">vars</span> <span class="string">qw($VERSION $drh)</span><span class="operator">;</span>
  
  <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="string">"1.23.00"</span>  <span class="comment"># Version number of DBD::File</span>
</code></code></pre>

<p>This is where the version number of your driver is specified, and is where <i>Makefile.PL</i> looks for this information. Please ensure that any other modules added with your driver are also version stamped so that CPAN does not get confused.</p>

<p>It is recommended that you use a two-part (1.23) or three-part (1.23.45) version number. Also consider the CPAN system, which gets confused and considers version 1.10 to precede version 1.9, so that using a raw CVS, RCS or SCCS version number is probably not appropriate (despite being very common).</p>

<p>For Subversion you could use:</p>

<pre><code><code>  <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="keyword">sprintf</span><span class="operator">(</span><span class="string">"12.%06d"</span><span class="operator">,</span> <span class="string">q$Revision: 12345 $</span> <span class="operator">=~</span> <span class="regex">/(\d+)/o</span><span class="operator">);</span>
</code></code></pre>

<p>(use lots of leading zeros on the second portion so if you move the code to a shared repository like svn.perl.org the much larger revision numbers won&#39;t cause a problem, at least not for a few years). For RCS or CVS you can use:</p>

<pre><code><code>  <span class="variable">$VERSION</span> <span class="operator">=</span> <span class="keyword">sprintf</span> <span class="string">"%d.%02d"</span><span class="operator">,</span> <span class="string">'$Revision: 11.21 $ '</span> <span class="operator">=~</span> <span class="regex">/(\d+)\.(\d+)/</span><span class="operator">;</span>
</code></code></pre>

<p>which pads out the fractional part with leading zeros so all is well (so long as you don&#39;t go past x.99)</p>

<pre><code><code>  <span class="variable">$drh</span> <span class="operator">=</span> <span class="keyword">undef</span><span class="operator">;</span>         <span class="comment"># holds driver handle once initialized</span>
</code></code></pre>

<p>This is where the driver handle will be stored, once created. Note that you may assume there is only one handle for your driver.</p>

<h4 id="The-driver-constructor">The driver constructor</h4>

<p>The <code><code>driver()</code></code> method is the driver handle constructor. Note that the <code><code>driver()</code></code> method is in the <b>DBD::Driver</b> package, not in one of the sub-packages <b>DBD::Driver::dr</b>, <b>DBD::Driver::db</b>, or <b>DBD::Driver::db</b>.</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> driver
  </span><span class="operator">{</span>
      <span class="keyword">return</span> <span class="variable">$drh</span> <span class="keyword">if</span> <span class="variable">$drh</span><span class="operator">;</span>      <span class="comment"># already created - return same one</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$class</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="variable">$class</span> <span class="operator">.=</span> <span class="string">"::dr"</span><span class="operator">;</span>
  
      <span class="variable">DBD::Driver::db</span><span class="operator">-&gt;</span><span class="variable">install_method</span><span class="operator">(</span><span class="string">'drv_example_dbh_method'</span><span class="operator">);</span>
      <span class="variable">DBD::Driver::st</span><span class="operator">-&gt;</span><span class="variable">install_method</span><span class="operator">(</span><span class="string">'drv_example_sth_method'</span><span class="operator">);</span>
  
      <span class="comment"># not a 'my' since we use it above to prevent multiple drivers</span>
      <span class="variable">$drh</span> <span class="operator">=</span> <span class="variable">DBI::_new_drh</span><span class="operator">(</span><span class="variable">$class</span><span class="operator">,</span> <span class="operator">{</span>
              <span class="string">'Name'</span>        <span class="operator">=&gt;</span> <span class="string">'File'</span><span class="operator">,</span>
              <span class="string">'Version'</span>     <span class="operator">=&gt;</span> <span class="variable">$VERSION</span><span class="operator">,</span>
              <span class="string">'Attribution'</span> <span class="operator">=&gt;</span> <span class="string">'DBD::File by Jochen Wiedmann'</span><span class="operator">,</span>
          <span class="operator">}</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
  
      <span class="keyword">return</span> <span class="variable">$drh</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>This is a reasonable example of how <b>DBI</b> implements its handles. There are three kinds: <b>driver handles</b> (typically stored in <i>$drh</i>; from now on called <i>drh</i> or <i>$drh</i>), <b>database handles</b> (from now on called <i>dbh</i> or <i>$dbh</i>) and <b>statement handles</b> (from now on called <i>sth</i> or <i>$sth</i>).</p>

<p>The prototype of <code><code>DBI::_new_drh()</code></code> is</p>

<pre><code><code>  <span class="variable">$drh</span> <span class="operator">=</span> <span class="variable">DBI::_new_drh</span><span class="operator">(</span><span class="variable">$class</span><span class="operator">,</span> <span class="variable">$public_attrs</span><span class="operator">,</span> <span class="variable">$private_attrs</span><span class="operator">);</span>
</code></code></pre>

<p>with the following arguments:</p>

<dl>

<dt id="class"><i>$class</i></dt>
<dd>

<p>is typically the class for your driver, (for example, &quot;DBD::File::dr&quot;), passed as the first argument to the <code><code>driver()</code></code> method.</p>

</dd>
<dt id="public_attrs"><i>$public_attrs</i></dt>
<dd>

<p>is a hash ref to attributes like <i>Name</i>, <i>Version</i>, and <i>Attribution</i>. These are processed and used by <b>DBI</b>. You had better not make any assumptions about them nor should you add private attributes here.</p>

</dd>
<dt id="private_attrs"><i>$private_attrs</i></dt>
<dd>

<p>This is another (optional) hash ref with your private attributes. <b>DBI</b> will store them and otherwise leave them alone.</p>

</dd>
</dl>

<p>The <code><code>DBI::_new_drh()</code></code> method and the <code><code>driver()</code></code> method both return <code><code>undef</code></code> for failure (in which case you must look at <i>$DBI::err</i> and <i>$DBI::errstr</i> for the failure information, because you have no driver handle to use).</p>

<h4 id="Using-install_method-to-expose-driver-private-methods">Using install_method() to expose driver-private methods</h4>

<pre><code><code>    <span class="variable">DBD::Foo::db</span><span class="operator">-&gt;</span><span class="variable">install_method</span><span class="operator">(</span><span class="variable">$method_name</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</code></code></pre>

<p>Installs the driver-private method named by $method_name into the DBI method dispatcher so it can be called directly, avoiding the need to use the func() method.</p>

<p>It is called as a static method on the driver class to which the method belongs. The method name must begin with the corresponding registered driver-private prefix. For example, for DBD::Oracle $method_name must being with &#39;<code><code>ora_</code></code>&#39;, and for DBD::AnyData it must begin with &#39;<code><code>ad_</code></code>&#39;.</p>

<p>The <code><code>\%attr</code></code> attributes can be used to provide fine control over how the DBI dispatcher handles the dispatching of the method. However it&#39;s undocumented at the moment. See the IMA_* #define&#39;s in DBI.xs and the O=&gt;0x000x values in the initialization of %DBI::DBI_methods in DBI.pm. (Volunteers to polish up and document the interface are very welcome to get in touch via dbi-dev@perl.org).</p>

<p>Methods installed using install_method default to the standard error handling behaviour for DBI methods: clearing err and errstr before calling the method, and checking for errors to trigger RaiseError etc. on return. This differs from the default behaviour of func().</p>

<p>Note for driver authors: The DBD::Foo::xx-&gt;install_method call won&#39;t work until the class-hierarchy has been setup. Normally the DBI looks after that just after the driver is loaded. This means install_method() can&#39;t be called at the time the driver is loaded unless the class-hierarchy is set up first. The way to do that is to call the setup_driver() method:</p>

<pre><code><code>    <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">setup_driver</span><span class="operator">(</span><span class="string">'DBD::Foo'</span><span class="operator">);</span>
</code></code></pre>

<p>before using install_method().</p>

<h4 id="The-CLONE-special-subroutine">The CLONE special subroutine</h4>

<p>Also needed here, in the <b>DBD::Driver</b> package, is a <code><code>CLONE()</code></code> method that will be called by perl when an interpreter is cloned. All your <code><code>CLONE()</code></code> method needs to do, currently, is clear the cached <i>$drh</i> so the new interpreter won&#39;t start using the cached <i>$drh</i> from the old interpreter:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> CLONE </span><span class="operator">{</span>
    <span class="keyword">undef</span> <span class="variable">$drh</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>See <a href="http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe">http://search.cpan.org/dist/perl/pod/perlmod.pod#Making_your_module_threadsafe</a> for details.</p>

<h3 id="The-DBD::Driver::dr-package">The DBD::Driver::dr package</h3>

<p>The next lines of code look as follows:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">DBD::Driver::dr</span><span class="operator">;</span> <span class="comment"># ====== DRIVER ======</span>
  
  <span class="variable">$DBD::Driver::dr::imp_data_size</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<p>Note that no <i>@ISA</i> is needed here, or for the other <b>DBD::Driver::*</b> classes, because the <b>DBI</b> takes care of that for you when the driver is loaded.</p>

<pre><code><code> *FIX ME* Explain what the imp_data_size is, so that implementors aren&#39;t
 practicing cargo-cult programming.</code></code></pre>

<h4 id="The-database-handle-constructor">The database handle constructor</h4>

<p>The database handle constructor is the driver&#39;s (hence the changed namespace) <code><code>connect()</code></code> method:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> connect
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="variable">$dr_dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="comment"># Some database specific verifications, default settings</span>
      <span class="comment"># and the like can go here. This should only include</span>
      <span class="comment"># syntax checks or similar stuff where it's legal to</span>
      <span class="comment"># 'die' in case of errors.</span>
      <span class="comment"># For example, many database packages requires specific</span>
      <span class="comment"># environment variables to be set; this could be where you</span>
      <span class="comment"># validate that they are set, or default them if they are not set.</span>
  
      <span class="keyword">my</span> <span class="variable">$driver_prefix</span> <span class="operator">=</span> <span class="string">"drv_"</span><span class="operator">;</span> <span class="comment"># the assigned prefix for this driver</span>
  
      <span class="comment"># Process attributes from the DSN; we assume ODBC syntax</span>
      <span class="comment"># here, that is, the DSN looks like var1=val1;...;varN=valN</span>
      <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$var</span> <span class="operator">(</span> <span class="keyword">split</span> <span class="regex">/;/</span><span class="operator">,</span> <span class="variable">$dr_dsn</span> <span class="operator">)</span> <span class="operator">{</span>
          <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$attr_name</span><span class="operator">,</span> <span class="variable">$attr_value</span><span class="operator">)</span> <span class="operator">=</span> <span class="keyword">split</span> <span class="string">'='</span><span class="operator">,</span> <span class="variable">$var</span><span class="operator">,</span> <span class="number">2</span><span class="operator">;</span>
          <span class="keyword">return</span> <span class="variable">$drh</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$DBI::stderr</span><span class="operator">,</span> <span class="string">"Can't parse DSN part '</span><span class="variable">$var</span><span class="string">'"</span><span class="operator">)</span>
              <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$attr_value</span><span class="operator">;</span>
  
          <span class="comment"># add driver prefix to attribute name if it doesn't have it already</span>
          <span class="variable">$attr_name</span> <span class="operator">=</span> <span class="variable">$driver_prefix</span><span class="operator">.</span><span class="variable">$attr_name</span>
              <span class="keyword">unless</span> <span class="variable">$attr_name</span> <span class="operator">=~</span> <span class="regex">/^</span><span class="variable">$driver_prefix</span><span class="regex">/o</span><span class="operator">;</span>
  
          <span class="comment"># Store attribute into %$attr, replacing any existing value.</span>
          <span class="comment"># The DBI will STORE() these into $dbh after we've connected</span>
          <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$attr_name</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$attr_value</span><span class="operator">;</span>
      <span class="operator">}</span>
  
      <span class="comment"># Get the attributes we'll use to connect.</span>
      <span class="comment"># We use delete here because these no need to STORE them</span>
      <span class="keyword">my</span> <span class="variable">$db</span> <span class="operator">=</span> <span class="keyword">delete</span> <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_database</span><span class="operator">}</span> <span class="operator">||</span> <span class="keyword">delete</span> <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_db</span><span class="operator">}</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="variable">$drh</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$DBI::stderr</span><span class="operator">,</span> <span class="string">"No database name given in DSN '</span><span class="variable">$dr_dsn</span><span class="string">'"</span><span class="operator">);</span>
      <span class="keyword">my</span> <span class="variable">$host</span> <span class="operator">=</span> <span class="keyword">delete</span> <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_host</span><span class="operator">}</span> <span class="operator">||</span> <span class="string">'localhost'</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$port</span> <span class="operator">=</span> <span class="keyword">delete</span> <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_port</span><span class="operator">}</span> <span class="operator">||</span> <span class="number">123456</span><span class="operator">;</span>
  
      <span class="comment"># Assume you can attach to your database via drv_connect:</span>
      <span class="keyword">my</span> <span class="variable">$connection</span> <span class="operator">=</span> <span class="variable">drv_connect</span><span class="operator">(</span><span class="variable">$db</span><span class="operator">,</span> <span class="variable">$host</span><span class="operator">,</span> <span class="variable">$port</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="variable">$drh</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$DBI::stderr</span><span class="operator">,</span> <span class="string">"Can't connect to </span><span class="variable">$dr_dsn</span><span class="string">: ..."</span><span class="operator">);</span>
  
      <span class="comment"># create a 'blank' dbh (call superclass constructor)</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$outer</span><span class="operator">,</span> <span class="variable">$dbh</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">DBI::_new_dbh</span><span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">Name</span> <span class="operator">=&gt;</span> <span class="variable">$dr_dsn</span> <span class="operator">}</span><span class="operator">);</span>
  
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">'Active'</span><span class="operator">,</span> <span class="number">1</span> <span class="operator">);</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_connection</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$connection</span><span class="operator">;</span>
  
      <span class="keyword">return</span> <span class="variable">$outer</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>This is mostly the same as in the <i>driver handle constructor</i> above. The arguments are described in <a href="../../lib/DBI.html">DBI</a>.</p>

<p>The constructor <code><code>DBI::_new_dbh()</code></code> is called, returning a database handle. The constructor&#39;s prototype is:</p>

<pre><code><code>  <span class="operator">(</span><span class="variable">$outer</span><span class="operator">,</span> <span class="variable">$inner</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">DBI::_new_dbh</span><span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="variable">$public_attr</span><span class="operator">,</span> <span class="variable">$private_attr</span><span class="operator">);</span>
</code></code></pre>

<p>with similar arguments to those in the <i>driver handle constructor</i>, except that the <i>$class</i> is replaced by <i>$drh</i>. The <i>Name</i> attribute is a standard <b>DBI</b> attribute (see <a href="../../lib/DBI.html#Database-Handle-Attributes">&quot;Database Handle Attributes&quot; in DBI</a>).</p>

<p>In scalar context, only the outer handle is returned.</p>

<p>Note the use of the <code><code>STORE()</code></code> method for setting the <i>dbh</i> attributes. That&#39;s because within the driver code, the handle object you have is the &#39;inner&#39; handle of a tied hash, not the outer handle that the users of your driver have.</p>

<p>Because you have the inner handle, tie magic doesn&#39;t get invoked when you get or set values in the hash. This is often very handy for speed when you want to get or set simple non-special driver-specific attributes.</p>

<p>However, some attribute values, such as those handled by the <b>DBI</b> like <i>PrintError</i>, don&#39;t actually exist in the hash and must be read via <code><code>$h-&gt;FETCH($attrib)</code></code> and set via <code><code>$h-&gt;STORE($attrib, $value)</code></code>. If in any doubt, use these methods.</p>

<h4 id="The-data_sources-method">The data_sources() method</h4>

<p>The <code><code>data_sources()</code></code> method must populate and return a list of valid data sources, prefixed with the &quot;<i>dbi:Driver</i>&quot; incantation that allows them to be used in the first argument of the <code><code>DBI-&gt;connect()</code></code> method. An example of this might be scanning the <i>$HOME/.odbcini</i> file on Unix for ODBC data sources (DSNs).</p>

<p>As a trivial example, consider a fixed list of data sources:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> data_sources
  </span><span class="operator">{</span>
      <span class="keyword">my</span><span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">my</span><span class="operator">(</span><span class="variable">@list</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">();</span>
      <span class="comment"># You need more sophisticated code than this to set @list...</span>
      <span class="keyword">push</span> <span class="variable">@list</span><span class="operator">,</span> <span class="string">"dbi:Driver:abc"</span><span class="operator">;</span>
      <span class="keyword">push</span> <span class="variable">@list</span><span class="operator">,</span> <span class="string">"dbi:Driver:def"</span><span class="operator">;</span>
      <span class="keyword">push</span> <span class="variable">@list</span><span class="operator">,</span> <span class="string">"dbi:Driver:ghi"</span><span class="operator">;</span>
      <span class="comment"># End of code to set @list</span>
      <span class="keyword">return</span> <span class="variable">@list</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h4 id="The-disconnect_all-method">The disconnect_all() method</h4>

<p>If you need to release any resources when the driver is unloaded, you can provide a disconnect_all method.</p>

<h4 id="Other-driver-handle-methods">Other driver handle methods</h4>

<p>If you need any other driver handle methods, they can follow here.</p>

<h4 id="Error-handling">Error handling</h4>

<p>It is quite likely that something fails in the connect method. With <b>DBD::File</b> for example, you might catch an error when setting the current directory to something not existent by using the (driver-specific) <i>f_dir</i> attribute.</p>

<p>To report an error, you use the <code><code>set_err()</code></code> method:</p>

<pre><code><code>  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$err</span><span class="operator">,</span> <span class="variable">$errmsg</span><span class="operator">,</span> <span class="variable">$state</span><span class="operator">);</span>
</code></code></pre>

<p>This will ensure that the error is recorded correctly and that <i>RaiseError</i> and <i>PrintError</i> etc are handled correctly.</p>

<p>Typically you&#39;ll always use the method instance, aka your method&#39;s first argument.</p>

<p>As <code><code>set_err()</code></code> always returns <code><code>undef</code></code> your error handling code can usually be simplified to something like this:</p>

<pre><code><code>  <span class="keyword">return</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$err</span><span class="operator">,</span> <span class="variable">$errmsg</span><span class="operator">,</span> <span class="variable">$state</span><span class="operator">)</span> <span class="keyword">if</span> <span class="operator">...;</span>
</code></code></pre>

<h3 id="The-DBD::Driver::db-package">The DBD::Driver::db package</h3>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">DBD::Driver::db</span><span class="operator">;</span> <span class="comment"># ====== DATABASE ======</span>
  
  <span class="variable">$DBD::Driver::db::imp_data_size</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<h4 id="The-statement-handle-constructor">The statement handle constructor</h4>

<p>There&#39;s nothing much new in the statement handle constructor, which is the <code><code>prepare()</code></code> method:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> prepare
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$statement</span><span class="operator">,</span> <span class="variable">@attribs</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="comment"># create a 'blank' sth</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$outer</span><span class="operator">,</span> <span class="variable">$sth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">DBI::_new_sth</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">Statement</span> <span class="operator">=&gt;</span> <span class="variable">$statement</span> <span class="operator">}</span><span class="operator">);</span>
  
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">'NUM_OF_PARAMS'</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">$statement</span> <span class="operator">=~</span> <span class="regex">tr/?//</span><span class="operator">));</span>
  
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_params</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">[]</span><span class="operator">;</span>
  
      <span class="keyword">return</span> <span class="variable">$outer</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>This is still the same -- check the arguments and call the super class constructor <code><code>DBI::_new_sth()</code></code>. Again, in scalar context, only the outer handle is returned. The <i>Statement</i> attribute should be cached as shown.</p>

<p>Note the prefix <i>drv_</i> in the attribute names: it is required that all your private attributes use a lowercase prefix unique to your driver. As mentioned earlier in this document, the <b>DBI</b> contains a registry of known driver prefixes and may one day warn about unknown attributes that don&#39;t have a registered prefix.</p>

<p>Note that we parse the statement here in order to set the attribute <i>NUM_OF_PARAMS</i>. The technique illustrated is not very reliable; it can be confused by question marks appearing in quoted strings, delimited identifiers or in SQL comments that are part of the SQL statement. We could set <i>NUM_OF_PARAMS</i> in the <code><code>execute()</code></code> method instead because the <b>DBI</b> specification explicitly allows a driver to defer this, but then the user could not call <code><code>bind_param()</code></code>.</p>

<h4 id="Transaction-handling">Transaction handling</h4>

<p>Pure Perl drivers will rarely support transactions. Thus your <code><code>commit()</code></code> and <code><code>rollback()</code></code> methods will typically be quite simple:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> commit
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'Warn'</span><span class="operator">))</span> <span class="operator">{</span>
          <span class="keyword">warn</span><span class="operator">(</span><span class="string">"Commit ineffective while AutoCommit is on"</span><span class="operator">);</span>
      <span class="operator">}</span>
      <span class="number">0</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> rollback </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'Warn'</span><span class="operator">))</span> <span class="operator">{</span>
          <span class="keyword">warn</span><span class="operator">(</span><span class="string">"Rollback ineffective while AutoCommit is on"</span><span class="operator">);</span>
      <span class="operator">}</span>
      <span class="number">0</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Or even simpler, just use the default methods provided by the <b>DBI</b> that do nothing except return <code><code>undef</code></code>.</p>

<p>The <b>DBI</b>&#39;s default <code><code>begin_work()</code></code> method can be used by inheritance.</p>

<h4 id="The-STORE-and-FETCH-methods">The STORE() and FETCH() methods</h4>

<p>These methods (that we have already used, see above) are called for you, whenever the user does a:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$attr</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$val</span><span class="operator">;</span>
</code></code></pre>

<p>or, respectively,</p>

<pre><code><code>  <span class="variable">$val</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$attr</span><span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>See <a href="../../lib/pods/perltie.html">perltie</a> for details on tied hash refs to understand why these methods are required.</p>

<p>The <b>DBI</b> will handle most attributes for you, in particular attributes like <i>RaiseError</i> or <i>PrintError</i>. All you have to do is handle your driver&#39;s private attributes and any attributes, like <i>AutoCommit</i> and <i>ChopBlanks</i>, that the <b>DBI</b> can&#39;t handle for you.</p>

<p>A good example might look like this:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> STORE
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$val</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="keyword">eq</span> <span class="string">'AutoCommit'</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="comment"># AutoCommit is currently the only standard attribute we have</span>
          <span class="comment"># to consider.</span>
          <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">$val</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="string">"Can't disable AutoCommit"</span><span class="operator">;</span> <span class="operator">}</span>
          <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
      <span class="operator">}</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="operator">=~</span> <span class="regex">m/^drv_/</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="comment"># Handle only our private attributes here</span>
          <span class="comment"># Note that we could trigger arbitrary actions.</span>
          <span class="comment"># Ideally we should warn about unknown attributes.</span>
          <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$attr</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$val</span><span class="operator">;</span> <span class="comment"># Yes, we are allowed to do this,</span>
          <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>             <span class="comment"># but only for our private attributes</span>
      <span class="operator">}</span>
      <span class="comment"># Else pass up to DBI to handle for us</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">SUPER::STORE</span><span class="operator">(</span><span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$val</span><span class="operator">);</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> FETCH
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="keyword">eq</span> <span class="string">'AutoCommit'</span><span class="operator">)</span> <span class="operator">{</span> <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span> <span class="operator">}</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="operator">=~</span> <span class="regex">m/^drv_/</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="comment"># Handle only our private attributes here</span>
          <span class="comment"># Note that we could trigger arbitrary actions.</span>
          <span class="keyword">return</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$attr</span><span class="operator">}</span><span class="operator">;</span> <span class="comment"># Yes, we are allowed to do this,</span>
                                <span class="comment"># but only for our private attributes</span>
      <span class="operator">}</span>
      <span class="comment"># Else pass up to DBI to handle</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">SUPER::FETCH</span><span class="operator">(</span><span class="variable">$attr</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The <b>DBI</b> will actually store and fetch driver-specific attributes (with all lowercase names) without warning or error, so there&#39;s actually no need to implement driver-specific any code in your <code><code>FETCH()</code></code> and <code><code>STORE()</code></code> methods unless you need extra logic/checks, beyond getting or setting the value.</p>

<p>Unless your driver documentation indicates otherwise, the return value of the <code><code>STORE()</code></code> method is unspecified and the caller shouldn&#39;t use that value.</p>

<h4 id="Other-database-handle-methods">Other database handle methods</h4>

<p>As with the driver package, other database handle methods may follow here. In particular you should consider a (possibly empty) <code><code>disconnect()</code></code> method and possibly a <code><code>quote()</code></code> method if <b>DBI</b>&#39;s default isn&#39;t correct for you. You may also need the <code><code>type_info_all()</code></code> and <code><code>get_info()</code></code> methods, as described elsewhere in this document.</p>

<p>Where reasonable use <code><code>$h-&gt;SUPER::foo()</code></code> to call the <b>DBI</b>&#39;s method in some or all cases and just wrap your custom behavior around that.</p>

<p>If you want to use private trace flags you&#39;ll probably want to be able to set them by name. To do that you&#39;ll need to define a <code><code>parse_trace_flag()</code></code> method (note that&#39;s &quot;parse_trace_flag&quot;, singular, not &quot;parse_trace_flags&quot;, plural).</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> parse_trace_flag </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$h</span><span class="operator">,</span> <span class="variable">$name</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x01000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'foo'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x02000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'bar'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x04000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'baz'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x08000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'boo'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x10000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'bop'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">SUPER::parse_trace_flag</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>All private flag names must be lowercase, and all private flags must be in the top 8 of the 32 bits.</p>

<h3 id="The-DBD::Driver::st-package">The DBD::Driver::st package</h3>

<p>This package follows the same pattern the others do:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">DBD::Driver::st</span><span class="operator">;</span>
  
  <span class="variable">$DBD::Driver::st::imp_data_size</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<h4 id="The-execute-and-bind_param-methods">The execute() and bind_param() methods</h4>

<p>This is perhaps the most difficult method because we have to consider parameter bindings here. In addition to that, there are a number of statement attributes which must be set for inherited <b>DBI</b> methods to function correctly (see <a href="#Statement-attributes">&quot;Statement attributes&quot;</a> below).</p>

<p>We present a simplified implementation by using the <i>drv_params</i> attribute from above:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> bind_param
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$sth</span><span class="operator">,</span> <span class="variable">$pNum</span><span class="operator">,</span> <span class="variable">$val</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$type</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">ref</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">?</span> <span class="variable">$attr</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">TYPE</span><span class="operator">}</span> <span class="operator">:</span> <span class="variable">$attr</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$type</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Database</span><span class="operator">}</span><span class="operator">;</span>
          <span class="variable">$val</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">);</span>
      <span class="operator">}</span>
      <span class="keyword">my</span> <span class="variable">$params</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_params</span><span class="operator">}</span><span class="operator">;</span>
      <span class="variable">$params</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="variable">$pNum</span><span class="operator">-</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="variable">$val</span><span class="operator">;</span>
      <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> execute
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$sth</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="comment"># start of by finishing any previous execution if still active</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span> <span class="keyword">if</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'Active'</span><span class="operator">);</span>
  
      <span class="keyword">my</span> <span class="variable">$params</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">@bind_values</span><span class="operator">)</span> <span class="operator">?</span>
          <span class="operator">\</span><span class="variable">@bind_values</span> <span class="operator">:</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_params</span><span class="operator">}</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$numParam</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'NUM_OF_PARAMS'</span><span class="operator">);</span>
      <span class="keyword">return</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">set_err</span><span class="operator">(</span><span class="variable">$DBI::stderr</span><span class="operator">,</span> <span class="string">"Wrong number of parameters"</span><span class="operator">)</span>
          <span class="keyword">if</span> <span class="variable">@$params</span> <span class="operator">!=</span> <span class="variable">$numParam</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$statement</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'Statement'</span><span class="operator">}</span><span class="operator">;</span>
      <span class="keyword">for</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>  <span class="variable">$i</span> <span class="operator">&lt;</span> <span class="variable">$numParam</span><span class="operator">;</span>  <span class="variable">$i</span><span class="operator">++)</span> <span class="operator">{</span>
          <span class="variable">$statement</span> <span class="operator">=~</span> <span class="regex">s/?/$params-&gt;[$i]/</span><span class="operator">;</span> <span class="comment"># XXX doesn't deal with quoting etc!</span>
      <span class="operator">}</span>
      <span class="comment"># Do anything ... we assume that an array ref of rows is</span>
      <span class="comment"># created and store it:</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'drv_data'</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$data</span><span class="operator">;</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">'drv_rows'</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">@$data</span><span class="operator">;</span> <span class="comment"># number of rows</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">'NUM_OF_FIELDS'</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$numFields</span><span class="operator">;</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Active</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
      <span class="variable">@$data</span> <span class="operator">||</span> <span class="string">'0E0'</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>There are a number of things you should note here.</p>

<p>We initialize the <i>NUM_OF_FIELDS</i> and <i>Active</i> attributes here, because they are essential for <code><code>bind_columns()</code></code> to work.</p>

<p>We use attribute <code><code><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Statement</span><span class="operator">}</span>
</code></code> which we created within <code><code>prepare()</code></code>. The attribute <code><code><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Database</span><span class="operator">}</span>
</code></code>, which is nothing else than the <i>dbh</i>, was automatically created by <b>DBI</b>.</p>

<p>Finally, note that (as specified in the <b>DBI</b> specification) we return the string <code><code>&#39;0E0&#39;</code></code> instead of the number 0, so that the result tests true but equal to zero.</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</code></code></pre>

<h4 id="The-execute_array-execute_for_fetch-and-bind_param_array-methods">The execute_array(), execute_for_fetch() and bind_param_array() methods</h4>

<p>In general, DBD&#39;s only need to implement <code><code>execute_for_fetch()</code></code> and <code><code>bind_param_array</code></code>. DBI&#39;s default <code><code>execute_array()</code></code> will invoke the DBD&#39;s <code><code>execute_for_fetch()</code></code> as needed.</p>

<p>The following sequence describes the interaction between DBI <code><code>execute_array</code></code> and a DBD&#39;s <code><code>execute_for_fetch</code></code>:</p>

<ol>

<li><p>App calls <code><code>$sth-&gt;execute_array(\%attrs, @array_of_arrays)</code></code></p>

</li>
<li><p>If <code><code>@array_of_arrays</code></code> was specified, DBI processes <code><code>@array_of_arrays</code></code> by calling DBD&#39;s <code><code>bind_param_array()</code></code>. Alternately, App may have directly called <code><code>bind_param_array()</code></code></p>

</li>
<li><p>DBD validates and binds each array</p>

</li>
<li><p>DBI retrieves the validated param arrays from DBD&#39;s ParamArray attribute</p>

</li>
<li><p>DBI calls DBD&#39;s <code><code>execute_for_fetch($fetch_tuple_sub, \@tuple_status)</code></code>, where <code><code>&amp;$fetch_tuple_sub</code></code> is a closure to iterate over the returned ParamArray values, and <code><code>\@tuple_status</code></code> is an array to receive the disposition status of each tuple.</p>

</li>
<li><p>DBD iteratively calls <code><code>&amp;$fetch_tuple_sub</code></code> to retrieve parameter tuples to be added to its bulk database operation/request.</p>

</li>
<li><p>when DBD reaches the limit of tuples it can handle in a single database operation/request, or the <code><code>&amp;$fetch_tuple_sub</code></code> indicates no more tuples by returning undef, the DBD executes the bulk operation, and reports the disposition of each tuple in \@tuple_status.</p>

</li>
<li><p>DBD repeats steps 6 and 7 until all tuples are processed.</p>

</li>
</ol>

<p>E.g., here&#39;s the essence of <a href="../../lib/DBD/Oracle.html">DBD::Oracle</a>&#39;s execute_for_fetch:</p>

<pre><code><code>       <span class="keyword">while</span> <span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
           <span class="keyword">my</span> <span class="variable">@tuple_batch</span><span class="operator">;</span>
           <span class="keyword">for</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">$i</span> <span class="operator">&lt;</span> <span class="variable">$batch_size</span><span class="operator">;</span> <span class="variable">$i</span><span class="operator">++)</span> <span class="operator">{</span>
                <span class="keyword">push</span> <span class="variable">@tuple_batch</span><span class="operator">,</span> <span class="operator">[</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">$fetch_tuple_sub</span><span class="operator">-&gt;()</span> <span class="operator">||</span> <span class="keyword">last</span><span class="operator">}</span> <span class="operator">]</span><span class="operator">;</span>
           <span class="operator">}</span>
           <span class="keyword">last</span> <span class="keyword">unless</span> <span class="variable">@tuple_batch</span><span class="operator">;</span>
           <span class="keyword">my</span> <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">ora_execute_array</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_batch</span><span class="operator">,</span>
              <span class="keyword">scalar</span><span class="operator">(</span><span class="variable">@tuple_batch</span><span class="operator">),</span> <span class="variable">$tuple_batch_status</span><span class="operator">);</span>
           <span class="keyword">push</span> <span class="variable">@$tuple_status</span><span class="operator">,</span> <span class="variable">@$tuple_batch_status</span><span class="operator">;</span>
       <span class="operator">}</span>
</code></code></pre>

<p>Note that DBI&#39;s default execute_array()/execute_for_fetch() implementation requires the use of positional (i.e., &#39;?&#39;) placeholders. Drivers which <b>require</b> named placeholders must either emulate positional placeholders (e.g., see <a href="../../lib/DBD/Oracle.html">DBD::Oracle</a>), or must implement their own execute_array()/execute_for_fetch() methods to properly sequence bound parameter arrays.</p>

<h4 id="Fetching-data">Fetching data</h4>

<p>Only one method needs to be written for fetching data, <code><code>fetchrow_arrayref()</code></code>. The other methods, <code><code>fetchrow_array()</code></code>, <code><code>fetchall_arrayref()</code></code>, etc, as well as the database handle&#39;s <code><code>select*</code></code> methods are part of <b>DBI</b>, and call <code><code>fetchrow_arrayref()</code></code> as necessary.</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> fetchrow_arrayref
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$sth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_data</span><span class="operator">}</span><span class="operator">;</span>
      <span class="keyword">my</span> <span class="variable">$row</span> <span class="operator">=</span> <span class="keyword">shift</span> <span class="variable">@$data</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">$row</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">Active</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">);</span> <span class="comment"># mark as no longer active</span>
          <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
      <span class="operator">}</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'ChopBlanks'</span><span class="operator">))</span> <span class="operator">{</span>
          <span class="keyword">map</span> <span class="operator">{</span> <span class="variable">$_</span> <span class="operator">=~</span> <span class="regex">s/\s+$//</span><span class="operator">;</span> <span class="operator">}</span> <span class="variable">@$row</span><span class="operator">;</span>
      <span class="operator">}</span>
      <span class="keyword">return</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">_set_fbav</span><span class="operator">(</span><span class="variable">$row</span><span class="operator">);</span>
  <span class="operator">}</span>
  <span class="variable">*fetch</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">fetchrow_arrayref</span><span class="operator">;</span> <span class="comment"># required alias for fetchrow_arrayref</span>
</code></code></pre>

<p>Note the use of the method <code><code>_set_fbav()</code></code> -- this is required so that <code><code>bind_col()</code></code> and <code><code>bind_columns()</code></code> work.</p>

<p>If an error occurs which leaves the <i>$sth</i> in a state where remaining rows can&#39;t be fetched then <i>Active</i> should be turned off before the method returns.</p>

<p>The <code><code>rows()</code></code> method for this driver can be implemented like this:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> rows </span><span class="operator">{</span> <span class="keyword">shift</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">drv_rows</span><span class="operator">}</span> <span class="operator">}</span>
</code></code></pre>

<p>because it knows in advance how many rows it has fetched. Alternatively you could delete that method and so fallback to the <b>DBI</b>&#39;s own method which does the right thing based on the number of calls to <code><code>_set_fbav()</code></code>.</p>

<h4 id="The-more_results-method">The more_results method</h4>

<p>If your driver doesn&#39;t support multiple result sets, then don&#39;t even implement this method.</p>

<p>Otherwise, this method needs to get the statement handle ready to fetch results from the next result set, if there is one. Typically you&#39;d start with:</p>

<pre><code><code>    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">;</span>
</code></code></pre>

<p>then you should delete all the attributes from the attribute cache that may no longer be relevant for the new result set:</p>

<pre><code><code>    <span class="keyword">delete</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span>
        <span class="keyword">for</span> <span class="string">qw(NAME TYPE PRECISION SCALE ...)</span><span class="operator">;</span>
</code></code></pre>

<p>for drivers written in C use:</p>

<pre><code><code>    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"NAME"</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"NULLABLE"</span><span class="operator">,</span> <span class="number">8</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"NUM_OF_FIELDS"</span><span class="operator">,</span> <span class="number">13</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"PRECISION"</span><span class="operator">,</span> <span class="number">9</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"SCALE"</span><span class="operator">,</span> <span class="number">5</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
    <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">),</span> <span class="string">"TYPE"</span><span class="operator">,</span> <span class="number">4</span><span class="operator">,</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
</code></code></pre>

<p>Don&#39;t forget to also delete, or update, any driver-private attributes that may not be correct for the next resultset.</p>

<p>The NUM_OF_FIELDS attribute is a special case. It should be set using STORE:</p>

<pre><code><code>    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">NUM_OF_FIELDS</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">);</span> <span class="regex">/* for DBI &lt;= 1.53 */</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">NUM_OF_FIELDS</span> <span class="operator">=&gt;</span> <span class="variable">$new_value</span><span class="operator">);</span>
</code></code></pre>

<p>for drivers written in C use this incantation:</p>

<pre><code><code>    <span class="regex">/* Adjust NUM_OF_FIELDS - which also adjusts the row buffer size */</span>
    <span class="variable">DBIc_NUM_FIELDS</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">)</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="regex">/* for DBI &lt;= 1.53 */</span>
    <span class="variable">DBIc_STATE</span><span class="operator">(</span><span class="variable">imp_xxh</span><span class="operator">)-&gt;</span><span class="variable">set_attr_k</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">,</span> <span class="variable">sv_2mortal</span><span class="operator">(</span><span class="variable">newSVpvn</span><span class="operator">(</span><span class="string">"NUM_OF_FIELDS"</span><span class="operator">,</span><span class="number">13</span><span class="operator">)),</span> <span class="number">0</span><span class="operator">,</span>
        <span class="variable">sv_2mortal</span><span class="operator">(</span><span class="variable">newSViv</span><span class="operator">(</span><span class="variable">mysql_num_fields</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">-&gt;</span><span class="variable">result</span><span class="operator">)))</span>
    <span class="operator">);</span>
</code></code></pre>

<p>For DBI versions prior to 1.54 you&#39;ll also need to explicitly adjust the number of elements in the row buffer array (<code><code>DBIc_FIELDS_AV(imp_sth)</code></code>) to match the new result set. Fill any new values with newSV(0) not &amp;sv_undef. Alternatively you could free DBIc_FIELDS_AV(imp_sth) and set it to null, but that would mean bind_columns() wouldn&#39;t work across result sets.</p>

<h4 id="Statement-attributes">Statement attributes</h4>

<p>The main difference between <i>dbh</i> and <i>sth</i> attributes is, that you should implement a lot of attributes here that are required by the <b>DBI</b>, such as <i>NAME</i>, <i>NULLABLE</i>, <i>TYPE</i>, etc. See <a href="../../lib/DBI.html#Statement-Handle-Attributes">&quot;Statement Handle Attributes&quot; in DBI</a> for a complete list.</p>

<p>Pay attention to attributes which are marked as read only, such as <i>NUM_OF_PARAMS</i>. These attributes can only be set the first time a statement is executed. If a statement is prepared, then executed multiple times, warnings may be generated.</p>

<p>You can protect against these warnings, and prevent the recalculation of attributes which might be expensive to calculate (such as the <i>NAME</i> and <i>NAME_*</i> attributes):</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$storedNumParams</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'NUM_OF_PARAMS'</span><span class="operator">);</span>
    <span class="keyword">if</span> <span class="operator">(!</span><span class="keyword">defined</span> <span class="variable">$storedNumParams</span> <span class="keyword">or</span> <span class="variable">$storedNumFields</span> <span class="operator">&lt;</span> <span class="number">0</span><span class="operator">)</span> <span class="operator">{</span>
        <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="string">'NUM_OF_PARAMS'</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$numParams</span><span class="operator">;</span>
    
        <span class="comment"># Set other useful attributes that only need to be set once</span>
        <span class="comment"># for a statement, like $sth-&gt;{NAME} and $sth-&gt;{TYPE}</span>
    <span class="operator">}</span>
</code></code></pre>

<p>One particularly important attribute to set correctly (mentioned in <a href="../../lib/DBI.html#ATTRIBUTES-COMMON-TO-ALL-HANDLES">&quot;ATTRIBUTES COMMON TO ALL HANDLES&quot; in DBI</a> is <i>Active</i>. Many <b>DBI</b> methods, including <code><code>bind_columns()</code></code>, depend on this attribute.</p>

<p>Besides that the <code><code>STORE()</code></code> and <code><code>FETCH()</code></code> methods are mainly the same as above for <i>dbh</i>&#39;s.</p>

<h4 id="Other-statement-methods">Other statement methods</h4>

<p>A trivial <code><code>finish()</code></code> method to discard stored data, reset any attributes (such as <i>Active</i>) and do <code><code>$sth-&gt;SUPER::finish()</code></code>.</p>

<p>If you&#39;ve defined a <code><code>parse_trace_flag()</code></code> method in <b>::db</b> you&#39;ll also want it in <b>::st</b>, so just alias it in:</p>

<pre><code><code>  <span class="variable">*parse_trace_flag</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">DBD::foo</span><span class="operator">:</span><span class="variable">db::parse_trace_flag</span><span class="operator">;</span>
</code></code></pre>

<p>And perhaps some other methods that are not part of the <b>DBI</b> specification, in particular to make metadata available. Remember that they must have names that begin with your drivers registered prefix so they can be installed using <code><code>install_method()</code></code>.</p>

<p>If <code><code>DESTROY()</code></code> is called on a statement handle that&#39;s still active (<code><code><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Active</span><span class="operator">}</span>
</code></code> is true) then it should effectively call <code><code>finish()</code></code>.</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> DESTROY </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span> <span class="keyword">if</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">FETCH</span><span class="operator">(</span><span class="string">'Active'</span><span class="operator">);</span>
    <span class="operator">}</span>
</code></code></pre>

<h2 id="Tests">Tests</h2>

<p>The test process should conform as closely as possibly to the Perl standard test harness.</p>

<p>In particular, most (all) of the tests should be run in the <i>t</i> sub-directory, and should simply produce an <code><code>ok</code></code> when run under <code><code>make test</code></code>. For details on how this is done, see the Camel book and the section in Chapter 7, &quot;The Standard Perl Library&quot; on <a href="../../lib/Test/Harness.html">Test::Harness</a>.</p>

<p>The tests may need to adapt to the type of database which is being used for testing, and to the privileges of the user testing the driver. For example, the <b>DBD::Informix</b> test code has to adapt in a number of places to the type of database to which it is connected as different Informix databases have different capabilities: some of the tests are for databases without transaction logs; others are for databases with a transaction log; some versions of the server have support for blobs, or stored procedures, or user-defined data types, and others do not.</p>

<p>When a complete file of tests must be skipped, you can provide a reason in a pseudo-comment:</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$no_transactions_available</span><span class="operator">)</span>
    <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"1..0 # Skip: No transactions available\n"</span><span class="operator">;</span>
        <span class="keyword">exit</span> <span class="number">0</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Consider downloading the <b>DBD::Informix</b> code and look at the code in <i>DBD/Informix/TestHarness.pm</i> which is used throughout the <b>DBD::Informix</b> tests in the <i>t</i> sub-directory.</p>

<h1 id="CREATING-A-C-XS-DRIVER">CREATING A C/XS DRIVER</h1>

<p>Please also see the section under <a href="#CREATING-A-PURE-PERL-DRIVER">&quot;CREATING A PURE PERL DRIVER&quot;</a> regarding the creation of the <i>Makefile.PL</i>.</p>

<p>Creating a new C/XS driver from scratch will always be a daunting task. You can and should greatly simplify your task by taking a good reference driver implementation and modifying that to match the database product for which you are writing a driver.</p>

<p>The de facto reference driver has been the one for <b>DBD::Oracle</b> written by Tim Bunce, who is also the author of the <b>DBI</b> package. The <b>DBD::Oracle</b> module is a good example of a driver implemented around a C-level API.</p>

<p>Nowadays it it seems better to base on <b>DBD::ODBC</b>, another driver maintained by Tim and Jeff Urlwin, because it offers a lot of metadata and seems to become the guideline for the future development. (Also as <b>DBD::Oracle</b> digs deeper into the Oracle 8 OCI interface it&#39;ll get even more hairy than it is now.)</p>

<p>The <b>DBD::Informix</b> driver is one driver implemented using embedded SQL instead of a function-based API. <b>DBD::Ingres</b> may also be worth a look.</p>

<h2 id="C-XS-version-of-Driver.pm">C/XS version of Driver.pm</h2>

<p>A lot of the code in the <i>Driver.pm</i> file is very similar to the code for pure Perl modules - see above. However, there are also some subtle (and not so subtle) differences, including:</p>

<ul>

<li><p>The variables <i>$DBD::Driver::{dr|db|st}::imp_data_size</i> are not defined here, but in the XS code, because they declare the size of certain C structures.</p>

</li>
<li><p>Some methods are typically moved to the XS code, in particular <code><code>prepare()</code></code>, <code><code>execute()</code></code>, <code><code>disconnect()</code></code>, <code><code>disconnect_all()</code></code> and the <code><code>STORE()</code></code> and <code><code>FETCH()</code></code> methods.</p>

</li>
<li><p>Other methods are still part of <i>Driver.pm</i>, but have callbacks to the XS code.</p>

</li>
<li><p>If the driver-specific parts of the <i>imp_drh_t</i> structure need to be formally initialized (which does not seem to be a common requirement), then you need to add a call to an appropriate XS function in the driver method of <code><code>DBD::Driver::driver()</code></code>, and you define the corresponding function in <i>Driver.xs</i>, and you define the C code in <i>dbdimp.c</i> and the prototype in <i>dbdimp.h</i>.</p>

<p>For example, <b>DBD::Informix</b> has such a requirement, and adds the following call after the call to <code><code>_new_drh()</code></code> in <i>Informix.pm</i>:</p>

<pre><code><code>  <span class="variable">DBD::Informix::dr::driver_init</span><span class="operator">(</span><span class="variable">$drh</span><span class="operator">);</span>
</code></code></pre>

<p>and the following code in <i>Informix.xs</i>:</p>

<pre><code><code>  <span class="comment"># Initialize the DBD::Informix driver data structure</span>
  <span class="variable">void</span>
  <span class="variable">driver_init</span><span class="operator">(</span><span class="variable">drh</span><span class="operator">)</span>
      <span class="variable">SV</span> <span class="variable">*drh</span>
      <span class="variable">CODE</span><span class="operator">:</span>
      <span class="variable">ST</span><span class="operator">(</span><span class="number">0</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">dbd_ix_dr_driver_init</span><span class="operator">(</span><span class="variable">drh</span><span class="operator">)</span> <span class="operator">?</span> <span class="operator">&amp;</span><span class="variable">sv_yes</span> <span class="operator">:</span> <span class="operator">&amp;</span><span class="variable">sv_no</span><span class="operator">;</span>
</code></code></pre>

<p>and the code in <i>dbdimp.h</i> declares:</p>

<pre><code><code>  <span class="variable">extern</span> <span class="keyword">int</span> <span class="variable">dbd_ix_dr_driver_init</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*drh</span><span class="operator">);</span>
</code></code></pre>

<p>and the code in <i>dbdimp.ec</i> (equivalent to <i>dbdimp.c</i>) defines:</p>

<pre><code><code>  <span class="regex">/* Formally initialize the DBD::Informix driver structure */</span>
  <span class="keyword">int</span>
  <span class="variable">dbd_ix_dr_driver</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*drh</span><span class="operator">)</span>
  <span class="operator">{</span>
      <span class="variable">D_imp_drh</span><span class="operator">(</span><span class="variable">drh</span><span class="operator">);</span>
      <span class="variable">imp_drh</span><span class="operator">-&gt;</span><span class="variable">n_connections</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>       <span class="regex">/* No active connections */</span>
      <span class="variable">imp_drh</span><span class="operator">-&gt;</span><span class="variable">current_connection</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>  <span class="regex">/* No current connection */</span>
      <span class="variable">imp_drh</span><span class="operator">-&gt;</span><span class="variable">multipleconnections</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">ESQLC_VERSION</span> <span class="operator">&gt;=</span> <span class="number">600</span><span class="operator">)</span> <span class="operator">?</span> <span class="variable">True</span> <span class="operator">:</span> <span class="variable">False</span><span class="operator">;</span>
      <span class="variable">dbd_ix_link_newhead</span><span class="operator">(&amp;</span><span class="variable">imp_drh</span><span class="operator">-&gt;</span><span class="variable">head</span><span class="operator">);</span>  <span class="regex">/* Empty linked list of connections */</span>
      <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p><b>DBD::Oracle</b> has a similar requirement but gets around it by checking whether the private data part of the driver handle is all zeroed out, rather than add extra functions.</p>

</li>
</ul>

<p>Now let&#39;s take a closer look at an excerpt from <i>Oracle.pm</i> (revised heavily to remove idiosyncrasies) as an example, ignoring things that were already discussed for pure Perl drivers.</p>

<h3 id="The-connect-method">The connect method</h3>

<p>The connect method is the database handle constructor. You could write either of two versions of this method: either one which takes connection attributes (new code) and one which ignores them (old code only).</p>

<p>If you ignore the connection attributes, then you omit all mention of the <i>$auth</i> variable (which is a reference to a hash of attributes), and the XS system manages the differences for you.</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> connect
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="variable">$dbname</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="comment"># Some database specific verifications, default settings</span>
      <span class="comment"># and the like following here. This should only include</span>
      <span class="comment"># syntax checks or similar stuff where it's legal to</span>
      <span class="comment"># 'die' in case of errors.</span>
  
      <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI::_new_dbh</span><span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="operator">{</span>
              <span class="string">'Name'</span>   <span class="operator">=&gt;</span> <span class="variable">$dbname</span><span class="operator">,</span>
          <span class="operator">}</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
  
      <span class="comment"># Call the driver-specific function _login in Driver.xs file which</span>
      <span class="comment"># calls the DBMS-specific function(s) to connect to the database,</span>
      <span class="comment"># and populate internal handle data.</span>
      <span class="variable">DBD::Driver::db::_login</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$dbname</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
  
      <span class="variable">$dbh</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>This is mostly the same as in the pure Perl case, the exception being the use of the private <code><code>_login()</code></code> callback, which is the function that will really connect to the database. It is implemented in <i>Driver.xst</i> (you should not implement it) and calls <code><code>dbd_db_login6()</code></code> or <code><code>dbd_db_login6_sv</code></code> from <i>dbdimp.c</i>. See below for details.</p>

<p>If your driver has driver-specific attributes which may be passed in the connect method and hence end up in <code><code>$attr</code></code> in <code><code>dbd_db_login6</code></code> then it is best to delete any you process so DBI does not send them again via STORE after connect. You can do this in C like this:</p>

<pre><code><code>  <span class="variable">DBD_ATTRIB_DELETE</span><span class="operator">(</span><span class="variable">attr</span><span class="operator">,</span> <span class="string">"my_attribute_name"</span><span class="operator">,</span>
                    <span class="variable">strlen</span><span class="operator">(</span><span class="string">"my_attribute_name"</span><span class="operator">));</span>
</code></code></pre>

<p>However, prior to DBI subversion version 11605 (and fixed post 1.607) DBD_ATTRIB_DELETE segfaulted so if you cannot guarantee the DBI version will be post 1.607 you need to use:</p>

<pre><code><code>  <span class="variable">hv_delete</span><span class="operator">((</span><span class="variable">HV</span><span class="operator">*)</span><span class="variable">SvRV</span><span class="operator">(</span><span class="variable">attr</span><span class="operator">),</span> <span class="string">"my_attribute_name"</span><span class="operator">,</span>
                     <span class="variable">strlen</span><span class="operator">(</span><span class="string">"my_attribute_name"</span><span class="operator">),</span> <span class="variable">G_DISCARD</span><span class="operator">);</span>
  
   <span class="variable">*FIX</span> <span class="variable">ME</span><span class="operator">*</span> <span class="variable">Discuss</span> <span class="variable">removing</span> <span class="variable">attributes</span> <span class="variable">in</span> <span class="variable">Perl</span> <span class="variable">code</span><span class="operator">.</span>
</code></code></pre>

<h3 id="The-disconnect_all-method1">The disconnect_all method</h3>

<pre><code><code> *FIX ME* T.B.S</code></code></pre>

<h3 id="The-data_sources-method1">The data_sources method</h3>

<p>If your <code><code>data_sources()</code></code> method can be implemented in pure Perl, then do so because it is easier than doing it in XS code (see the section above for pure Perl drivers).</p>

<p>If your <code><code>data_sources()</code></code> method must call onto compiled functions, then you will need to define <i>dbd_dr_data_sources</i> in your <i>dbdimp.h</i> file, which will trigger <i>Driver.xst</i> (in <b>DBI</b> v1.33 or greater) to generate the XS code that calls your actual C function (see the discussion below for details) and you do not code anything in <i>Driver.pm</i> to handle it.</p>

<h3 id="The-prepare-method">The prepare method</h3>

<p>The prepare method is the statement handle constructor, and most of it is not new. Like the <code><code>connect()</code></code> method, it now has a C callback:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">DBD::Driver::db</span><span class="operator">;</span> <span class="comment"># ====== DATABASE ======</span>
  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  
  <span class="keyword">sub</span><span class="variable"> prepare
  </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$statement</span><span class="operator">,</span> <span class="variable">$attribs</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="comment"># create a 'blank' sth</span>
      <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">DBI::_new_sth</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="operator">{</span>
          <span class="string">'Statement'</span> <span class="operator">=&gt;</span> <span class="variable">$statement</span><span class="operator">,</span>
          <span class="operator">}</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
  
      <span class="comment"># Call the driver-specific function _prepare in Driver.xs file</span>
      <span class="comment"># which calls the DBMS-specific function(s) to prepare a statement</span>
      <span class="comment"># and populate internal handle data.</span>
      <span class="variable">DBD::Driver::st::_prepare</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">,</span> <span class="variable">$statement</span><span class="operator">,</span> <span class="variable">$attribs</span><span class="operator">)</span>
          <span class="keyword">or</span> <span class="keyword">return</span> <span class="keyword">undef</span><span class="operator">;</span>
      <span class="variable">$sth</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h3 id="The-execute-method">The execute method</h3>

<pre><code><code> *FIX ME* T.B.S</code></code></pre>

<h3 id="The-fetchrow_arrayref-method">The fetchrow_arrayref method</h3>

<pre><code><code> *FIX ME* T.B.S</code></code></pre>

<h3 id="Other-methods-">Other methods?</h3>

<pre><code><code> *FIX ME* T.B.S</code></code></pre>

<h2 id="Driver.xs">Driver.xs</h2>

<p><i>Driver.xs</i> should look something like this:</p>

<pre><code><code>  <span class="comment">#include "Driver.h"</span>
  
  <span class="variable">DBISTATE_DECLARE</span><span class="operator">;</span>
  
  <span class="variable">INCLUDE</span><span class="operator">:</span> <span class="variable">Driver</span><span class="operator">.</span><span class="variable">xsi</span>
  
  <span class="variable">MODULE</span> <span class="operator">=</span> <span class="variable">DBD::Driver</span>    <span class="variable">PACKAGE</span> <span class="operator">=</span> <span class="variable">DBD::Driver::dr</span>
  
  <span class="operator">/*</span> <span class="variable">Non</span><span class="operator">-</span><span class="variable">standard</span> <span class="variable">drh</span> <span class="variable">XS</span> <span class="variable">methods</span> <span class="variable">following</span> <span class="variable">here</span><span class="operator">,</span> <span class="keyword">if</span> <span class="variable">any</span><span class="operator">.</span>       <span class="operator">*</span><span class="regex">/
  /</span><span class="operator">*</span> <span class="variable">If</span> <span class="variable">none</span> <span class="operator">(</span><span class="variable">the</span> <span class="variable">usual</span> <span class="variable">case</span><span class="operator">),</span> <span class="variable">omit</span> <span class="variable">the</span> <span class="variable">MODULE</span> <span class="variable">line</span> <span class="variable">above</span> <span class="variable">too</span><span class="operator">.</span> <span class="operator">*</span><span class="regex">/
  
  MODULE = DBD::Driver    PACKAGE = DBD::Driver::db
  
  /</span><span class="operator">*</span> <span class="variable">Non</span><span class="operator">-</span><span class="variable">standard</span> <span class="variable">dbh</span> <span class="variable">XS</span> <span class="variable">methods</span> <span class="variable">following</span> <span class="variable">here</span><span class="operator">,</span> <span class="keyword">if</span> <span class="variable">any</span><span class="operator">.</span>       <span class="operator">*</span><span class="regex">/
  /</span><span class="operator">*</span> <span class="variable">Currently</span> <span class="variable">this</span> <span class="variable">includes</span> <span class="variable">things</span> <span class="variable">like</span> <span class="variable">_list_tables</span> <span class="variable">from</span>     <span class="operator">*/</span>
  <span class="regex">/* DBD::mSQL and DBD::mysql.                                 */</span>
  
  <span class="variable">MODULE</span> <span class="operator">=</span> <span class="variable">DBD::Driver</span>    <span class="variable">PACKAGE</span> <span class="operator">=</span> <span class="variable">DBD::Driver::st</span>
  
  <span class="operator">/*</span> <span class="variable">Non</span><span class="operator">-</span><span class="variable">standard</span> <span class="variable">sth</span> <span class="variable">XS</span> <span class="variable">methods</span> <span class="variable">following</span> <span class="variable">here</span><span class="operator">,</span> <span class="keyword">if</span> <span class="variable">any</span><span class="operator">.</span>       <span class="operator">*</span><span class="regex">/
  /</span><span class="operator">*</span> <span class="variable">In</span> <span class="variable">particular</span> <span class="variable">this</span> <span class="variable">includes</span> <span class="variable">things</span> <span class="variable">like</span> <span class="variable">_list_fields</span> <span class="variable">from</span> <span class="operator">*/</span>
  <span class="regex">/* DBD::mSQL and DBD::mysql for accessing metadata.          */</span>
</code></code></pre>

<p>Note especially the include of <i>Driver.xsi</i> here: <b>DBI</b> inserts stub functions for almost all private methods here which will typically do much work for you.</p>

<p>Wherever you really have to implement something, it will call a private function in <i>dbdimp.c</i>, and this is what you have to implement.</p>

<p>You need to set up an extra routine if your driver needs to export constants of its own, analogous to the SQL types available when you say:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
  
   <span class="variable">*FIX</span> <span class="variable">ME</span><span class="operator">*</span> <span class="variable">T</span><span class="operator">.</span><span class="variable">B</span><span class="operator">.</span><span class="variable">S</span>
</code></code></pre>

<h2 id="Driver.h">Driver.h</h2>

<p><i>Driver.h</i> is very simple and the operational contents should look like this:</p>

<pre><code><code>  <span class="comment">#ifndef DRIVER_H_INCLUDED</span>
  <span class="comment">#define DRIVER_H_INCLUDED</span>
  
  <span class="comment">#define NEED_DBIXS_VERSION 93    /* 93 for DBI versions 1.00 to 1.51+ */</span>
  <span class="comment">#define PERL_NO_GET_CONTEXT      /* if used require DBI 1.51+ */</span>
  
  <span class="comment">#include &lt;DBIXS.h&gt;      /* installed by the DBI module  */</span>
  
  <span class="comment">#include "dbdimp.h"</span>
  
  <span class="comment">#include "dbivport.h"   /* see below                    */</span>
  
  <span class="comment">#include &lt;dbd_xsh.h&gt;    /* installed by the DBI module  */</span>
  
  <span class="comment">#endif /* DRIVER_H_INCLUDED */</span>
</code></code></pre>

<p>The <i>DBIXS.h</i> header defines most of the interesting information that the writer of a driver needs.</p>

<p>The file <i>dbd_xsh.h</i> header provides prototype declarations for the C functions that you might decide to implement. Note that you should normally only define one of <code><code>dbd_db_login()</code></code>, <code><code>dbd_db_login6()</code></code> or <code><code>dbd_db_login6_sv</code></code> unless you are intent on supporting really old versions of <b>DBI</b> (prior to <b>DBI</b> 1.06) as well as modern versions. The only standard, <b>DBI</b>-mandated functions that you need write are those specified in the <i>dbd_xsh.h</i> header. You might also add extra driver-specific functions in <i>Driver.xs</i>.</p>

<p>The <i>dbivport.h</i> file should be <i>copied</i> from the latest <b>DBI</b> release into your distribution each time you modify your driver. Its job is to allow you to enhance your code to work with the latest <b>DBI</b> API while still allowing your driver to be compiled and used with older versions of the <b>DBI</b> (for example, when the <code><code>DBIh_SET_ERR_CHAR()</code></code> macro was added to <b>DBI</b> 1.41, an emulation of it was added to <i>dbivport.h</i>). This makes users happy and your life easier. Always read the notes in <i>dbivport.h</i> to check for any limitations in the emulation that you should be aware of.</p>

<p>With <b>DBI</b> v1.51 or better I recommend that the driver defines <i>PERL_NO_GET_CONTEXT</i> before <i>DBIXS.h</i> is included. This can significantly improve efficiency when running under a thread enabled perl. (Remember that the standard perl in most Linux distributions is built with threads enabled. So is ActiveState perl for Windows, and perl built for Apache mod_perl2.) If you do this there are some things to keep in mind:</p>

<ul>

<li><p>If <i>PERL_NO_GET_CONTEXT</i> is defined, then every function that calls the Perl API will need to start out with a <code><code><span class="variable">dTHX</span><span class="operator">;</span>
</code></code> declaration.</p>

</li>
<li><p>You&#39;ll know which functions need this, because the C compiler will complain that the undeclared identifier <code><code>my_perl</code></code> is used if <i>and only if</i> the perl you are using to develop and test your driver has threads enabled.</p>

</li>
<li><p>If you don&#39;t remember to test with a thread-enabled perl before making a release it&#39;s likely that you&#39;ll get failure reports from users who are.</p>

</li>
<li><p>For driver private functions it is possible to gain even more efficiency by replacing <code><code><span class="variable">dTHX</span><span class="operator">;</span>
</code></code> with <code><code>pTHX_</code></code> prepended to the parameter list and then <code><code>aTHX_</code></code> prepended to the argument list where the function is called.</p>

</li>
</ul>

<p>See <a href="../../lib/pods/perlguts.html#How-multiple-interpreters-and-concurrency-are-supported">&quot;How multiple interpreters and concurrency are supported&quot; in perlguts</a> for additional information about <i>PERL_NO_GET_CONTEXT</i>.</p>

<h2 id="Implementation-header-dbdimp.h">Implementation header dbdimp.h</h2>

<p>This header file has two jobs:</p>

<p>First it defines data structures for your private part of the handles.</p>

<p>Second it defines macros that rename the generic names like <code><code>dbd_db_login()</code></code> to database specific names like <code><code>ora_db_login()</code></code>. This avoids name clashes and enables use of different drivers when you work with a statically linked perl.</p>

<p>It also will have the important task of disabling XS methods that you don&#39;t want to implement.</p>

<p>Finally, the macros will also be used to select alternate implementations of some functions. For example, the <code><code>dbd_db_login()</code></code> function is not passed the attribute hash.</p>

<p>Since <b>DBI</b> v1.06, if a <code><code>dbd_db_login6()</code></code> macro is defined (for a function with 6 arguments), it will be used instead with the attribute hash passed as the sixth argument.</p>

<p>Since <b>DBI</b> post v1.607, if a <code><code>dbd_db_login6_sv()</code></code> macro is defined (for a function like dbd_db_login6 but with scalar pointers for the dbname, username and password), it will be used instead. This will allow your login6 function to see if there are any Unicode characters in the dbname.</p>

<p>People used to just pick Oracle&#39;s <i>dbdimp.c</i> and use the same names, structures and types. I strongly recommend against that. At first glance this saves time, but your implementation will be less readable. It was just hell when I had to separate <b>DBI</b> specific parts, Oracle specific parts, mSQL specific parts and mysql specific parts in <b>DBD::mysql</b>&#39;s <i>dbdimp.h</i> and <i>dbdimp.c</i>. (<b>DBD::mysql</b> was a port of <b>DBD::mSQL</b> which was based on <b>DBD::Oracle</b>.) [Seconded, based on the experience taking <b>DBD::Informix</b> apart, even though the version inherited in 1996 was only based on <b>DBD::Oracle</b>.]</p>

<p>This part of the driver is <i>your exclusive part</i>. Rewrite it from scratch, so it will be clean and short: in other words, a better piece of code. (Of course keep an eye on other people&#39;s work.)</p>

<pre><code><code>  <span class="variable">struct</span> <span class="variable">imp_drh_st</span> <span class="operator">{</span>
      <span class="variable">dbih_drc_t</span> <span class="variable">com</span><span class="operator">;</span>           <span class="regex">/* MUST be first element in structure   */</span>
      <span class="operator">/*</span> <span class="variable">Insert</span> <span class="variable">your</span> <span class="variable">driver</span> <span class="variable">handle</span> <span class="variable">attributes</span> <span class="variable">here</span> <span class="operator">*/</span>
  <span class="operator">};</span>
  
  <span class="variable">struct</span> <span class="variable">imp_dbh_st</span> <span class="operator">{</span>
      <span class="variable">dbih_dbc_t</span> <span class="variable">com</span><span class="operator">;</span>           <span class="regex">/* MUST be first element in structure   */</span>
      <span class="operator">/*</span> <span class="variable">Insert</span> <span class="variable">your</span> <span class="variable">database</span> <span class="variable">handle</span> <span class="variable">attributes</span> <span class="variable">here</span> <span class="operator">*/</span>
  <span class="operator">};</span>
  
  <span class="variable">struct</span> <span class="variable">imp_sth_st</span> <span class="operator">{</span>
      <span class="variable">dbih_stc_t</span> <span class="variable">com</span><span class="operator">;</span>           <span class="regex">/* MUST be first element in structure   */</span>
      <span class="operator">/*</span> <span class="variable">Insert</span> <span class="variable">your</span> <span class="variable">statement</span> <span class="variable">handle</span> <span class="variable">attributes</span> <span class="variable">here</span> <span class="operator">*/</span>
  <span class="operator">};</span>
  
  <span class="regex">/*  Rename functions for avoiding name clashes; prototypes are  */</span>
  <span class="operator">/*</span>  <span class="variable">in</span> <span class="variable">dbd_xsh</span><span class="operator">.</span><span class="variable">h</span>                                                <span class="operator">*/</span>
  <span class="comment">#define dbd_init            drv_dr_init</span>
  <span class="comment">#define dbd_db_login6_sv    drv_db_login_sv</span>
  <span class="comment">#define dbd_db_do           drv_db_do</span>
  <span class="operator">...</span> <span class="variable">many</span> <span class="variable">more</span> <span class="variable">here</span> <span class="operator">...</span>
</code></code></pre>

<p>These structures implement your private part of the handles.</p>

<p>You <i>have</i> to use the name <code><code><span class="variable">imp_dbh_</span><span class="operator">{</span><span class="variable">dr</span><span class="operator">|</span><span class="variable">db</span><span class="operator">|</span><span class="variable">st</span><span class="operator">}</span>
</code></code> and the first field <i>must</i> be of type <i>dbih_drc_t|_dbc_t|_stc_t</i> and <i>must</i> be called <code><code>com</code></code>.</p>

<p>You should never access these fields directly, except by using the <i>DBIc_xxx()</i> macros below.</p>

<h2 id="Implementation-source-dbdimp.c">Implementation source dbdimp.c</h2>

<p>Conventionally, <i>dbdimp.c</i> is the main implementation file (but <b>DBD::Informix</b> calls the file <i>dbdimp.ec</i>). This section includes a short note on each function that is used in the <i>Driver.xsi</i> template and thus <i>has</i> to be implemented.</p>

<p>Of course, you will probably also need to implement other support functions, which should usually be file static if they are placed in <i>dbdimp.c</i>. If they are placed in other files, you need to list those files in <i>Makefile.PL</i> (and <i>MANIFEST</i>) to handle them correctly.</p>

<p>It is wise to adhere to a namespace convention for your functions to avoid conflicts. For example, for a driver with prefix <i>drv_</i>, you might call externally visible functions <i>dbd_drv_xxxx</i>. You should also avoid non-constant global variables as much as possible to improve the support for threading.</p>

<p>Since Perl requires support for function prototypes (ANSI or ISO or Standard C), you should write your code using function prototypes too.</p>

<p>It is possible to use either the unmapped names such as <code><code>dbd_init()</code></code> or the mapped names such as <code><code>dbd_ix_dr_init()</code></code> in the <i>dbdimp.c</i> file. <b>DBD::Informix</b> uses the mapped names which makes it easier to identify where to look for linkage problems at runtime (which will report errors using the mapped names).</p>

<p>Most other drivers, and in particular <b>DBD::Oracle</b>, use the unmapped names in the source code which makes it a little easier to compare code between drivers and eases discussions on the <i>dbi-dev</i> mailing list. The majority of the code fragments here will use the unmapped names.</p>

<p>Ultimately, you should provide implementations for most of the functions listed in the <i>dbd_xsh.h</i> header. The exceptions are optional functions (such as <code><code>dbd_st_rows()</code></code>) and those functions with alternative signatures, such as <code><code>dbd_db_login6_sv</code></code>, <code><code>dbd_db_login6()</code></code> and <i>dbd_db_login()</i>. Then you should only implement one of the alternatives, and generally the newer one of the alternatives.</p>

<h3 id="The-dbd_init-method">The dbd_init method</h3>

<pre><code><code>  <span class="comment">#include "Driver.h"</span>
  
  <span class="variable">DBISTATE_DECLARE</span><span class="operator">;</span>
  
  <span class="variable">void</span> <span class="variable">dbd_init</span><span class="operator">(</span><span class="variable">dbistate_t</span><span class="operator">*</span> <span class="variable">dbistate</span><span class="operator">)</span>
  <span class="operator">{</span>
      <span class="variable">DBISTATE_INIT</span><span class="operator">;</span>  <span class="regex">/*  Initialize the DBI macros  */</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The <code><code>dbd_init()</code></code> function will be called when your driver is first loaded; the bootstrap command in <code><code>DBD::Driver::dr::driver()</code></code> triggers this, and the call is generated in the <i>BOOT</i> section of <i>Driver.xst</i>. These statements are needed to allow your driver to use the <b>DBI</b> macros. They will include your private header file <i>dbdimp.h</i> in turn. Note that <i>DBISTATE_INIT</i> requires the name of the argument to <code><code>dbd_init()</code></code> to be called <code><code>dbistate()</code></code>.</p>

<h3 id="The-dbd_drv_error-method">The dbd_drv_error method</h3>

<p>You need a function to record errors so <b>DBI</b> can access them properly. You can call it whatever you like, but we&#39;ll call it <code><code>dbd_drv_error()</code></code> here.</p>

<p>The argument list depends on your database software; different systems provide different ways to get at error information.</p>

<pre><code><code>  <span class="variable">static</span> <span class="variable">void</span> <span class="variable">dbd_drv_error</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*h</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">rc</span><span class="operator">,</span> <span class="variable">const</span> <span class="variable">char</span> <span class="variable">*what</span><span class="operator">)</span>
  <span class="operator">{</span>
</code></code></pre>

<p>Note that <i>h</i> is a generic handle, may it be a driver handle, a database or a statement handle.</p>

<pre><code><code>      <span class="variable">D_imp_xxh</span><span class="operator">(</span><span class="variable">h</span><span class="operator">);</span>
</code></code></pre>

<p>This macro will declare and initialize a variable <i>imp_xxh</i> with a pointer to your private handle pointer. You may cast this to to <i>imp_drh_t</i>, <i>imp_dbh_t</i> or <i>imp_sth_t</i>.</p>

<p>To record the error correctly, equivalent to the <code><code>set_err()</code></code> method, use one of the <code><code>DBIh_SET_ERR_CHAR(...)</code></code> or <code><code>DBIh_SET_ERR_SV(...)</code></code> macros, which were added in <b>DBI</b> 1.41:</p>

<pre><code><code>  <span class="variable">DBIh_SET_ERR_SV</span><span class="operator">(</span><span class="variable">h</span><span class="operator">,</span> <span class="variable">imp_xxh</span><span class="operator">,</span> <span class="variable">err</span><span class="operator">,</span> <span class="variable">errstr</span><span class="operator">,</span> <span class="keyword">state</span><span class="operator">,</span> <span class="variable">method</span><span class="operator">);</span>
  <span class="variable">DBIh_SET_ERR_CHAR</span><span class="operator">(</span><span class="variable">h</span><span class="operator">,</span> <span class="variable">imp_xxh</span><span class="operator">,</span> <span class="variable">err_c</span><span class="operator">,</span> <span class="variable">err_i</span><span class="operator">,</span> <span class="variable">errstr</span><span class="operator">,</span> <span class="keyword">state</span><span class="operator">,</span> <span class="variable">method</span><span class="operator">);</span>
</code></code></pre>

<p>For <code><code>DBIh_SET_ERR_SV</code></code> the <i>err</i>, <i>errstr</i>, <i>state</i>, and <i>method</i> parameters are <code><code>SV*</code></code> (use &amp;sv_undef instead of NULL).</p>

<p>For <code><code>DBIh_SET_ERR_CHAR</code></code> the <i>err_c</i>, <i>errstr</i>, <i>state</i>, <i>method</i> parameters are <code><code>char*</code></code>.</p>

<p>The <i>err_i</i> parameter is an <code><code>IV</code></code> that&#39;s used instead of <i>err_c</i> if <i>err_c</i> is <code><code>Null</code></code>.</p>

<p>The <i>method</i> parameter can be ignored.</p>

<p>The <code><code>DBIh_SET_ERR_CHAR</code></code> macro is usually the simplest to use when you just have an integer error code and an error message string:</p>

<pre><code><code>  <span class="variable">DBIh_SET_ERR_CHAR</span><span class="operator">(</span><span class="variable">h</span><span class="operator">,</span> <span class="variable">imp_xxh</span><span class="operator">,</span> <span class="variable">Nullch</span><span class="operator">,</span> <span class="variable">rc</span><span class="operator">,</span> <span class="variable">what</span><span class="operator">,</span> <span class="variable">Nullch</span><span class="operator">,</span> <span class="variable">Nullch</span><span class="operator">);</span>
</code></code></pre>

<p>As you can see, any parameters that aren&#39;t relevant to you can be <code><code>Null</code></code>.</p>

<p>To make drivers compatible with <b>DBI</b> &lt; 1.41 you should be using <i>dbivport.h</i> as described in <a href="#Driver.h">&quot;Driver.h&quot;</a> above.</p>

<p>The (obsolete) macros such as <code><code>DBIh_EVENT2</code></code> should be removed from drivers.</p>

<p>The names <code><code>dbis</code></code> and <code><code>DBIS</code></code>, which were used in previous versions of this document, should be replaced with the <code><code>DBIc_DBISTATE(imp_xxh)</code></code> macro.</p>

<p>The name <code><code>DBILOGFP</code></code>, which was also used in previous versions of this document, should be replaced by <code><code>DBIc_LOGPIO(imp_xxh)</code></code>.</p>

<p>Your code should not call the C <code><code>&lt;stdio.h&gt;</code></code> I/O functions; you should use <code><code>PerlIO_printf()</code></code> as shown:</p>

<pre><code><code>      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">DBIc_TRACE_LEVEL</span><span class="operator">(</span><span class="variable">imp_xxh</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="number">2</span><span class="operator">)</span>
          <span class="variable">PerlIO_printf</span><span class="operator">(</span><span class="variable">DBIc_LOGPIO</span><span class="operator">(</span><span class="variable">imp_xxh</span><span class="operator">),</span> <span class="string">"foobar %s: %s\n"</span><span class="operator">,</span>
              <span class="variable">foo</span><span class="operator">,</span> <span class="variable">neatsvpv</span><span class="operator">(</span><span class="variable">errstr</span><span class="operator">,</span><span class="number">0</span><span class="operator">));</span>
</code></code></pre>

<p>That&#39;s the first time we see how tracing works within a <b>DBI</b> driver. Make use of this as often as you can, but don&#39;t output anything at a trace level less than 3. Levels 1 and 2 are reserved for the <b>DBI</b>.</p>

<p>You can define up to 8 private trace flags using the top 8 bits of <code><code>DBIc_TRACE_FLAGS(imp)</code></code>, that is: <code><code>0xFF000000</code></code>. See the <code><code>parse_trace_flag()</code></code> method elsewhere in this document.</p>

<h3 id="The-dbd_dr_data_sources-method">The dbd_dr_data_sources method</h3>

<p>This method is optional; the support for it was added in <b>DBI</b> v1.33.</p>

<p>As noted in the discussion of <i>Driver.pm</i>, if the data sources can be determined by pure Perl code, do it that way. If, as in <b>DBD::Informix</b>, the information is obtained by a C function call, then you need to define a function that matches the prototype:</p>

<pre><code><code>  <span class="variable">extern</span> <span class="variable">AV</span> <span class="variable">*dbd_dr_data_sources</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*drh</span><span class="operator">,</span> <span class="variable">imp_drh_t</span> <span class="variable">*imp_drh</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*attrs</span><span class="operator">);</span>
</code></code></pre>

<p>An outline implementation for <b>DBD::Informix</b> follows, assuming that the <code><code>sqgetdbs()</code></code> function call shown will return up to 100 databases names, with the pointers to each name in the array dbsname and the name strings themselves being stores in dbsarea.</p>

<pre><code><code>  <span class="variable">AV</span> <span class="variable">*dbd_dr_data_sources</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*drh</span><span class="operator">,</span> <span class="variable">imp_drh_t</span> <span class="variable">*imp_drh</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*attr</span><span class="operator">)</span>
  <span class="operator">{</span>
      <span class="keyword">int</span> <span class="variable">ndbs</span><span class="operator">;</span>
      <span class="keyword">int</span> <span class="variable">i</span><span class="operator">;</span>
      <span class="variable">char</span> <span class="variable">*dbsname</span><span class="operator">[</span><span class="number">100</span><span class="operator">]</span><span class="operator">;</span>
      <span class="variable">char</span>  <span class="variable">dbsarea</span><span class="operator">[</span><span class="number">10000</span><span class="operator">]</span><span class="operator">;</span>
      <span class="variable">AV</span> <span class="variable">*av</span> <span class="operator">=</span> <span class="variable">Nullav</span><span class="operator">;</span>
  
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">sqgetdbs</span><span class="operator">(&amp;</span><span class="variable">ndbs</span><span class="operator">,</span> <span class="variable">dbsname</span><span class="operator">,</span> <span class="number">100</span><span class="operator">,</span> <span class="variable">dbsarea</span><span class="operator">,</span> <span class="variable">sizeof</span><span class="operator">(</span><span class="variable">dbsarea</span><span class="operator">))</span> <span class="operator">==</span> <span class="number">0</span><span class="operator">)</span>
      <span class="operator">{</span>
          <span class="variable">av</span> <span class="operator">=</span> <span class="variable">NewAV</span><span class="operator">();</span>
          <span class="variable">av_extend</span><span class="operator">(</span><span class="variable">av</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">I32</span><span class="operator">)</span><span class="variable">ndbs</span><span class="operator">);</span>
          <span class="variable">sv_2mortal</span><span class="operator">((</span><span class="variable">SV</span> <span class="operator">*)</span><span class="variable">av</span><span class="operator">);</span>
          <span class="keyword">for</span> <span class="operator">(</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">ndbs</span><span class="operator">;</span> <span class="variable">i</span><span class="operator">++)</span>
            <span class="variable">av_store</span><span class="operator">(</span><span class="variable">av</span><span class="operator">,</span> <span class="variable">i</span><span class="operator">,</span> <span class="variable">newSVpvf</span><span class="operator">(</span><span class="string">"dbi:Informix:%s"</span><span class="operator">,</span> <span class="variable">dbsname</span><span class="operator">[</span><span class="variable">i</span><span class="operator">]</span><span class="operator">));</span>
      <span class="operator">}</span>
      <span class="keyword">return</span><span class="operator">(</span><span class="variable">av</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The actual <b>DBD::Informix</b> implementation has a number of extra lines of code, logs function entry and exit, reports the error from <code><code>sqgetdbs()</code></code>, and uses <code><code><span class="comment">#define</span>
</code></code>&#39;d constants for the array sizes.</p>

<h3 id="The-dbd_db_login6-method">The dbd_db_login6 method</h3>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_db_login6_sv</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbname</span><span class="operator">,</span>
                       <span class="variable">SV</span><span class="operator">*</span> <span class="variable">user</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">auth</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*attr</span><span class="operator">);</span>
  
  <span class="keyword">or</span>
  
  <span class="keyword">int</span> <span class="variable">dbd_db_login6</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">dbname</span><span class="operator">,</span>
                   <span class="variable">char</span><span class="operator">*</span> <span class="variable">user</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">auth</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*attr</span><span class="operator">);</span>
</code></code></pre>

<p>This function will really connect to the database. The argument <i>dbh</i> is the database handle. <i>imp_dbh</i> is the pointer to the handles private data, as is <i>imp_xxx</i> in <code><code>dbd_drv_error()</code></code> above. The arguments <i>dbname</i>, <i>user</i>, <i>auth</i> and <i>attr</i> correspond to the arguments of the driver handle&#39;s <code><code>connect()</code></code> method.</p>

<p>You will quite often use database specific attributes here, that are specified in the DSN. I recommend you parse the DSN (using Perl) within the <code><code>connect()</code></code> method and pass the segments of the DSN via the attributes parameter through <code><code>_login()</code></code> to <code><code>dbd_db_login6()</code></code>.</p>

<p>Here&#39;s how you fetch them; as an example we use <i>hostname</i> attribute, which can be up to 12 characters long excluding null terminator:</p>

<pre><code><code>  <span class="variable">SV</span><span class="operator">**</span> <span class="variable">svp</span><span class="operator">;</span>
  <span class="variable">STRLEN</span> <span class="variable">len</span><span class="operator">;</span>
  <span class="variable">char</span><span class="operator">*</span> <span class="variable">hostname</span><span class="operator">;</span>
  
  <span class="keyword">if</span> <span class="operator">(</span> <span class="operator">(</span><span class="variable">svp</span> <span class="operator">=</span> <span class="variable">DBD_ATTRIB_GET_SVP</span><span class="operator">(</span><span class="variable">attr</span><span class="operator">,</span> <span class="string">"drv_hostname"</span><span class="operator">,</span> <span class="number">12</span><span class="operator">))</span> <span class="operator">&amp;&amp;</span> <span class="variable">SvTRUE</span><span class="operator">(</span><span class="variable">*svp</span><span class="operator">))</span> <span class="operator">{</span>
      <span class="variable">hostname</span> <span class="operator">=</span> <span class="variable">SvPV</span><span class="operator">(</span><span class="variable">*svp</span><span class="operator">,</span> <span class="variable">len</span><span class="operator">);</span>
      <span class="variable">DBD_ATTRIB_DELETE</span><span class="operator">(</span><span class="variable">attr</span><span class="operator">,</span> <span class="string">"drv_hostname"</span><span class="operator">,</span> <span class="number">12</span><span class="operator">);</span> <span class="regex">/* avoid later STORE */</span>
  <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
      <span class="variable">hostname</span> <span class="operator">=</span> <span class="string">"localhost"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>If you handle any driver specific attributes in the dbd_db_login6 method you probably want to delete them from <code><code>attr</code></code> (as above with DBD_ATTRIB_DELETE). If you don&#39;t delete your handled attributes DBI will call <code><code>STORE</code></code> for each attribute after the connect/login and this is at best redundant for attributes you have already processed.</p>

<p><b>Note: Until revision 11605 (post DBI 1.607), there was a problem with DBD_ATTRIBUTE_DELETE so unless you require a DBI version after 1.607 you need to replace each DBD_ATTRIBUTE_DELETE call with:</b></p>

<pre><code><code>  hv_delete((HV*)SvRV(attr), key, key_len, G_DISCARD)</code></code></pre>

<p>Note that you can also obtain standard attributes such as <i>AutoCommit</i> and <i>ChopBlanks</i> from the attributes parameter, using <code><code>DBD_ATTRIB_GET_IV</code></code> for integer attributes.</p>

<p>If, for example, your database does not support transactions but <i>AutoCommit</i> is set off (requesting transaction support), then you can emulate a &#39;failure to connect&#39;.</p>

<p>Now you should really connect to the database. In general, if the connection fails, it is best to ensure that all allocated resources are released so that the handle does not need to be destroyed separately. If you are successful (and possibly even if you fail but you have allocated some resources), you should use the following macros:</p>

<pre><code><code>  <span class="variable">DBIc_IMPSET_on</span><span class="operator">(</span><span class="variable">imp_dbh</span><span class="operator">);</span>
</code></code></pre>

<p>This indicates that the driver (implementor) has allocated resources in the <i>imp_dbh</i> structure and that the implementors private <code><code>dbd_db_destroy()</code></code> function should be called when the handle is destroyed.</p>

<pre><code><code>  <span class="variable">DBIc_ACTIVE_on</span><span class="operator">(</span><span class="variable">imp_dbh</span><span class="operator">);</span>
</code></code></pre>

<p>This indicates that the handle has an active connection to the server and that the <code><code>dbd_db_disconnect()</code></code> function should be called before the handle is destroyed.</p>

<p>Note that if you do need to fail, you should report errors via the <i>drh</i> or <i>imp_drh</i> rather than via <i>dbh</i> or <i>imp_dbh</i> because <i>imp_dbh</i> will be destroyed by the failure, so errors recorded in that handle will not be visible to <b>DBI</b>, and hence not the user either.</p>

<p>Note too, that the function is passed <i>dbh</i> and <i>imp_dbh</i>, and there is a macro <code><code>D_imp_drh_from_dbh</code></code> which can recover the <i>imp_drh</i> from the <i>imp_dbh</i>. However, there is no <b>DBI</b> macro to provide you with the <i>drh</i> given either the <i>imp_dbh</i> or the <i>dbh</i> or the <i>imp_drh</i> (and there&#39;s no way to recover the <i>dbh</i> given just the <i>imp_dbh</i>).</p>

<p>This suggests that, despite the above notes about <code><code>dbd_drv_error()</code></code> taking an <code><code>SV *</code></code>, it may be better to have two error routines, one taking <i>imp_dbh</i> and one taking <i>imp_drh</i> instead. With care, you can factor most of the formatting code out so that these are small routines calling a common error formatter. See the code in <b>DBD::Informix</b> 1.05.00 for more information.</p>

<p>The <code><code>dbd_db_login6()</code></code> function should return <i>TRUE</i> for success, <i>FALSE</i> otherwise.</p>

<p>Drivers implemented long ago may define the five-argument function <code><code>dbd_db_login()</code></code> instead of <code><code>dbd_db_login6()</code></code>. The missing argument is the attributes. There are ways to work around the missing attributes, but they are ungainly; it is much better to use the 6-argument form. Even later drivers will use <code><code>dbd_db_login6_sv()</code></code> which provides the dbname, username and password as SVs.</p>

<h3 id="The-dbd_db_commit-and-dbd_db_rollback-methods">The dbd_db_commit and dbd_db_rollback methods</h3>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_db_commit</span><span class="operator">(</span><span class="variable">SV</span> <span class="variable">*dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span> <span class="variable">*imp_dbh</span><span class="operator">);</span>
  <span class="keyword">int</span> <span class="variable">dbd_db_rollback</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">);</span>
</code></code></pre>

<p>These are used for commit and rollback. They should return <i>TRUE</i> for success, <i>FALSE</i> for error.</p>

<p>The arguments <i>dbh</i> and <i>imp_dbh</i> are the same as for <code><code>dbd_db_login6()</code></code> above; I will omit describing them in what follows, as they appear always.</p>

<p>These functions should return <i>TRUE</i> for success, <i>FALSE</i> otherwise.</p>

<h3 id="The-dbd_db_disconnect-method">The dbd_db_disconnect method</h3>

<p>This is your private part of the <code><code>disconnect()</code></code> method. Any <i>dbh</i> with the <i>ACTIVE</i> flag on must be disconnected. (Note that you have to set it in <code><code>dbd_db_connect()</code></code> above.)</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_db_disconnect</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">);</span>
</code></code></pre>

<p>The database handle will return <i>TRUE</i> for success, <i>FALSE</i> otherwise. In any case it should do a:</p>

<pre><code><code>  <span class="variable">DBIc_ACTIVE_off</span><span class="operator">(</span><span class="variable">imp_dbh</span><span class="operator">);</span>
</code></code></pre>

<p>before returning so <b>DBI</b> knows that <code><code>dbd_db_disconnect()</code></code> was executed.</p>

<p>Note that there&#39;s nothing to stop a <i>dbh</i> being <i>disconnected</i> while it still have active children. If your database API reacts badly to trying to use an <i>sth</i> in this situation then you&#39;ll need to add code like this to all <i>sth</i> methods:</p>

<pre><code><code>  <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">DBIc_ACTIVE</span><span class="operator">(</span><span class="variable">DBIc_PARENT_COM</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">)))</span>
    <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<p>Alternatively, you can add code to your driver to keep explicit track of the statement handles that exist for each database handle and arrange to destroy those handles before disconnecting from the database. There is code to do this in <b>DBD::Informix</b>. Similar comments apply to the driver handle keeping track of all the database handles.</p>

<p>Note that the code which destroys the subordinate handles should only release the associated database resources and mark the handles inactive; it does not attempt to free the actual handle structures.</p>

<p>This function should return <i>TRUE</i> for success, <i>FALSE</i> otherwise, but it is not clear what anything can do about a failure.</p>

<h3 id="The-dbd_db_discon_all-method">The dbd_db_discon_all method</h3>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_discon_all</span> <span class="operator">(</span><span class="variable">SV</span> <span class="variable">*drh</span><span class="operator">,</span> <span class="variable">imp_drh_t</span> <span class="variable">*imp_drh</span><span class="operator">);</span>
</code></code></pre>

<p>This function may be called at shutdown time. It should make best-efforts to disconnect all database handles - if possible. Some databases don&#39;t support that, in which case you can do nothing but return &#39;success&#39;.</p>

<p>This function should return <i>TRUE</i> for success, <i>FALSE</i> otherwise, but it is not clear what anything can do about a failure.</p>

<h3 id="The-dbd_db_destroy-method">The dbd_db_destroy method</h3>

<p>This is your private part of the database handle destructor. Any <i>dbh</i> with the <i>IMPSET</i> flag on must be destroyed, so that you can safely free resources. (Note that you have to set it in <code><code>dbd_db_connect()</code></code> above.)</p>

<pre><code><code>  <span class="variable">void</span> <span class="variable">dbd_db_destroy</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">)</span>
  <span class="operator">{</span>
      <span class="variable">DBIc_IMPSET_off</span><span class="operator">(</span><span class="variable">imp_dbh</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The <b>DBI</b> <i>Driver.xst</i> code will have called <code><code>dbd_db_disconnect()</code></code> for you, if the handle is still &#39;active&#39;, before calling <code><code>dbd_db_destroy()</code></code>.</p>

<p>Before returning the function must switch <i>IMPSET</i> to off, so <b>DBI</b> knows that the destructor was called.</p>

<p>A <b>DBI</b> handle doesn&#39;t keep references to its children. But children do keep references to their parents. So a database handle won&#39;t be <code><code>DESTROY</code></code>&#39;d until all its children have been <code><code>DESTROY</code></code>&#39;d.</p>

<h3 id="The-dbd_db_STORE_attrib-method">The dbd_db_STORE_attrib method</h3>

<p>This function handles</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$key</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$value</span><span class="operator">;</span>
</code></code></pre>

<p>Its prototype is:</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_db_STORE_attrib</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">keysv</span><span class="operator">,</span>
                          <span class="variable">SV</span><span class="operator">*</span> <span class="variable">valuesv</span><span class="operator">);</span>
</code></code></pre>

<p>You do not handle all attributes; on the contrary, you should not handle <b>DBI</b> attributes here: leave this to <b>DBI</b>. (There are two exceptions, <i>AutoCommit</i> and <i>ChopBlanks</i>, which you should care about.)</p>

<p>The return value is <i>TRUE</i> if you have handled the attribute or <i>FALSE</i> otherwise. If you are handling an attribute and something fails, you should call <code><code>dbd_drv_error()</code></code>, so <b>DBI</b> can raise exceptions, if desired. If <code><code>dbd_drv_error()</code></code> returns, however, you have a problem: the user will never know about the error, because he typically will not check <code><code>$dbh-&gt;errstr()</code></code>.</p>

<p>I cannot recommend a general way of going on, if <code><code>dbd_drv_error()</code></code> returns, but there are examples where even the <b>DBI</b> specification expects that you <code><code>croak()</code></code>. (See the <i>AutoCommit</i> method in <a href="../../lib/DBI.html">DBI</a>.)</p>

<p>If you have to store attributes, you should either use your private data structure <i>imp_xxx</i>, the handle hash (via <code><code>(HV*)SvRV(dbh)</code></code>), or use the private <i>imp_data</i>.</p>

<p>The first is best for internal C values like integers or pointers and where speed is important within the driver. The handle hash is best for values the user may want to get/set via driver-specific attributes. The private <i>imp_data</i> is an additional <code><code>SV</code></code> attached to the handle. You could think of it as an unnamed handle attribute. It&#39;s not normally used.</p>

<h3 id="The-dbd_db_FETCH_attrib-method">The dbd_db_FETCH_attrib method</h3>

<p>This is the counterpart of <code><code>dbd_db_STORE_attrib()</code></code>, needed for:</p>

<pre><code><code>  <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$key</span><span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>Its prototype is:</p>

<pre><code><code>  <span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbd_db_FETCH_attrib</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbh</span><span class="operator">,</span> <span class="variable">imp_dbh_t</span><span class="operator">*</span> <span class="variable">imp_dbh</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">keysv</span><span class="operator">);</span>
</code></code></pre>

<p>Unlike all previous methods this returns an <code><code>SV</code></code> with the value. Note that you should normally execute <code><code>sv_2mortal()</code></code>, if you return a nonconstant value. (Constant values are <code><code>&amp;sv_undef</code></code>, <code><code>&amp;sv_no</code></code> and <code><code>&amp;sv_yes</code></code>.)</p>

<p>Note, that <b>DBI</b> implements a caching algorithm for attribute values. If you think, that an attribute may be fetched, you store it in the <i>dbh</i> itself:</p>

<pre><code><code>  if (cacheit) /* cache value for later DBI &#39;quick&#39; fetch? */
      hv_store((HV*)SvRV(dbh), key, kl, cachesv, 0);</code></code></pre>

<h3 id="The-dbd_st_prepare-method">The dbd_st_prepare method</h3>

<p>This is the private part of the <code><code>prepare()</code></code> method. Note that you <b>must not</b> really execute the statement here. You may, however, preparse and validate the statement, or do similar things.</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_st_prepare</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">,</span> <span class="variable">char</span><span class="operator">*</span> <span class="variable">statement</span><span class="operator">,</span>
                     <span class="variable">SV</span><span class="operator">*</span> <span class="variable">attribs</span><span class="operator">);</span>
</code></code></pre>

<p>A typical, simple, possibility is to do nothing and rely on the perl <code><code>prepare()</code></code> code that set the <i>Statement</i> attribute on the handle. This attribute can then be used by <code><code>dbd_st_execute()</code></code>.</p>

<p>If the driver supports placeholders then the <i>NUM_OF_PARAMS</i> attribute must be set correctly by <code><code>dbd_st_prepare()</code></code>:</p>

<pre><code><code>  DBIc_NUM_PARAMS(imp_sth) = ...</code></code></pre>

<p>If you can, you should also setup attributes like <i>NUM_OF_FIELDS</i>, <i>NAME</i>, etc. here, but <b>DBI</b> doesn&#39;t require that - they can be deferred until execute() is called. However, if you do, document it.</p>

<p>In any case you should set the <i>IMPSET</i> flag, as you did in <code><code>dbd_db_connect()</code></code> above:</p>

<pre><code><code>  <span class="variable">DBIc_IMPSET_on</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span>
</code></code></pre>

<h3 id="The-dbd_st_execute-method">The dbd_st_execute method</h3>

<p>This is where a statement will really be executed.</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_st_execute</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>dbd_st_execute</code></code> should return -2 for any error, -1 if the number of rows affected is unknown else it should be the number of affected (updated, inserted) rows.</p>

<p>Note that you must be aware a statement may be executed repeatedly. Also, you should not expect that <code><code>finish()</code></code> will be called between two executions, so you might need code, like the following, near the start of the function:</p>

<pre><code><code>  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">DBIc_ACTIVE</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">))</span>
      <span class="variable">dbd_st_finish</span><span class="operator">(</span><span class="variable">h</span><span class="operator">,</span> <span class="variable">imp_sth</span><span class="operator">);</span>
</code></code></pre>

<p>If your driver supports the binding of parameters (it should!), but the database doesn&#39;t, you must do it here. This can be done as follows:</p>

<pre><code><code>  <span class="variable">SV</span> <span class="variable">*svp</span><span class="operator">;</span>
  <span class="variable">char</span><span class="operator">*</span> <span class="variable">statement</span> <span class="operator">=</span> <span class="variable">DBD_ATTRIB_GET_PV</span><span class="operator">(</span><span class="variable">h</span><span class="operator">,</span> <span class="string">"Statement"</span><span class="operator">,</span> <span class="number">9</span><span class="operator">,</span> <span class="variable">svp</span><span class="operator">,</span> <span class="string">""</span><span class="operator">);</span>
  <span class="keyword">int</span> <span class="variable">numParam</span> <span class="operator">=</span> <span class="variable">DBIc_NUM_PARAMS</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span>
  <span class="keyword">int</span> <span class="variable">i</span><span class="operator">;</span>
  
  <span class="keyword">for</span> <span class="operator">(</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">numParam</span><span class="operator">;</span> <span class="variable">i</span><span class="operator">++)</span>
  <span class="operator">{</span>
      <span class="variable">char</span><span class="operator">*</span> <span class="variable">value</span> <span class="operator">=</span> <span class="variable">dbd_db_get_param</span><span class="operator">(</span><span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth</span><span class="operator">,</span> <span class="variable">i</span><span class="operator">);</span>
      <span class="regex">/* It is your drivers task to implement dbd_db_get_param,    */</span>
      <span class="operator">/*</span> <span class="variable">it</span> <span class="variable">must</span> <span class="variable">be</span> <span class="variable">setup</span> <span class="variable">as</span> <span class="variable">a</span> <span class="variable">counterpart</span> <span class="variable">of</span> <span class="variable">dbd_bind_ph</span><span class="operator">.</span>         <span class="operator">*</span><span class="regex">/
      /</span><span class="operator">*</span> <span class="variable">Look</span> <span class="keyword">for</span> <span class="string">'?'</span> <span class="keyword">and</span> <span class="variable">replace</span> <span class="variable">it</span> <span class="variable">with</span> <span class="string">'value'</span><span class="operator">.</span>  <span class="variable">Difficult</span>      <span class="operator">*/</span>
      <span class="regex">/* task, note that you may have question marks inside        */</span>
      <span class="operator">/*</span> <span class="variable">quotes</span> <span class="keyword">and</span> <span class="variable">comments</span> <span class="variable">the</span> <span class="variable">like</span> <span class="operator">...</span>  <span class="operator">:-(</span>                     <span class="operator">*</span><span class="regex">/
      /</span><span class="operator">*</span> <span class="variable">See</span> <span class="variable">DBD::mysql</span> <span class="keyword">for</span> <span class="variable">an</span> <span class="variable">example</span><span class="operator">.</span> <span class="operator">(</span><span class="variable">Don't</span> <span class="variable">look</span> <span class="variable">too</span> <span class="variable">deep</span> <span class="variable">into</span>  <span class="operator">*/</span>
      <span class="regex">/* the example, you will notice where I was lazy ...)        */</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The next thing is to really execute the statement.</p>

<p>Note that you must set the attributes <i>NUM_OF_FIELDS</i>, <i>NAME</i>, etc when the statement is successfully executed if the driver has not already done so: they may be used even before a potential <code><code>fetchrow()</code></code>. In particular you have to tell <b>DBI</b> the number of fields that the statement has, because it will be used by <b>DBI</b> internally. Thus the function will typically ends with:</p>

<pre><code><code>  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">isSelectStatement</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">DBIc_NUM_FIELDS</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">numFields</span><span class="operator">;</span>
      <span class="variable">DBIc_ACTIVE_on</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>It is important that the <i>ACTIVE</i> flag only be set for <code><code>SELECT</code></code> statements (or any other statements that can return many values from the database using a cursor-like mechanism). See <code><code>dbd_db_connect()</code></code> above for more explanations.</p>

<p>There plans for a preparse function to be provided by <b>DBI</b>, but this has not reached fruition yet. Meantime, if you want to know how ugly it can get, try looking at the <code><code>dbd_ix_preparse()</code></code> in <b>DBD::Informix</b> <i>dbdimp.ec</i> and the related functions in <i>iustoken.c</i> and <i>sqltoken.c</i>.</p>

<h3 id="The-dbd_st_fetch-method">The dbd_st_fetch method</h3>

<p>This function fetches a row of data. The row is stored in in an array, of <code><code>SV</code></code>&#39;s that <b>DBI</b> prepares for you. This has two advantages: it is fast (you even reuse the <code><code>SV</code></code>&#39;s, so they don&#39;t have to be created after the first <code><code>fetchrow()</code></code>), and it guarantees that <b>DBI</b> handles <code><code>bind_cols()</code></code> for you.</p>

<p>What you do is the following:</p>

<pre><code><code>  <span class="variable">AV</span><span class="operator">*</span> <span class="variable">av</span><span class="operator">;</span>
  <span class="keyword">int</span> <span class="variable">numFields</span> <span class="operator">=</span> <span class="variable">DBIc_NUM_FIELDS</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span> <span class="regex">/* Correct, if NUM_FIELDS
      is constant for this statement. There are drivers where this is
      not the case! */</span>
  <span class="keyword">int</span> <span class="variable">chopBlanks</span> <span class="operator">=</span> <span class="variable">DBIc_is</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">,</span> <span class="variable">DBIcf_ChopBlanks</span><span class="operator">);</span>
  <span class="keyword">int</span> <span class="variable">i</span><span class="operator">;</span>
  
  <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">fetch_new_row_of_data</span><span class="operator">(...))</span> <span class="operator">{</span>
      <span class="operator">...</span> <span class="regex">/* check for error or end-of-data */</span>
      <span class="variable">DBIc_ACTIVE_off</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span> <span class="regex">/* turn off Active flag automatically */</span>
      <span class="keyword">return</span> <span class="variable">Nullav</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="regex">/* get the fbav (field buffer array value) for this row       */</span>
  <span class="operator">/*</span> <span class="variable">it</span> <span class="variable">is</span> <span class="variable">very</span> <span class="variable">important</span> <span class="variable">to</span> <span class="variable">only</span> <span class="variable">call</span> <span class="variable">this</span> <span class="variable">after</span> <span class="variable">you</span> <span class="variable">know</span>      <span class="operator">*/</span>
  <span class="regex">/* that you have a row of data to return.                     */</span>
  <span class="variable">av</span> <span class="operator">=</span> <span class="variable">DBIc_DBISTATE</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">)-&gt;</span><span class="variable">get_fbav</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span> <span class="variable">i</span> <span class="operator">&lt;</span> <span class="variable">numFields</span><span class="operator">;</span> <span class="variable">i</span><span class="operator">++)</span> <span class="operator">{</span>
      <span class="variable">SV</span><span class="operator">*</span> <span class="variable">sv</span> <span class="operator">=</span> <span class="variable">fetch_a_field</span><span class="operator">(...,</span> <span class="variable">i</span><span class="operator">);</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">chopBlanks</span> <span class="operator">&amp;&amp;</span> <span class="variable">SvOK</span><span class="operator">(</span><span class="variable">sv</span><span class="operator">)</span> <span class="operator">&amp;&amp;</span> <span class="variable">type_is_blank_padded</span><span class="operator">(</span><span class="variable">field_type</span><span class="operator">[</span><span class="variable">i</span><span class="operator">]</span><span class="operator">))</span> <span class="operator">{</span>
          <span class="regex">/*  Remove white space from end (only) of sv  */</span>
      <span class="operator">}</span>
      <span class="variable">sv_setsv</span><span class="operator">(</span><span class="variable">AvARRAY</span><span class="operator">(</span><span class="variable">av</span><span class="operator">)</span><span class="operator">[</span><span class="variable">i</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">sv</span><span class="operator">);</span> <span class="regex">/* Note: (re)use! */</span>
  <span class="operator">}</span>
  <span class="keyword">return</span> <span class="variable">av</span><span class="operator">;</span>
</code></code></pre>

<p>There&#39;s no need to use a <code><code>fetch_a_field()</code></code> function returning an <code><code>SV*</code></code>. It&#39;s more common to use your database API functions to fetch the data as character strings and use code like this:</p>

<pre><code><code>  <span class="variable">sv_setpvn</span><span class="operator">(</span><span class="variable">AvARRAY</span><span class="operator">(</span><span class="variable">av</span><span class="operator">)</span><span class="operator">[</span><span class="variable">i</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">char_ptr</span><span class="operator">,</span> <span class="variable">char_count</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>NULL</code></code> values must be returned as <code><code>undef</code></code>. You can use code like this:</p>

<pre><code><code>  <span class="variable">SvOK_off</span><span class="operator">(</span><span class="variable">AvARRAY</span><span class="operator">(</span><span class="variable">av</span><span class="operator">)</span><span class="operator">[</span><span class="variable">i</span><span class="operator">]</span><span class="operator">);</span>
</code></code></pre>

<p>The function returns the <code><code>AV</code></code> prepared by <b>DBI</b> for success or <code><code>Nullav</code></code> otherwise.</p>

<pre><code><code> *FIX ME* Discuss what happens when there&#39;s no more data to fetch.
 Are errors permitted if another fetch occurs after the first fetch
 that reports no more data. (Permitted, not required.)</code></code></pre>

<p>If an error occurs which leaves the <i>$sth</i> in a state where remaining rows can&#39;t be fetched then <i>Active</i> should be turned off before the method returns.</p>

<h3 id="The-dbd_st_finish3-method">The dbd_st_finish3 method</h3>

<p>The <code><code>$sth-&gt;finish()</code></code> method can be called if the user wishes to indicate that no more rows will be fetched even if the database has more rows to offer, and the <b>DBI</b> code can call the function when handles are being destroyed. See the <b>DBI</b> specification for more background details.</p>

<p>In both circumstances, the <b>DBI</b> code ends up calling the <code><code>dbd_st_finish3()</code></code> method (if you provide a mapping for <code><code>dbd_st_finish3()</code></code> in <i>dbdimp.h</i>), or <code><code>dbd_st_finish()</code></code> otherwise. The difference is that <code><code>dbd_st_finish3()</code></code> takes a third argument which is an <code><code>int</code></code> with the value 1 if it is being called from a <code><code>destroy()</code></code> method and 0 otherwise.</p>

<p>Note that <b>DBI</b> v1.32 and earlier test on <code><code>dbd_db_finish3()</code></code> to call <code><code>dbd_st_finish3()</code></code>; if you provide <code><code>dbd_st_finish3()</code></code>, either define <code><code>dbd_db_finish3()</code></code> too, or insist on <b>DBI</b> v1.33 or later.</p>

<p>All it <i>needs</i> to do is turn off the <i>Active</i> flag for the <i>sth</i>. It will only be called by <i>Driver.xst</i> code, if the driver has set <i>ACTIVE</i> to on for the <i>sth</i>.</p>

<p>Outline example:</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_st_finish3</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">,</span> <span class="keyword">int</span> <span class="variable">from_destroy</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">DBIc_ACTIVE</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">))</span>
      <span class="operator">{</span>
          <span class="regex">/* close cursor or equivalent action */</span>
          <span class="variable">DBIc_ACTIVE_off</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span>
      <span class="operator">}</span>
      <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The from_destroy parameter is true if <code><code>dbd_st_finish3()</code></code> is being called from <code><code>DESTROY()</code></code> - and so the statement is about to be destroyed. For many drivers there is no point in doing anything more than turning off the <i>Active</i> flag in this case.</p>

<p>The function returns <i>TRUE</i> for success, <i>FALSE</i> otherwise, but there isn&#39;t a lot anyone can do to recover if there is an error.</p>

<h3 id="The-dbd_st_destroy-method">The dbd_st_destroy method</h3>

<p>This function is the private part of the statement handle destructor.</p>

<pre><code><code>  <span class="variable">void</span> <span class="variable">dbd_st_destroy</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="operator">...</span> <span class="regex">/* any clean-up that's needed */</span>
      <span class="variable">DBIc_IMPSET_off</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">);</span> <span class="regex">/* let DBI know we've done it   */</span>
  <span class="operator">}</span>
</code></code></pre>

<p>The <b>DBI</b> <i>Driver.xst</i> code will call <code><code>dbd_st_finish()</code></code> for you, if the <i>sth</i> has the <i>ACTIVE</i> flag set, before calling <code><code>dbd_st_destroy()</code></code>.</p>

<h3 id="The-dbd_st_STORE_attrib-and-dbd_st_FETCH_attrib-methods">The dbd_st_STORE_attrib and dbd_st_FETCH_attrib methods</h3>

<p>These functions correspond to <code><code>dbd_db_STORE()</code></code> and <code><code>dbd_db_FETCH()</code></code> attrib above, except that they are for statement handles. See above.</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_st_STORE_attrib</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">keysv</span><span class="operator">,</span>
                          <span class="variable">SV</span><span class="operator">*</span> <span class="variable">valuesv</span><span class="operator">);</span>
  <span class="variable">SV</span><span class="operator">*</span> <span class="variable">dbd_st_FETCH_attrib</span><span class="operator">(</span><span class="variable">SV</span><span class="operator">*</span> <span class="variable">sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span><span class="operator">*</span> <span class="variable">imp_sth</span><span class="operator">,</span> <span class="variable">SV</span><span class="operator">*</span> <span class="variable">keysv</span><span class="operator">);</span>
</code></code></pre>

<h3 id="The-dbd_bind_ph-method">The dbd_bind_ph method</h3>

<p>This function is internally used by the <code><code>bind_param()</code></code> method, the <code><code>bind_param_inout()</code></code> method and by the <b>DBI</b> <i>Driver.xst</i> code if <code><code>execute()</code></code> is called with any bind parameters.</p>

<pre><code><code>  <span class="keyword">int</span> <span class="variable">dbd_bind_ph</span> <span class="operator">(</span><span class="variable">SV</span> <span class="variable">*sth</span><span class="operator">,</span> <span class="variable">imp_sth_t</span> <span class="variable">*imp_sth</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*param</span><span class="operator">,</span>
                   <span class="variable">SV</span> <span class="variable">*value</span><span class="operator">,</span> <span class="variable">IV</span> <span class="variable">sql_type</span><span class="operator">,</span> <span class="variable">SV</span> <span class="variable">*attribs</span><span class="operator">,</span>
                   <span class="keyword">int</span> <span class="variable">is_inout</span><span class="operator">,</span> <span class="variable">IV</span> <span class="variable">maxlen</span><span class="operator">);</span>
</code></code></pre>

<p>The <i>param</i> argument holds an <code><code>IV</code></code> with the parameter number (1, 2, ...). The <i>value</i> argument is the parameter value and <i>sql_type</i> is its type.</p>

<p>If your driver does not support <code><code>bind_param_inout()</code></code> then you should ignore <i>maxlen</i> and croak if <i>is_inout</i> is <i>TRUE</i>.</p>

<p>If your driver <i>does</i> support <code><code>bind_param_inout()</code></code> then you should note that <i>value</i> is the <code><code>SV</code></code> <i>after</i> dereferencing the reference passed to <code><code>bind_param_inout()</code></code>.</p>

<p>In drivers of simple databases the function will, for example, store the value in a parameter array and use it later in <code><code>dbd_st_execute()</code></code>. See the <b>DBD::mysql</b> driver for an example.</p>

<h3 id="Implementing-bind_param_inout-support">Implementing bind_param_inout support</h3>

<p>To provide support for parameters bound by reference rather than by value, the driver must do a number of things. First, and most importantly, it must note the references and stash them in its own driver structure. Secondly, when a value is bound to a column, the driver must discard any previous reference bound to the column. On each execute, the driver must evaluate the references and internally bind the values resulting from the references. This is only applicable if the user writes:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</code></code></pre>

<p>If the user writes:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">@values</span><span class="operator">);</span>
</code></code></pre>

<p>then <b>DBI</b> automatically calls the binding code for each element of <i>@values</i>. These calls are indistinguishable from explicit user calls to <code><code>bind_param()</code></code>.</p>

<h2 id="C-XS-version-of-Makefile.PL">C/XS version of Makefile.PL</h2>

<p>The <i>Makefile.PL</i> file for a C/XS driver is similar to the code needed for a pure Perl driver, but there are a number of extra bits of information needed by the build system.</p>

<p>For example, the attributes list passed to <code><code>WriteMakefile()</code></code> needs to specify the object files that need to be compiled and built into the shared object (DLL). This is often, but not necessarily, just <i>dbdimp.o</i> (unless that should be <i>dbdimp.obj</i> because you&#39;re building on MS Windows).</p>

<p>Note that you can reliably determine the extension of the object files from the <i>$Config{obj_ext}</i> values, and there are many other useful pieces of configuration information lurking in that hash. You get access to it with:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">Config</span><span class="operator">;</span>
</code></code></pre>

<h2 id="Methods-which-do-not-need-to-be-written">Methods which do not need to be written</h2>

<p>The <b>DBI</b> code implements the majority of the methods which are accessed using the notation <code><code>DBI-&gt;function()</code></code>, the only exceptions being <code><code>DBI-&gt;connect()</code></code> and <code><code>DBI-&gt;data_sources()</code></code> which require support from the driver.</p>

<p>The <b>DBI</b> code implements the following documented driver, database and statement functions which do not need to be written by the <b>DBD</b> driver writer.</p>

<dl>

<dt id="dbh-do-">$dbh-&gt;do()</dt>
<dd>

<p>The default implementation of this function prepares, executes and destroys the statement. This can be replaced if there is a better way to implement this, such as <code><code>EXECUTE IMMEDIATE</code></code> which can sometimes be used if there are no parameters.</p>

</dd>
<dt id="h-errstr-">$h-&gt;errstr()</dt>
<dd>

</dd>
<dt id="h-err-">$h-&gt;err()</dt>
<dd>

</dd>
<dt id="h-state-">$h-&gt;state()</dt>
<dd>

</dd>
<dt id="h-trace-">$h-&gt;trace()</dt>
<dd>

<p>The <b>DBD</b> driver does not need to worry about these routines at all.</p>

</dd>
<dt id="h--ChopBlanks-">$h-&gt;{ChopBlanks}</dt>
<dd>

<p>This attribute needs to be honored during <code><code>fetch()</code></code> operations, but does not need to be handled by the attribute handling code.</p>

</dd>
<dt id="h--RaiseError-">$h-&gt;{RaiseError}</dt>
<dd>

<p>The <b>DBD</b> driver does not need to worry about this attribute at all.</p>

</dd>
<dt id="h--PrintError-">$h-&gt;{PrintError}</dt>
<dd>

<p>The <b>DBD</b> driver does not need to worry about this attribute at all.</p>

</dd>
<dt id="sth-bind_col-">$sth-&gt;bind_col()</dt>
<dd>

<p>Assuming the driver uses the <code><code>DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()</code></code> function (C drivers, see below), or the <code><code>$sth-&gt;_set_fbav($data)</code></code> method (Perl drivers) the driver does not need to do anything about this routine.</p>

</dd>
<dt id="sth-bind_columns-">$sth-&gt;bind_columns()</dt>
<dd>

<p>Regardless of whether the driver uses <code><code>DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()</code></code>, the driver does not need to do anything about this routine as it simply iteratively calls <code><code>$sth-&gt;bind_col()</code></code>.</p>

</dd>
</dl>

<p>The <b>DBI</b> code implements a default implementation of the following functions which do not need to be written by the <b>DBD</b> driver writer unless the default implementation is incorrect for the Driver.</p>

<dl>

<dt id="dbh-quote-">$dbh-&gt;quote()</dt>
<dd>

<p>This should only be written if the database does not accept the ANSI SQL standard for quoting strings, with the string enclosed in single quotes and any embedded single quotes replaced by two consecutive single quotes.</p>

<p>For the two argument form of quote, you need to implement the <code><code>type_info()</code></code> method to provide the information that quote needs.</p>

</dd>
<dt id="dbh-ping-">$dbh-&gt;ping()</dt>
<dd>

<p>This should be implemented as a simple efficient way to determine whether the connection to the database is still alive. Typically code like this:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> ping </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
      <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare_cached</span><span class="operator">(</span><span class="string">q{
          select * from A_TABLE_NAME where 1=0
      }</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span> <span class="keyword">or</span> <span class="keyword">return</span> <span class="number">0</span><span class="operator">;</span>
      <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>where <i>A_TABLE_NAME</i> is the name of a table that always exists (such as a database system catalogue).</p>

</dd>
<dt id="drh-default_user">$drh-&gt;default_user</dt>
<dd>

<p>The default implementation of default_user will get the database username and password fields from <code><code><span class="variable">$ENV</span><span class="operator">{</span><span class="string">DBI_USER</span><span class="operator">}</span>
</code></code> and <code><code><span class="variable">$ENV</span><span class="operator">{</span><span class="string">DBI_PASS</span><span class="operator">}</span>
</code></code>. You can override this method. It is called as follows:</p>

<pre><code><code>  ($user, $pass) = $drh-&gt;default_user($user, $pass, $attr)</code></code></pre>

</dd>
</dl>

<h1 id="METADATA-METHODS">METADATA METHODS</h1>

<p>The exposition above ignores the <b>DBI</b> MetaData methods. The metadata methods are all associated with a database handle.</p>

<h2 id="Using-DBI::DBD::Metadata">Using DBI::DBD::Metadata</h2>

<p>The <b>DBI::DBD::Metadata</b> module is a good semi-automatic way for the developer of a <b>DBD</b> module to write the <code><code>get_info()</code></code> and <code><code>type_info()</code></code> functions quickly and accurately.</p>

<h3 id="Generating-the-get_info-method">Generating the get_info method</h3>

<p>Prior to <b>DBI</b> v1.33, this existed as the method <code><code>write_getinfo_pm()</code></code> in the <b>DBI::DBD</b> module. From <b>DBI</b> v1.33, it exists as the method <code><code>write_getinfo_pm()</code></code> in the <b>DBI::DBD::Metadata</b> module. This discussion assumes you have <b>DBI</b> v1.33 or later.</p>

<p>You examine the documentation for <code><code>write_getinfo_pm()</code></code> using:</p>

<pre><code><code>    perldoc DBI::DBD::Metadata</code></code></pre>

<p>To use it, you need a Perl <b>DBI</b> driver for your database which implements the <code><code>get_info()</code></code> method. In practice, this means you need to install <b>DBD::ODBC</b>, an ODBC driver manager, and an ODBC driver for your database.</p>

<p>With the pre-requisites in place, you might type:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MDBI::DBD::Metadata</span> <span class="operator">-</span><span class="variable">we</span> <span class="operator">\</span>
       <span class="string">"write_getinfo_pm (qw{ dbi:ODBC:foo_db username password Driver })"</span>
</code></code></pre>

<p>The procedure writes to standard output the code that should be added to your <i>Driver.pm</i> file and the code that should be written to <i>lib/DBD/Driver/GetInfo.pm</i>.</p>

<p>You should review the output to ensure that it is sensible.</p>

<h3 id="Generating-the-type_info-method">Generating the type_info method</h3>

<p>Given the idea of the <code><code>write_getinfo_pm()</code></code> method, it was not hard to devise a parallel method, <code><code>write_typeinfo_pm()</code></code>, which does the analogous job for the <b>DBI</b> <code><code>type_info_all()</code></code> metadata method. The <code><code>write_typeinfo_pm()</code></code> method was added to <b>DBI</b> v1.33.</p>

<p>You examine the documentation for <code><code>write_typeinfo_pm()</code></code> using:</p>

<pre><code><code>    perldoc DBI::DBD::Metadata</code></code></pre>

<p>The setup is exactly analogous to the mechanism described in <a href="#Generating-the-get_info-method">&quot;Generating the get_info method&quot;</a>.</p>

<p>With the pre-requisites in place, you might type:</p>

<pre><code><code>    <span class="variable">perl</span> <span class="operator">-</span><span class="variable">MDBI::DBD::Metadata</span> <span class="operator">-</span><span class="variable">we</span> <span class="operator">\</span>
       <span class="string">"write_typeinfo (qw{ dbi:ODBC:foo_db username password Driver })"</span>
</code></code></pre>

<p>The procedure writes to standard output the code that should be added to your <i>Driver.pm</i> file and the code that should be written to <i>lib/DBD/Driver/TypeInfo.pm</i>.</p>

<p>You should review the output to ensure that it is sensible.</p>

<h2 id="Writing-DBD::Driver::db::get_info">Writing DBD::Driver::db::get_info</h2>

<p>If you use the <b>DBI::DBD::Metadata</b> module, then the code you need is generated for you.</p>

<p>If you decide not to use the <b>DBI::DBD::Metadata</b> module, you should probably borrow the code from a driver that has done so (eg <b>DBD::Informix</b> from version 1.05 onwards) and crib the code from there, or look at the code that generates that module and follow that. The method in <i>Driver.pm</i> will be very simple; the method in <i>lib/DBD/Driver/GetInfo.pm</i> is not very much more complex unless your DBMS itself is much more complex.</p>

<p>Note that some of the <b>DBI</b> utility methods rely on information from the <code><code>get_info()</code></code> method to perform their operations correctly. See, for example, the <code><code>quote_identifier()</code></code> and quote methods, discussed below.</p>

<h2 id="Writing-DBD::Driver::db::type_info_all">Writing DBD::Driver::db::type_info_all</h2>

<p>If you use the <code><code>DBI::DBD::Metadata</code></code> module, then the code you need is generated for you.</p>

<p>If you decide not to use the <code><code>DBI::DBD::Metadata</code></code> module, you should probably borrow the code from a driver that has done so (eg <code><code>DBD::Informix</code></code> from version 1.05 onwards) and crib the code from there, or look at the code that generates that module and follow that. The method in <i>Driver.pm</i> will be very simple; the method in <i>lib/DBD/Driver/TypeInfo.pm</i> is not very much more complex unless your DBMS itself is much more complex.</p>

<h2 id="Writing-DBD::Driver::db::type_info">Writing DBD::Driver::db::type_info</h2>

<p>The guidelines on writing this method are still not really clear. No sample implementation is available.</p>

<h2 id="Writing-DBD::Driver::db::table_info">Writing DBD::Driver::db::table_info</h2>

<pre><code><code> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</code></code></pre>

<h2 id="Writing-DBD::Driver::db::column_info">Writing DBD::Driver::db::column_info</h2>

<pre><code><code> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</code></code></pre>

<h2 id="Writing-DBD::Driver::db::primary_key_info">Writing DBD::Driver::db::primary_key_info</h2>

<pre><code><code> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</code></code></pre>

<h2 id="Writing-DBD::Driver::db::primary_key">Writing DBD::Driver::db::primary_key</h2>

<pre><code><code> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</code></code></pre>

<h2 id="Writing-DBD::Driver::db::foreign_key_info">Writing DBD::Driver::db::foreign_key_info</h2>

<pre><code><code> *FIX ME* The guidelines on writing this method have not been written yet.
 No sample implementation is available.</code></code></pre>

<h2 id="Writing-DBD::Driver::db::tables">Writing DBD::Driver::db::tables</h2>

<p>This method generates an array of names in a format suitable for being embedded in SQL statements in places where a table name is expected.</p>

<p>If your database hews close enough to the SQL standard or if you have implemented an appropriate <code><code>table_info()</code></code> function and and the appropriate <code><code>quote_identifier()</code></code> function, then the <b>DBI</b> default version of this method will work for your driver too.</p>

<p>Otherwise, you have to write a function yourself, such as:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> tables
    </span><span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$cat</span><span class="operator">,</span> <span class="variable">$sch</span><span class="operator">,</span> <span class="variable">$tab</span><span class="operator">,</span> <span class="variable">$typ</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">@res</span><span class="operator">);</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$sth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="variable">$cat</span><span class="operator">,</span> <span class="variable">$sch</span><span class="operator">,</span> <span class="variable">$tab</span><span class="operator">,</span> <span class="variable">$typ</span><span class="operator">);</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">@arr</span><span class="operator">);</span>
        <span class="keyword">while</span> <span class="operator">(</span><span class="variable">@arr</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">)</span>
        <span class="operator">{</span>
            <span class="keyword">push</span> <span class="variable">@res</span><span class="operator">,</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="variable">$arr</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$arr</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$arr</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">);</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">@res</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>See also the default implementation in <i>DBI.pm</i>.</p>

<h2 id="Writing-DBD::Driver::db::quote">Writing DBD::Driver::db::quote</h2>

<p>This method takes a value and converts it into a string suitable for embedding in an SQL statement as a string literal.</p>

<p>If your DBMS accepts the SQL standard notation for strings (single quotes around the string as a whole with any embedded single quotes doubled up), then you do not need to write this method as <b>DBI</b> provides a default method that does it for you.</p>

<p>If your DBMS uses an alternative notation or escape mechanism, then you need to provide an equivalent function. For example, suppose your DBMS used C notation with double quotes around the string and backslashes escaping both double quotes and backslashes themselves. Then you might write the function as:</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> quote
    </span><span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$str</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="variable">$str</span> <span class="operator">=~</span> <span class="regex">s/["\\]/\\$&amp;/gmo</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="string">qq{"</span><span class="variable">$str</span><span class="string">"}</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Handling newlines and other control characters is left as an exercise for the reader.</p>

<p>This sample method ignores the <i>$data_type</i> indicator which is the optional second argument to the method.</p>

<h2 id="Writing-DBD::Driver::db::quote_identifier">Writing DBD::Driver::db::quote_identifier</h2>

<p>This method is called to ensure that the name of the given table (or other database object) can be embedded into an SQL statement without danger of misinterpretation. The result string should be usable in the text of an SQL statement as the identifier for a table.</p>

<p>If your DBMS accepts the SQL standard notation for quoted identifiers (which uses double quotes around the identifier as a whole, with any embedded double quotes doubled up) and accepts <i>&quot;schema&quot;.&quot;identifier&quot;</i> (and <i>&quot;catalog&quot;.&quot;schema&quot;.&quot;identifier&quot;</i> when a catalog is specified), then you do not need to write this method as <b>DBI</b> provides a default method that does it for you.</p>

<p>In fact, even if your DBMS does not handle exactly that notation but you have implemented the <code><code>get_info()</code></code> method and it gives the correct responses, then it will work for you. If your database is fussier, then you need to implement your own version of the function.</p>

<p>For example, <b>DBD::Informix</b> has to deal with an environment variable <i>DELIMIDENT</i>. If it is not set, then the DBMS treats names enclosed in double quotes as strings rather than names, which is usually a syntax error. Additionally, the catalog portion of the name is separated from the schema and table by a different delimiter (colon instead of dot), and the catalog portion is never enclosed in quotes. (Fortunately, valid strings for the catalog will never contain weird characters that might need to be escaped, unless you count dots, dashes, slashes and at-signs as weird.) Finally, an Informix database can contain objects that cannot be accessed because they were created by a user with the <i>DELIMIDENT</i> environment variable set, but the current user does not have it set. By design choice, the <code><code>quote_identifier()</code></code> method encloses those identifiers in double quotes anyway, which generally triggers a syntax error, and the metadata methods which generate lists of tables etc omit those identifiers from the result sets.</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> quote_identifier
    </span><span class="operator">{</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$cat</span><span class="operator">,</span> <span class="variable">$sch</span><span class="operator">,</span> <span class="variable">$obj</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$rv</span><span class="operator">)</span> <span class="operator">=</span> <span class="string">""</span><span class="operator">;</span>
        <span class="keyword">my</span><span class="operator">(</span><span class="variable">$qq</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">DELIMIDENT</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">'"'</span> <span class="operator">:</span> <span class="string">''</span><span class="operator">;</span>
        <span class="variable">$rv</span> <span class="operator">.=</span> <span class="string">qq{</span><span class="variable">$cat</span><span class="string">:}</span> <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$cat</span><span class="operator">);</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$sch</span><span class="operator">)</span>
        <span class="operator">{</span>
            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$sch</span> <span class="operator">!~</span> <span class="regex">m/^\w+$/o</span><span class="operator">)</span>
            <span class="operator">{</span>
                <span class="variable">$qq</span> <span class="operator">=</span> <span class="string">'"'</span><span class="operator">;</span>
                <span class="variable">$sch</span> <span class="operator">=~</span> <span class="regex">s/</span><span class="variable">$qq</span><span class="regex">/$qq$qq/gm</span><span class="operator">;</span>
            <span class="operator">}</span>
            <span class="variable">$rv</span> <span class="operator">.=</span> <span class="string">qq{</span><span class="variable">$qq$sch$qq</span><span class="string">.}</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$obj</span><span class="operator">)</span>
        <span class="operator">{</span>
            <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$obj</span> <span class="operator">!~</span> <span class="regex">m/^\w+$/o</span><span class="operator">)</span>
            <span class="operator">{</span>
                <span class="variable">$qq</span> <span class="operator">=</span> <span class="string">'"'</span><span class="operator">;</span>
                <span class="variable">$obj</span> <span class="operator">=~</span> <span class="regex">s/</span><span class="variable">$qq</span><span class="regex">/$qq$qq/gm</span><span class="operator">;</span>
            <span class="operator">}</span>
            <span class="variable">$rv</span> <span class="operator">.=</span> <span class="string">qq{</span><span class="variable">$qq$obj$qq</span><span class="string">}</span><span class="operator">;</span>
        <span class="operator">}</span>
        <span class="keyword">return</span> <span class="variable">$rv</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Handling newlines and other control characters is left as an exercise for the reader.</p>

<p>Note that there is an optional fourth parameter to this function which is a reference to a hash of attributes; this sample implementation ignores that.</p>

<p>This sample implementation also ignores the single-argument variant of the method.</p>

<h1 id="TRACING">TRACING</h1>

<p>Tracing in DBI is controlled with a combination of a trace level and a set of flags which together are known as the trace settings. The trace settings are stored in a single integer and divided into levels and flags by a set of masks (<code><code>DBIc_TRACE_LEVEL_MASK</code></code> and <code><code>DBIc_TRACE_FLAGS_MASK</code></code>).</p>

<p>Each handle has it&#39;s own trace settings and so does the DBI. When you call a method the DBI merges the handles settings into its own for the duration of the call: the trace flags of the handle are OR&#39;d into the trace flags of the DBI, and if the handle has a higher trace level then the DBI trace level is raised to match it. The previous DBI trace settings are restored when the called method returns.</p>

<h2 id="Trace-Level">Trace Level</h2>

<p>The trace level is the first 4 bits of the trace settings (masked by <code><code>DBIc_TRACE_FLAGS_MASK</code></code>) and represents trace levels of 1 to 15. Do not output anything at trace levels less than 3 as they are reserved for DBI.</p>

<p>For advice on what to output at each level see &quot;Trace Levels&quot; in <a href="../../lib/DBI.html">DBI</a>.</p>

<p>To test for a trace level you can use the <code><code>DBIc_TRACE_LEVEL</code></code> macro like this:</p>

<pre><code><code>  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">DBIc_TRACE_LEVEL</span><span class="operator">(</span><span class="variable">imp_xxh</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="number">2</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">PerlIO_printf</span><span class="operator">(</span><span class="variable">DBIc_LOGPIO</span><span class="operator">(</span><span class="variable">imp_xxh</span><span class="operator">),</span> <span class="string">"foobar"</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Also <b>note</b> the use of PerlIO_printf which you should always use for tracing and never the C <code><code>stdio.h</code></code> I/O functions.</p>

<h2 id="Trace-Flags">Trace Flags</h2>

<p>Trace flags are used to enable tracing of specific activities within the DBI and drivers. The DBI defines some trace flags and drivers can define others. DBI trace flag names begin with a capital letter and driver specific names begin with a lowercase letter. For a list of DBI defined trace flags see &quot;Trace Flags&quot; in <a href="../../lib/DBI.html">DBI</a>.</p>

<p>If you want to use private trace flags you&#39;ll probably want to be able to set them by name. Drivers are expected to override the parse_trace_flag (note the singular) and check if $trace_flag_name is a driver specific trace flags and, if not, then call the DBIs default parse_trace_flag(). To do that you&#39;ll need to define a parse_trace_flag() method like this:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> parse_trace_flag </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$h</span><span class="operator">,</span> <span class="variable">$name</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x01000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'foo'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x02000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'bar'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x04000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'baz'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x08000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'boo'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="number">0x10000000</span> <span class="keyword">if</span> <span class="variable">$name</span> <span class="keyword">eq</span> <span class="string">'bop'</span><span class="operator">;</span>
      <span class="keyword">return</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">SUPER::parse_trace_flag</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>All private flag names must be lowercase, and all private flags must be in the top 8 of the 32 bits of <code><code>DBIc_TRACE_FLAGS(imp)</code></code> i.e., 0xFF000000.</p>

<p>If you&#39;ve defined a parse_trace_flag() method in ::db you&#39;ll also want it in ::st, so just alias it in:</p>

<pre><code><code>  <span class="variable">*parse_trace_flag</span> <span class="operator">=</span> <span class="operator">\&amp;</span><span class="variable">DBD::foo</span><span class="operator">:</span><span class="variable">db::parse_trace_flag</span><span class="operator">;</span>
</code></code></pre>

<p>You may want to act on the current &#39;SQL&#39; trace flag that DBI defines to output SQL prepared/executed as DBI currently does not do SQL tracing.</p>

<h2 id="Trace-Macros">Trace Macros</h2>

<p>Access to the trace level and trace flags is via a set of macros.</p>

<pre><code><code>  DBIc_TRACE_SETTINGS(imp) returns the trace settings
  DBIc_TRACE_LEVEL(imp) returns the trace level
  DBIc_TRACE_FLAGS(imp) returns the trace flags
  DBIc_TRACE(imp, flags, flaglevel, level)

  e.g.,

  DBIc_TRACE(imp, 0, 0, 4)
    if level &gt;= 4

  DBIc_TRACE(imp, DBDtf_FOO, 2, 4)
    if tracing DBDtf_FOO &amp; level&gt;=2 or level&gt;=4

  DBIc_TRACE(imp, DBDtf_FOO, 2, 0)
    as above but never trace just due to level</code></code></pre>

<h1 id="WRITING-AN-EMULATION-LAYER-FOR-AN-OLD-PERL-INTERFACE">WRITING AN EMULATION LAYER FOR AN OLD PERL INTERFACE</h1>

<p>Study <i>Oraperl.pm</i> (supplied with <b>DBD::Oracle</b>) and <i>Ingperl.pm</i> (supplied with <b>DBD::Ingres</b>) and the corresponding <i>dbdimp.c</i> files for ideas.</p>

<p>Note that the emulation code sets <code><code><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">CompatMode</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</code></code> for each connection so that the internals of the driver can implement behaviour compatible with the old interface when dealing with those handles.</p>

<h2 id="Setting-emulation-perl-variables">Setting emulation perl variables</h2>

<p>For example, ingperl has a <i>$sql_rowcount</i> variable. Rather than try to manually update this in <i>Ingperl.pm</i> it can be done faster in C code. In <code><code>dbd_init()</code></code>:</p>

<pre><code><code>  <span class="variable">sql_rowcount</span> <span class="operator">=</span> <span class="variable">perl_get_sv</span><span class="operator">(</span><span class="string">"Ingperl::sql_rowcount"</span><span class="operator">,</span> <span class="variable">GV_ADDMULTI</span><span class="operator">);</span>
</code></code></pre>

<p>In the relevant places do:</p>

<pre><code><code>  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">DBIc_COMPAT</span><span class="operator">(</span><span class="variable">imp_sth</span><span class="operator">))</span>     <span class="operator">/*</span> <span class="variable">only</span> <span class="keyword">do</span> <span class="variable">this</span> <span class="keyword">for</span> <span class="variable">compatibility</span> <span class="variable">mode</span> <span class="variable">handles</span> <span class="operator">*/</span>
      <span class="variable">sv_setiv</span><span class="operator">(</span><span class="variable">sql_rowcount</span><span class="operator">,</span> <span class="variable">the_row_count</span><span class="operator">);</span>
</code></code></pre>

<h1 id="OTHER-MISCELLANEOUS-INFORMATION">OTHER MISCELLANEOUS INFORMATION</h1>

<h2 id="The-imp_xyz_t-types">The imp_xyz_t types</h2>

<p>Any handle has a corresponding C structure filled with private data. Some of this data is reserved for use by <b>DBI</b> (except for using the DBIc macros below), some is for you. See the description of the <i>dbdimp.h</i> file above for examples. Most functions in <i>dbdimp.c</i> are passed both the handle <code><code>xyz</code></code> and a pointer to <code><code>imp_xyz</code></code>. In rare cases, however, you may use the following macros:</p>

<dl>

<dt id="D_imp_dbh-dbh-">D_imp_dbh(dbh)</dt>
<dd>

<p>Given a function argument <i>dbh</i>, declare a variable <i>imp_dbh</i> and initialize it with a pointer to the handles private data. Note: This must be a part of the function header, because it declares a variable.</p>

</dd>
<dt id="D_imp_sth-sth-">D_imp_sth(sth)</dt>
<dd>

<p>Likewise for statement handles.</p>

</dd>
<dt id="D_imp_xxx-h-">D_imp_xxx(h)</dt>
<dd>

<p>Given any handle, declare a variable <i>imp_xxx</i> and initialize it with a pointer to the handles private data. It is safe, for example, to cast <i>imp_xxx</i> to <code><code>imp_dbh_t*</code></code>, if <code><code>DBIc_TYPE(imp_xxx) == DBIt_DB</code></code>. (You can also call <code><code>sv_derived_from(h, &quot;DBI::db&quot;)</code></code>, but that&#39;s much slower.)</p>

</dd>
<dt id="D_imp_dbh_from_sth">D_imp_dbh_from_sth</dt>
<dd>

<p>Given a <i>imp_sth</i>, declare a variable <i>imp_dbh</i> and initialize it with a pointer to the parent database handle&#39;s implementors structure.</p>

</dd>
</dl>

<h2 id="Using-DBIc_IMPSET_on">Using DBIc_IMPSET_on</h2>

<p>The driver code which initializes a handle should use <code><code>DBIc_IMPSET_on()</code></code> as soon as its state is such that the cleanup code must be called. When this happens is determined by your driver code.</p>

<p><b>Failure to call this can lead to corruption of data structures.</b></p>

<p>For example, <b>DBD::Informix</b> maintains a linked list of database handles in the driver, and within each handle, a linked list of statements. Once a statement is added to the linked list, it is crucial that it is cleaned up (removed from the list). When <i>DBIc_IMPSET_on()</i> was being called too late, it was able to cause all sorts of problems.</p>

<h2 id="Using-DBIc_is-DBIc_has-DBIc_on-and-DBIc_off-">Using DBIc_is(), DBIc_has(), DBIc_on() and DBIc_off()</h2>

<p>Once upon a long time ago, the only way of handling the internal <b>DBI</b> boolean flags/attributes was through macros such as:</p>

<pre><code><code>  DBIc_WARN       DBIc_WARN_on        DBIc_WARN_off
  DBIc_COMPAT     DBIc_COMPAT_on      DBIc_COMPAT_off</code></code></pre>

<p>Each of these took an <i>imp_xxh</i> pointer as an argument.</p>

<p>Since then, new attributes have been added such as <i>ChopBlanks</i>, <i>RaiseError</i> and <i>PrintError</i>, and these do not have the full set of macros. The approved method for handling these is now the four macros:</p>

<pre><code><code>  DBIc_is(imp, flag)
  DBIc_has(imp, flag)       an alias for DBIc_is
  DBIc_on(imp, flag)
  DBIc_off(imp, flag)
  DBIc_set(imp, flag, on)   set if on is true, else clear</code></code></pre>

<p>Consequently, the <code><code>DBIc_XXXXX</code></code> family of macros is now mostly deprecated and new drivers should avoid using them, even though the older drivers will probably continue to do so for quite a while yet. However...</p>

<p>There is an <i>important exception</i> to that. The <i>ACTIVE</i> and <i>IMPSET</i> flags should be set via the <code><code>DBIc_ACTIVE_on()</code></code> and <code><code>DBIc_IMPSET_on()</code></code> macros, and unset via the <code><code>DBIc_ACTIVE_off()</code></code> and <code><code>DBIc_IMPSET_off()</code></code> macros.</p>

<h2 id="Using-the-get_fbav-method">Using the get_fbav() method</h2>

<p><b>THIS IS CRITICAL for C/XS drivers</b>.</p>

<p>The <code><code>$sth-&gt;bind_col()</code></code> and <code><code>$sth-&gt;bind_columns()</code></code> documented in the <b>DBI</b> specification do not have to be implemented by the driver writer because <b>DBI</b> takes care of the details for you.</p>

<p>However, the key to ensuring that bound columns work is to call the function <code><code>DBIc_DBISTATE(imp_xxh)-&gt;get_fbav()</code></code> in the code which fetches a row of data.</p>

<p>This returns an <code><code>AV</code></code>, and each element of the <code><code>AV</code></code> contains the <code><code>SV</code></code> which should be set to contain the returned data.</p>

<p>The pure Perl equivalent is the <code><code>$sth-&gt;_set_fbav($data)</code></code> method, as described in the part on pure Perl drivers.</p>

<h2 id="Casting-strings-to-Perl-types-based-on-a-SQL-type">Casting strings to Perl types based on a SQL type</h2>

<p>DBI from 1.611 (and DBIXS_REVISION 13606) defines the sql_type_cast_svpv method which may be used to cast a string representation of a value to a more specific Perl type based on a SQL type. You should consider using this method when processing bound column data as it provides some support for the TYPE bind_col attribute which is rarely used in drivers.</p>

<pre><code><code>  int sql_type_cast_svpv(pTHX_ SV *sv, int sql_type, U32 flags, void *v)</code></code></pre>

<p><code><code>sv</code></code> is what you would like cast, <code><code>sql_type</code></code> is one of the DBI defined SQL types (e.g., <code><code>SQL_INTEGER</code></code>) and <code><code>flags</code></code> is a bitmask as follows:</p>

<dl>

<dt id="DBIstcf_STRICT">DBIstcf_STRICT</dt>
<dd>

<p>If set this indicates you want an error state returned if the cast cannot be performed.</p>

</dd>
<dt id="DBIstcf_DISCARD_STRING">DBIstcf_DISCARD_STRING</dt>
<dd>

<p>If set and the pv portion of the <code><code>sv</code></code> is cast then this will cause sv&#39;s pv to be freed up.</p>

</dd>
</dl>

<p>sql_type_cast_svpv returns the following states:</p>

<pre><code><code> -2 sql_type is not handled - sv not changed
 -1 sv is undef, sv not changed
  0 sv could not be cast cleanly and DBIstcf_STRICT was specified
  1 sv could not be case cleanly and DBIstcf_STRICT was not specified
  2 sv was cast ok</code></code></pre>

<p>The current implementation of sql_type_cast_svpv supports <code><code>SQL_INTEGER</code></code>, <code><code>SQL_DOUBLE</code></code> and <code><code>SQL_NUMERIC</code></code>. <code><code>SQL_INTEGER</code></code> uses sv_2iv and hence may set IV, UV or NV depending on the number. <code><code>SQL_DOUBLE</code></code> uses sv_2nv so may set NV and <code><code>SQL_NUMERIC</code></code> will set IV or UV or NV.</p>

<p>DBIstcf_STRICT should be implemented as the StrictlyTyped attribute and DBIstcf_DISCARD_STRING implemented as the DiscardString attribute to the bind_col method and both default to off.</p>

<p>See DBD::Oracle for an example of how this is used.</p>

<h1 id="SUBCLASSING-DBI-DRIVERS">SUBCLASSING DBI DRIVERS</h1>

<p>This is definitely an open subject. It can be done, as demonstrated by the <b>DBD::File</b> driver, but it is not as simple as one might think.</p>

<p>(Note that this topic is different from subclassing the <b>DBI</b>. For an example of that, see the <i>t/subclass.t</i> file supplied with the <b>DBI</b>.)</p>

<p>The main problem is that the <i>dbh</i>&#39;s and <i>sth</i>&#39;s that your <code><code>connect()</code></code> and <code><code>prepare()</code></code> methods return are not instances of your <b>DBD::Driver::db</b> or <b>DBD::Driver::st</b> packages, they are not even derived from it. Instead they are instances of the <b>DBI::db</b> or <b>DBI::st</b> classes or a derived subclass. Thus, if you write a method <code><code>mymethod()</code></code> and do a</p>

<pre><code><code>  $dbh-&gt;mymethod()</code></code></pre>

<p>then the autoloader will search for that method in the package <b>DBI::db</b>. Of course you can instead to a</p>

<pre><code><code>  $dbh-&gt;func(&#39;mymethod&#39;)</code></code></pre>

<p>and that will indeed work, even if <code><code>mymethod()</code></code> is inherited, but not without additional work. Setting <i>@ISA</i> is not sufficient.</p>

<h2 id="Overwriting-methods">Overwriting methods</h2>

<p>The first problem is, that the <code><code>connect()</code></code> method has no idea of subclasses. For example, you cannot implement base class and subclass in the same file: The <code><code>install_driver()</code></code> method wants to do a</p>

<pre><code><code>  <span class="keyword">require</span> <span class="variable">DBD::Driver</span><span class="operator">;</span>
</code></code></pre>

<p>In particular, your subclass <b>has</b> to be a separate driver, from the view of <b>DBI</b>, and you cannot share driver handles.</p>

<p>Of course that&#39;s not much of a problem. You should even be able to inherit the base classes <code><code>connect()</code></code> method. But you cannot simply overwrite the method, unless you do something like this, quoted from <b>DBD::CSV</b>:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> connect </span><span class="operator">(</span>$$;$$$<span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$drh</span><span class="operator">,</span> <span class="variable">$dbname</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
  
      <span class="keyword">my</span> <span class="variable">$this</span> <span class="operator">=</span> <span class="variable">$drh</span><span class="operator">-&gt;</span><span class="variable">DBD::File::dr::connect</span><span class="operator">(</span><span class="variable">$dbname</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">);</span>
      <span class="keyword">if</span> <span class="operator">(!</span><span class="keyword">exists</span><span class="operator">(</span><span class="variable">$this</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">csv_tables</span><span class="operator">}</span><span class="operator">))</span> <span class="operator">{</span>
          <span class="variable">$this</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">csv_tables</span><span class="operator">}</span> <span class="operator">=</span> <span class="operator">{}</span><span class="operator">;</span>
      <span class="operator">}</span>
  
      <span class="variable">$this</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Note that we cannot do a</p>

<pre><code><code>  <span class="variable">$drh</span><span class="operator">-&gt;</span><span class="variable">SUPER::connect</span><span class="operator">(</span><span class="variable">$dbname</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$auth</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">);</span>
</code></code></pre>

<p>as we would usually do in a an OO environment, because <i>$drh</i> is an instance of <b>DBI::dr</b>. And note, that the <code><code>connect()</code></code> method of <b>DBD::File</b> is able to handle subclass attributes. See the description of Pure Perl drivers above.</p>

<p>It is essential that you always call superclass method in the above manner. However, that should do.</p>

<h2 id="Attribute-handling">Attribute handling</h2>

<p>Fortunately the <b>DBI</b> specifications allow a simple, but still performant way of handling attributes. The idea is based on the convention that any driver uses a prefix <i>driver_</i> for its private methods. Thus it&#39;s always clear whether to pass attributes to the super class or not. For example, consider this <code><code>STORE()</code></code> method from the <b>DBD::CSV</b> class:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> STORE </span><span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">,</span> <span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$val</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="operator">!~</span> <span class="regex">/^driver_/</span><span class="operator">)</span> <span class="operator">{</span>
          <span class="keyword">return</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">DBD::File::db::STORE</span><span class="operator">(</span><span class="variable">$attr</span><span class="operator">,</span> <span class="variable">$val</span><span class="operator">);</span>
      <span class="operator">}</span>
      <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$attr</span> <span class="keyword">eq</span> <span class="string">'driver_foo'</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="operator">...</span>
  <span class="operator">}</span>
</code></code></pre>

<h1 id="AUTHORS">AUTHORS</h1>

<p>Jonathan Leffler &lt;jleffler@us.ibm.com&gt; (previously &lt;jleffler@informix.com&gt;), Jochen Wiedmann &lt;joe@ispsoft.de&gt;, Steffen Goeldner &lt;sgoeldner@cpan.org&gt;, and Tim Bunce &lt;dbi-users@perl.org&gt;.</p>


</body>

</html>


