<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../displayToc.js"></script>
<script language="JavaScript" src="../tocParas.js"></script>
<script language="JavaScript" src="../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../scineplex.css">
<title></title>
<link rel="stylesheet" href="../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#Fundamentals">Fundamentals</a>
        <ul>
          <li><a href="#Declaration">Declaration</a></li>
          <li><a href="#Calling-Conventions-and-Magic-Autogeneration">Calling Conventions and Magic Autogeneration</a></li>
          <li><a href="#Mathemagic-Mutators-and-Copy-Constructors">Mathemagic, Mutators, and Copy Constructors</a></li>
        </ul>
      </li>
      <li><a href="#Overloadable-Operations">Overloadable Operations</a></li>
      <li><a href="#Magic-Autogeneration">Magic Autogeneration</a>
        <ul>
          <li><a href="#Minimal-Set-of-Overloaded-Operations">Minimal Set of Overloaded Operations</a></li>
        </ul>
      </li>
      <li><a href="#Special-Keys-for">Special Keys for </a>
        <ul>
          <li><a href="#"></a></li>
          <li><a href="#1"></a></li>
          <li><a href="#Copy-Constructor">Copy Constructor</a></li>
        </ul>
      </li>
      <li><a href="#How-Perl-Chooses-an-Operator-Implementation">How Perl Chooses an Operator Implementation</a></li>
      <li><a href="#Losing-Overloading">Losing Overloading</a></li>
      <li><a href="#Inheritance-and-Overloading">Inheritance and Overloading</a></li>
      <li><a href="#Run-time-Overloading">Run-time Overloading</a></li>
      <li><a href="#Public-Functions">Public Functions</a></li>
      <li><a href="#Overloading-Constants">Overloading Constants</a></li>
    </ul>
  </li>
  <li><a href="#IMPLEMENTATION">IMPLEMENTATION</a></li>
  <li><a href="#COOKBOOK">COOKBOOK</a>
    <ul>
      <li><a href="#Two-face-Scalars">Two-face Scalars</a></li>
      <li><a href="#Two-face-References">Two-face References</a></li>
      <li><a href="#Symbolic-Calculator">Symbolic Calculator</a></li>
      <li><a href="#Really-Symbolic-Calculator">Really Symbolic Calculator</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#DIAGNOSTICS">DIAGNOSTICS</a></li>
  <li><a href="#BUGS-AND-PITFALLS">BUGS AND PITFALLS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>overload - Package for overloading Perl operations</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">SomeThing</span><span class="operator">;</span>
    
    <span class="keyword">use</span> <span class="variable">overload</span>
        <span class="string">'+'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">myadd</span><span class="operator">,</span>
        <span class="string">'-'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">mysub</span><span class="operator">;</span>
        <span class="comment"># etc</span>
    <span class="operator">...</span>
    
    <span class="keyword">package</span> <span class="variable">main</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">SomeThing</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="number">57</span> <span class="operator">);</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="number">5</span> <span class="operator">+</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="operator">...</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">overload::Overloaded</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">{...}</span>
    <span class="operator">...</span>
    <span class="variable">$strval</span> <span class="operator">=</span> <span class="variable">overload::StrVal</span> <span class="variable">$b</span><span class="operator">;</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This pragma allows overloading of Perl&#39;s operators for a class. To overload built-in functions, see <a href="../lib/pods/perlsub.html#Overriding-Built-in-Functions">&quot;Overriding Built-in Functions&quot; in perlsub</a> instead.</p>

<h2 id="Fundamentals">Fundamentals</h2>

<h3 id="Declaration">Declaration</h3>

<p>Arguments of the <code><code>use overload</code></code> directive are (key, value) pairs. For the full set of legal keys, see <a href="#Overloadable-Operations">&quot;Overloadable Operations&quot;</a> below.</p>

<p>Operator implementations (the values) can be subroutines, references to subroutines, or anonymous subroutines - in other words, anything legal inside a <code><code><span class="operator">&amp;{</span> <span class="operator">...</span> <span class="operator">}</span>
</code></code> call. Values specified as strings are interpreted as method names. Thus</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Number</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">overload</span>
        <span class="string">"-"</span> <span class="operator">=&gt;</span> <span class="string">"minus"</span><span class="operator">,</span>
        <span class="string">"*="</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">muas</span><span class="operator">,</span>
        <span class="string">'""'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="operator">...;</span> <span class="operator">};</span>
</code></code></pre>

<p>declares that subtraction is to be implemented by method <code><code>minus()</code></code> in the class <code><code>Number</code></code> (or one of its base classes), and that the function <code><code>Number::muas()</code></code> is to be used for the assignment form of multiplication, <code><code>*=</code></code>. It also defines an anonymous subroutine to implement stringification: this is called whenever an object blessed into the package <code><code>Number</code></code> is used in a string context (this subroutine might, for example, return the number as a Roman numeral).</p>

<h3 id="Calling-Conventions-and-Magic-Autogeneration">Calling Conventions and Magic Autogeneration</h3>

<p>The following sample implementation of <code><code>minus()</code></code> (which assumes that <code><code>Number</code></code> objects are simply blessed references to scalars) illustrates the calling conventions:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Number</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> minus </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">,</span> <span class="variable">$swap</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$$self</span> <span class="operator">-</span> <span class="variable">$other</span><span class="operator">;</span>         <span class="comment"># *</span>
        <span class="variable">$result</span> <span class="operator">=</span> <span class="operator">-</span><span class="variable">$result</span> <span class="keyword">if</span> <span class="variable">$swap</span><span class="operator">;</span>
        <span class="keyword">ref</span> <span class="variable">$result</span> <span class="operator">?</span> <span class="variable">$result</span> <span class="operator">:</span> <span class="keyword">bless</span> <span class="operator">\</span><span class="variable">$result</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="comment"># * may recurse once - see table below</span>
</code></code></pre>

<p>Three arguments are passed to all subroutines specified in the <code><code>use overload</code></code> directive (with one exception - see <a href="#nomethod">&quot;nomethod&quot;</a>). The first of these is the operand providing the overloaded operator implementation - in this case, the object whose <code><code>minus()</code></code> method is being called.</p>

<p>The second argument is the other operand, or <code><code>undef</code></code> in the case of a unary operator.</p>

<p>The third argument is set to TRUE if (and only if) the two operands have been swapped. Perl may do this to ensure that the first argument (<code><code>$self</code></code>) is an object implementing the overloaded operation, in line with general object calling conventions. For example, if <code><code>$x</code></code> and <code><code>$y</code></code> are <code><code>Number</code></code>s:</p>

<pre><code><code>    operation   |   generates a call to
    ============|======================
    $x - $y     |   minus($x, $y, &#39;&#39;)
    $x - 7      |   minus($x, 7, &#39;&#39;)
    7 - $x      |   minus($x, 7, 1)</code></code></pre>

<p>Perl may also use <code><code>minus()</code></code> to implement other operators which have not been specified in the <code><code>use overload</code></code> directive, according to the rules for <a href="#Magic-Autogeneration">&quot;Magic Autogeneration&quot;</a> described later. For example, the <code><code>use overload</code></code> above declared no subroutine for any of the operators <code><code>--</code></code>, <code><code>neg</code></code> (the overload key for unary minus), or <code><code>-=</code></code>. Thus</p>

<pre><code><code>    operation   |   generates a call to
    ============|======================
    -$x         |   minus($x, 0, 1)
    $x--        |   minus($x, 1, undef)
    $x -= 3     |   minus($x, 3, undef)</code></code></pre>

<p>Note the <code><code>undef</code></code>s: where autogeneration results in the method for a standard operator which does not change either of its operands, such as <code><code>-</code></code>, being used to implement an operator which changes the operand (&quot;mutators&quot;: here, <code><code>--</code></code> and <code><code>-=</code></code>), Perl passes undef as the third argument. This still evaluates as FALSE, consistent with the fact that the operands have not been swapped, but gives the subroutine a chance to alter its behaviour in these cases.</p>

<p>In all the above examples, <code><code>minus()</code></code> is required only to return the result of the subtraction: Perl takes care of the assignment to $x. In fact, such methods should <i>not</i> modify their operands, even if <code><code>undef</code></code> is passed as the third argument (see <a href="#Overloadable-Operations">&quot;Overloadable Operations&quot;</a>).</p>

<p>The same is not true of implementations of <code><code>++</code></code> and <code><code>--</code></code>: these are expected to modify their operand. An appropriate implementation of <code><code>--</code></code> might look like</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'--'</span> <span class="operator">=&gt;</span> <span class="string">"decr"</span><span class="operator">,</span>
        <span class="comment"># ...</span>
    <span class="keyword">sub</span><span class="variable"> decr </span><span class="operator">{</span> <span class="operator">--</span><span class="variable">$</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]}</span><span class="operator">;</span> <span class="operator">}</span>
</code></code></pre>

<h3 id="Mathemagic-Mutators-and-Copy-Constructors">Mathemagic, Mutators, and Copy Constructors</h3>

<p>The term &#39;mathemagic&#39; describes the overloaded implementation of mathematical operators. Mathemagical operations raise an issue. Consider the code:</p>

<pre><code><code>    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="operator">--</span><span class="variable">$a</span><span class="operator">;</span>
</code></code></pre>

<p>If <code><code>$a</code></code> and <code><code>$b</code></code> are scalars then after these statements</p>

<pre><code><code>    $a == $b - 1</code></code></pre>

<p>An object, however, is a reference to blessed data, so if <code><code>$a</code></code> and <code><code>$b</code></code> are objects then the assignment <code><code>$a = $b</code></code> copies only the reference, leaving <code><code>$a</code></code> and <code><code>$b</code></code> referring to the same object data. One might therefore expect the operation <code><code>--$a</code></code> to decrement <code><code>$b</code></code> as well as <code><code>$a</code></code>. However, this would not be consistent with how we expect the mathematical operators to work.</p>

<p>Perl resolves this dilemma by transparently calling a copy constructor before calling a method defined to implement a mutator (<code><code>--</code></code>, <code><code>+=</code></code>, and so on.). In the above example, when Perl reaches the decrement statement, it makes a copy of the object data in <code><code>$a</code></code> and assigns to <code><code>$a</code></code> a reference to the copied data. Only then does it call <code><code>decr()</code></code>, which alters the copied data, leaving <code><code>$b</code></code> unchanged. Thus the object metaphor is preserved as far as possible, while mathemagical operations still work according to the arithmetic metaphor.</p>

<p>Note: the preceding paragraph describes what happens when Perl autogenerates the copy constructor for an object based on a scalar. For other cases, see <a href="#Copy-Constructor">&quot;Copy Constructor&quot;</a>.</p>

<h2 id="Overloadable-Operations">Overloadable Operations</h2>

<p>The complete list of keys that can be specified in the <code><code>use overload</code></code> directive are given, separated by spaces, in the values of the hash <code><code>%overload::ops</code></code>:</p>

<pre><code><code> <span class="string">with_assign</span>      <span class="operator">=&gt;</span> <span class="string">'+ - * / % ** &lt;&lt; &gt;&gt; x .'</span><span class="operator">,</span>
 <span class="string">assign</span>           <span class="operator">=&gt;</span> <span class="string">'+= -= *= /= %= **= &lt;&lt;= &gt;&gt;= x= .='</span><span class="operator">,</span>
 <span class="string">num_comparison</span>   <span class="operator">=&gt;</span> <span class="string">'&lt; &lt;= &gt; &gt;= == !='</span><span class="operator">,</span>
 <span class="string">'3way_comparison'</span><span class="operator">=&gt;</span> <span class="string">'&lt;=&gt; cmp'</span><span class="operator">,</span>
 <span class="string">str_comparison</span>   <span class="operator">=&gt;</span> <span class="string">'lt le gt ge eq ne'</span><span class="operator">,</span>
 <span class="string">binary</span>           <span class="operator">=&gt;</span> <span class="string">'&amp; &amp;= | |= ^ ^='</span><span class="operator">,</span>
 <span class="string">unary</span>            <span class="operator">=&gt;</span> <span class="string">'neg ! ~'</span><span class="operator">,</span>
 <span class="string">mutators</span>         <span class="operator">=&gt;</span> <span class="string">'++ --'</span><span class="operator">,</span>
 <span class="string">func</span>             <span class="operator">=&gt;</span> <span class="string">'atan2 cos sin exp abs log sqrt int'</span><span class="operator">,</span>
 <span class="string">conversion</span>       <span class="operator">=&gt;</span> <span class="string">'bool "" 0+ qr'</span><span class="operator">,</span>
 <span class="string">iterators</span>        <span class="operator">=&gt;</span> <span class="string">'&lt;&gt;'</span><span class="operator">,</span>
 <span class="string">filetest</span>         <span class="operator">=&gt;</span> <span class="string">'-X'</span><span class="operator">,</span>
 <span class="string">dereferencing</span>    <span class="operator">=&gt;</span> <span class="string">'${} @{} %{} &amp;{} *{}'</span><span class="operator">,</span>
 <span class="string">matching</span>         <span class="operator">=&gt;</span> <span class="string">'~~'</span><span class="operator">,</span>
 <span class="string">special</span>          <span class="operator">=&gt;</span> <span class="string">'nomethod fallback ='</span>
</code></code></pre>

<p>Most of the overloadable operators map one-to-one to these keys. Exceptions, including additional overloadable operations not apparent from this hash, are included in the notes which follow.</p>

<p>A warning is issued if an attempt is made to register an operator not found above.</p>

<ul>

<li><p><code><code>not</code></code></p>

<p>The operator <code><code>not</code></code> is not a valid key for <code><code>use overload</code></code>. However, if the operator <code><code>!</code></code> is overloaded then the same implementation will be used for <code><code>not</code></code> (since the two operators differ only in precedence).</p>

</li>
<li><p><code><code>neg</code></code></p>

<p>The key <code><code>neg</code></code> is used for unary minus to disambiguate it from binary <code><code>-</code></code>.</p>

</li>
<li><p><code><code>++</code></code>, <code><code>--</code></code></p>

<p>Assuming they are to behave analogously to Perl&#39;s <code><code>++</code></code> and <code><code>--</code></code>, overloaded implementations of these operators are required to mutate their operands.</p>

<p>No distinction is made between prefix and postfix forms of the increment and decrement operators: these differ only in the point at which Perl calls the associated subroutine when evaluating an expression.</p>

</li>
<li><p><i>Assignments</i></p>

<pre><code><code>    +=  -=  *=  /=  %=  **=  &lt;&lt;=  &gt;&gt;=  x=  .=
    &amp;=  |=  ^=</code></code></pre>

<p>Simple assignment is not overloadable (the <code><code>&#39;=&#39;</code></code> key is used for the <a href="#Copy-Constructor">&quot;Copy Constructor&quot;</a>). Perl does have a way to make assignments to an object do whatever you want, but this involves using tie(), not overload - see <a href="../lib/pods/perlfunc.html#tie">&quot;tie&quot; in perlfunc</a> and the <a href="#COOKBOOK">&quot;COOKBOOK&quot;</a> examples below.</p>

<p>The subroutine for the assignment variant of an operator is required only to return the result of the operation. It is permitted to change the value of its operand (this is safe because Perl calls the copy constructor first), but this is optional since Perl assigns the returned value to the left-hand operand anyway.</p>

<p>An object that overloads an assignment operator does so only in respect of assignments to that object. In other words, Perl never calls the corresponding methods with the third argument (the &quot;swap&quot; argument) set to TRUE. For example, the operation</p>

<pre><code><code>    $a *= $b</code></code></pre>

<p>cannot lead to <code><code>$b</code></code>&#39;s implementation of <code><code>*=</code></code> being called, even if <code><code>$a</code></code> is a scalar. (It can, however, generate a call to <code><code>$b</code></code>&#39;s method for <code><code>*</code></code>).</p>

</li>
<li><p><i>Non-mutators with a mutator variant</i></p>

<pre><code><code>     +  -  *  /  %  **  &lt;&lt;  &gt;&gt;  x  .
     &amp;  |  ^</code></code></pre>

<p>As described <a href="#Calling-Conventions-and-Magic-Autogeneration">above</a>, Perl may call methods for operators like <code><code>+</code></code> and <code><code>&amp;</code></code> in the course of implementing missing operations like <code><code>++</code></code>, <code><code>+=</code></code>, and <code><code>&amp;=</code></code>. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</p>

</li>
<li><p><code><code>int</code></code></p>

<p>Traditionally, the Perl function <code><code>int</code></code> rounds to 0 (see <a href="../lib/pods/perlfunc.html#int">&quot;int&quot; in perlfunc</a>), and so for floating-point-like types one should follow the same semantic.</p>

</li>
<li><p><i>String, numeric, boolean, and regexp conversions</i></p>

<pre><code><code>    &quot;&quot;  0+  bool</code></code></pre>

<p>These conversions are invoked according to context as necessary. For example, the subroutine for <code><code>&#39;&quot;&quot;&#39;</code></code> (stringify) may be used where the overloaded object is passed as an argument to <code><code>print</code></code>, and that for <code><code>&#39;bool&#39;</code></code> where it is tested in the condition of a flow control statement (like <code><code>while</code></code>) or the ternary <code><code>?:</code></code> operation.</p>

<p>Of course, in contexts like, for example, <code><code>$obj + 1</code></code>, Perl will invoke <code><code>$obj</code></code>&#39;s implementation of <code><code>+</code></code> rather than (in this example) converting <code><code>$obj</code></code> to a number using the numify method <code><code>&#39;0+&#39;</code></code> (an exception to this is when no method has been provided for <code><code>&#39;+&#39;</code></code> and <a href="#fallback">&quot;fallback&quot;</a> is set to TRUE).</p>

<p>The subroutines for <code><code>&#39;&quot;&quot;&#39;</code></code>, <code><code>&#39;0+&#39;</code></code>, and <code><code>&#39;bool&#39;</code></code> can return any arbitrary Perl value. If the corresponding operation for this value is overloaded too, the operation will be called again with this value.</p>

<p>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you&#39;re likely to get something that looks like <code><code>YourPackage=HASH(0x8172b34)</code></code>.</p>

<pre><code><code>    qr</code></code></pre>

<p>The subroutine for <code><code>&#39;qr&#39;</code></code> is used wherever the object is interpolated into or used as a regexp, including when it appears on the RHS of a <code><code>=~</code></code> or <code><code>!~</code></code> operator.</p>

<p><code><code>qr</code></code> must return a compiled regexp, or a ref to a compiled regexp (such as <code><code>qr//</code></code> returns), and any further overloading on the return value will be ignored.</p>

</li>
<li><p><i>Iteration</i></p>

<p>If <code><code>&lt;&gt;</code></code> is overloaded then the same implementation is used for both the <i>read-filehandle</i> syntax <code><code>&lt;$var&gt;</code></code> and <i>globbing</i> syntax <code><code><span class="operator">&lt;</span><span class="variable">$</span><span class="operator">{</span><span class="string">var</span><span class="operator">}</span><span class="operator">&gt;</span>
</code></code>.</p>

<p><b>BUGS</b> Even in list context, the iterator is currently called only once and with scalar context.</p>

</li>
<li><p><i>File tests</i></p>

<p>The key <code><code>&#39;-X&#39;</code></code> is used to specify a subroutine to handle all the filetest operators (<code><code>-f</code></code>, <code><code>-x</code></code>, and so on: see <a href="../lib/pods/perlfunc.html#X">&quot;-X&quot; in perlfunc</a> for the full list); it is not possible to overload any filetest operator individually. To distinguish them, the letter following the &#39;-&#39; is passed as the second argument (that is, in the slot that for binary operators is used to pass the second operand).</p>

<p>Calling an overloaded filetest operator does not affect the stat value associated with the special filehandle <code><code>_</code></code>. It still refers to the result of the last <code><code>stat</code></code>, <code><code>lstat</code></code> or unoverloaded filetest.</p>

<p>This overload was introduced in Perl 5.12.</p>

</li>
<li><p><i>Matching</i></p>

<p>The key <code><code>&quot;~~&quot;</code></code> allows you to override the smart matching logic used by the <code><code>~~</code></code> operator and the switch construct (<code><code>given</code></code>/<code><code>when</code></code>). See <a href="../lib/pods/perlsyn.html#Switch-Statements">&quot;Switch Statements&quot; in perlsyn</a> and <a href="../lib/feature.html">feature</a>.</p>

<p>Unusually, the overloaded implementation of the smart match operator does not get full control of the smart match behaviour. In particular, in the following code:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Foo</span><span class="operator">;</span>
    <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'~~'</span> <span class="operator">=&gt;</span> <span class="string">'match'</span><span class="operator">;</span>
    
    <span class="keyword">my</span> <span class="variable">$obj</span> <span class="operator">=</span>  <span class="variable">Foo</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">();</span>
    <span class="variable">$obj</span> <span class="operator">~~</span> <span class="operator">[</span> <span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span> <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>the smart match does <i>not</i> invoke the method call like this:</p>

<pre><code><code>    <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">match</span><span class="operator">(</span><span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">3</span><span class="operator">]</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
</code></code></pre>

<p>rather, the smart match distributive rule takes precedence, so $obj is smart matched against each array element in turn until a match is found, so you may see between one and three of these calls instead:</p>

<pre><code><code>    <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">match</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
    <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">match</span><span class="operator">(</span><span class="number">2</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
    <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">match</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
</code></code></pre>

<p>Consult the match table in <a href="../lib/pods/perlop.html#Smartmatch-Operator">&quot;Smartmatch Operator&quot; in perlop</a> for details of when overloading is invoked.</p>

</li>
<li><p><i>Dereferencing</i></p>

<pre><code><code>    <span class="variable">$</span><span class="operator">{}</span>  <span class="variable">@</span><span class="operator">{}</span>  <span class="variable">%</span><span class="operator">{}</span>  <span class="operator">&amp;{}</span>  <span class="variable">*</span><span class="operator">{}</span>
</code></code></pre>

<p>If these operators are not explicitly overloaded then they work in the normal way, yielding the underlying scalar, array, or whatever stores the object data (or the appropriate error message if the dereference operator doesn&#39;t match it). Defining a catch-all <code><code>&#39;nomethod&#39;</code></code> (see <a href="#nomethod">below</a>) makes no difference to this as the catch-all function will not be called to implement a missing dereference operator.</p>

<p>If a dereference operator is overloaded then it must return a <i>reference</i> of the appropriate type (for example, the subroutine for key <code><code><span class="string">'${}'</span>
</code></code> should return a reference to a scalar, not a scalar), or another object which overloads the operator: that is, the subroutine only determines what is dereferenced and the actual dereferencing is left to Perl. As a special case, if the subroutine returns the object itself then it will not be called again - avoiding infinite recursion.</p>

</li>
<li><p><i>Special</i></p>

<pre><code><code>    nomethod  fallback  =</code></code></pre>

<p>See <a href="#Special-Keys-for-use-overload">&quot;Special Keys for <code><code>use overload</code></code>&quot;</a>.</p>

</li>
</ul>

<h2 id="Magic-Autogeneration">Magic Autogeneration</h2>

<p>If a method for an operation is not found then Perl tries to autogenerate a substitute implementation from the operations that have been defined.</p>

<p>Note: the behaviour described in this section can be disabled by setting <code><code>fallback</code></code> to FALSE (see <a href="#fallback">&quot;fallback&quot;</a>).</p>

<p>In the following tables, numbers indicate priority. For example, the table below states that, if no implementation for <code><code>&#39;!&#39;</code></code> has been defined then Perl will implement it using <code><code>&#39;bool&#39;</code></code> (that is, by inverting the value returned by the method for <code><code>&#39;bool&#39;</code></code>); if boolean conversion is also unimplemented then Perl will use <code><code>&#39;0+&#39;</code></code> or, failing that, <code><code>&#39;&quot;&quot;&#39;</code></code>.</p>

<pre><code><code>    operator | can be autogenerated from
             |
             | 0+   &quot;&quot;   bool   .   x
    =========|==========================
       0+    |       1     2
       &quot;&quot;    |  1          2
       bool  |  1    2
       int   |  1    2     3
       !     |  2    3     1
       qr    |  2    1     3
       .     |  2    1     3
       x     |  2    1     3
       .=    |  3    2     4    1
       x=    |  3    2     4        1
       &lt;&gt;    |  2    1     3
       -X    |  2    1     3</code></code></pre>

<p>Note: The iterator (<code><code>&#39;&lt;&gt;&#39;</code></code>) and file test (<code><code>&#39;-X&#39;</code></code>) operators work as normal: if the operand is not a blessed glob or IO reference then it is converted to a string (using the method for <code><code>&#39;&quot;&quot;&#39;</code></code>, <code><code>&#39;0+&#39;</code></code>, or <code><code>&#39;bool&#39;</code></code>) to be interpreted as a glob or filename.</p>

<pre><code><code>    operator | can be autogenerated from
             |
             |  &lt;   &lt;=&gt;   neg   -=    -
    =========|==========================
       neg   |                        1
       -=    |                        1
       --    |                   1    2
       abs   | a1    a2    b1        b2    [*]
       &lt;     |        1
       &lt;=    |        1
       &gt;     |        1
       &gt;=    |        1
       ==    |        1
       !=    |        1

    * one from [a1, a2] and one from [b1, b2]</code></code></pre>

<p>Just as numeric comparisons can be autogenerated from the method for <code><code>&#39;&lt;=&gt;&#39;</code></code>, string comparisons can be autogenerated from that for <code><code>&#39;cmp&#39;</code></code>:</p>

<pre><code><code>     operators          |  can be autogenerated from
    ====================|===========================
     lt gt le ge eq ne  |  cmp</code></code></pre>

<p>Similarly, autogeneration for keys <code><code>&#39;+=&#39;</code></code> and <code><code>&#39;++&#39;</code></code> is analogous to <code><code>&#39;-=&#39;</code></code> and <code><code>&#39;--&#39;</code></code> above:</p>

<pre><code><code>    operator | can be autogenerated from
             |
             |  +=    +
    =========|==========================
        +=   |        1
        ++   |   1    2</code></code></pre>

<p>And other assignment variations are analogous to <code><code>&#39;+=&#39;</code></code> and <code><code>&#39;-=&#39;</code></code> (and similar to <code><code>&#39;.=&#39;</code></code> and <code><code>&#39;x=&#39;</code></code> above):</p>

<pre><code><code>              operator ||  *= /= %= **= &lt;&lt;= &gt;&gt;= &amp;= ^= |=
    -------------------||--------------------------------
    autogenerated from ||  *  /  %  **  &lt;&lt;  &gt;&gt;  &amp;  ^  |</code></code></pre>

<p>Note also that the copy constructor (key <code><code>&#39;=&#39;</code></code>) may be autogenerated, but only for objects based on scalars. See <a href="#Copy-Constructor">&quot;Copy Constructor&quot;</a>.</p>

<h3 id="Minimal-Set-of-Overloaded-Operations">Minimal Set of Overloaded Operations</h3>

<p>Since some operations can be automatically generated from others, there is a minimal set of operations that need to be overloaded in order to have the complete set of overloaded operations at one&#39;s disposal. Of course, the autogenerated operations may not do exactly what the user expects. The minimal set is:</p>

<pre><code><code>    + - * / % ** &lt;&lt; &gt;&gt; x
    &lt;=&gt; cmp
    &amp; | ^ ~
    atan2 cos sin exp log sqrt int
    &quot;&quot; 0+ bool
    ~~</code></code></pre>

<p>Of the conversions, only one of string, boolean or numeric is needed because each can be generated from either of the other two.</p>

<h2 id="Special-Keys-for">Special Keys for <code><code>use overload</code></code></h2>

<h3 id=""><code><code>nomethod</code></code></h3>

<p>The <code><code>&#39;nomethod&#39;</code></code> key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the <code><code>use overload</code></code> key for that missing method.</p>

<p>For example, if <code><code>$a</code></code> is an object blessed into a package declaring</p>

<pre><code><code>    use overload &#39;nomethod&#39; =&gt; &#39;catch_all&#39;, # ...</code></code></pre>

<p>then the operation</p>

<pre><code><code>    3 + $a</code></code></pre>

<p>could (unless a method is specifically declared for the key <code><code>&#39;+&#39;</code></code>) result in a call</p>

<pre><code><code>    catch_all($a, 3, 1, &#39;+&#39;)</code></code></pre>

<p>See <a href="#How-Perl-Chooses-an-Operator-Implementation">&quot;How Perl Chooses an Operator Implementation&quot;</a>.</p>

<h3 id="1"><code><code>fallback</code></code></h3>

<p>The value assigned to the key <code><code>&#39;fallback&#39;</code></code> tells Perl how hard it should try to find an alternative way to implement a missing operator.</p>

<ul>

<li><p>defined, but FALSE</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">"fallback"</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="comment"># ... ;</span>
</code></code></pre>

<p>This disables <a href="#Magic-Autogeneration">&quot;Magic Autogeneration&quot;</a>.</p>

</li>
<li><p><code><code>undef</code></code></p>

<p>In the default case where no value is explicitly assigned to <code><code>fallback</code></code>, magic autogeneration is enabled.</p>

</li>
<li><p>TRUE</p>

<p>The same as for <code><code>undef</code></code>, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no <code><code>use overload</code></code> directive.</p>

<p>Note: in most cases, particularly the <a href="#Copy-Constructor">&quot;Copy Constructor&quot;</a>, this is unlikely to be appropriate behaviour.</p>

</li>
</ul>

<p>See <a href="#How-Perl-Chooses-an-Operator-Implementation">&quot;How Perl Chooses an Operator Implementation&quot;</a>.</p>

<h3 id="Copy-Constructor">Copy Constructor</h3>

<p>As mentioned <a href="#Mathemagic-Mutators-and-Copy-Constructors">above</a>, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if <code><code>$b</code></code> is mathemagical, and <code><code>&#39;++&#39;</code></code> is overloaded with <code><code>&#39;incr&#39;</code></code>, and <code><code>&#39;=&#39;</code></code> is overloaded with <code><code>&#39;clone&#39;</code></code>, then the code</p>

<pre><code><code>    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="comment"># ... (other code which does not modify $a or $b) ...</span>
    <span class="operator">++</span><span class="variable">$b</span><span class="operator">;</span>
</code></code></pre>

<p>would be executed in a manner equivalent to</p>

<pre><code><code>    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="comment"># ...</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="string">""</span><span class="operator">);</span>
    <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">incr</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="string">""</span><span class="operator">);</span>
</code></code></pre>

<p>Note:</p>

<ul>

<li><p>The subroutine for <code><code>&#39;=&#39;</code></code> does not overload the Perl assignment operator: it is used only to allow mutators to work as described here. (See <a href="#Assignments">&quot;Assignments&quot;</a> above.)</p>

</li>
<li><p>As for other operations, the subroutine implementing &#39;=&#39; is passed three arguments, though the last two are always <code><code>undef</code></code> and <code><code>&#39;&#39;</code></code>.</p>

</li>
<li><p>The copy constructor is called only before a call to a function declared to implement a mutator, for example, if <code><code><span class="operator">++</span><span class="variable">$b</span><span class="operator">;</span>
</code></code> in the code above is effected via a method declared for key <code><code>&#39;++&#39;</code></code> (or &#39;nomethod&#39;, passed <code><code>&#39;++&#39;</code></code> as the fourth argument) or, by autogeneration, <code><code>&#39;+=&#39;</code></code>. It is not called if the increment operation is effected by a call to the method for <code><code>&#39;+&#39;</code></code> since, in the equivalent code,</p>

<pre><code><code>    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="variable">$b</span> <span class="operator">+</span> <span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>the data referred to by <code><code>$a</code></code> is unchanged by the assignment to <code><code>$b</code></code> of a reference to new object data.</p>

</li>
<li><p>The copy constructor is not called if Perl determines that it is unnecessary because there is no other reference to the data being modified.</p>

</li>
<li><p>If <code><code>&#39;fallback&#39;</code></code> is undefined or TRUE then a copy constructor can be autogenerated, but only for objects based on scalars. In other cases it needs to be defined explicitly. Where an object&#39;s data is stored as, for example, an array of scalars, the following might be appropriate:</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'='</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">bless</span> <span class="operator">[</span> <span class="variable">@</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]}</span> <span class="operator">]</span> <span class="operator">},</span>  <span class="comment"># ...</span>
</code></code></pre>

</li>
<li><p>If <code><code>&#39;fallback&#39;</code></code> is TRUE and no copy constructor is defined then, for objects not based on scalars, Perl may silently fall back on simple assignment - that is, assignment of the object reference. In effect, this disables the copy constructor mechanism since no new copy of the object data is created. This is almost certainly not what you want. (It is, however, consistent: for example, Perl&#39;s fallback for the <code><code>++</code></code> operator is to increment the reference itself.)</p>

</li>
</ul>

<h2 id="How-Perl-Chooses-an-Operator-Implementation">How Perl Chooses an Operator Implementation</h2>

<p>Which is checked first, <code><code>nomethod</code></code> or <code><code>fallback</code></code>? If the two operands of an operator are of different types and both overload the operator, which implementation is used? The following are the precedence rules:</p>

<ol>

<li><p>If the first operand has declared a subroutine to overload the operator then use that implementation.</p>

</li>
<li><p>Otherwise, if fallback is TRUE or undefined for the first operand then see if the <a href="#Magic-Autogeneration">rules for autogeneration</a> allows another of its operators to be used instead.</p>

</li>
<li><p>Unless the operator is an assignment (<code><code>+=</code></code>, <code><code>-=</code></code>, etc.), repeat step (1) in respect of the second operand.</p>

</li>
<li><p>Repeat Step (2) in respect of the second operand.</p>

</li>
<li><p>If the first operand has a &quot;nomethod&quot; method then use that.</p>

</li>
<li><p>If the second operand has a &quot;nomethod&quot; method then use that.</p>

</li>
<li><p>If <code><code>fallback</code></code> is TRUE for both operands then perform the usual operation for the operator, treating the operands as numbers, strings, or booleans as appropriate for the operator (see note).</p>

</li>
<li><p>Nothing worked - die.</p>

</li>
</ol>

<p>Where there is only one operand (or only one operand with overloading) the checks in respect of the other operand above are skipped.</p>

<p>There are exceptions to the above rules for dereference operations (which, if Step 1 fails, always fall back to the normal, built-in implementations - see Dereferencing), and for <code><code>~~</code></code> (which has its own set of rules - see <code><code>Matching</code></code> under <a href="#Overloadable-Operations">&quot;Overloadable Operations&quot;</a> above).</p>

<p>Note on Step 7: some operators have a different semantic depending on the type of their operands. As there is no way to instruct Perl to treat the operands as, e.g., numbers instead of strings, the result here may not be what you expect. See <a href="#BUGS-AND-PITFALLS">&quot;BUGS AND PITFALLS&quot;</a>.</p>

<h2 id="Losing-Overloading">Losing Overloading</h2>

<p>The restriction for the comparison operation is that even if, for example, <code><code>cmp</code></code> should return a blessed reference, the autogenerated <code><code>lt</code></code> function will produce only a standard logical value based on the numerical value of the result of <code><code>cmp</code></code>. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</p>

<p>Similarly, <code><code>.=</code></code> and <code><code>x=</code></code> operators lose their mathemagical properties if the string conversion substitution is applied.</p>

<p>When you chop() a mathemagical object it is promoted to a string and its mathemagical properties are lost. The same can happen with other operations as well.</p>

<h2 id="Inheritance-and-Overloading">Inheritance and Overloading</h2>

<p>Overloading respects inheritance via the @ISA hierarchy. Inheritance interacts with overloading in two ways.</p>

<dl>

<dt id="Method-names-in-the-use-overload-directive">Method names in the <code><code>use overload</code></code> directive</dt>
<dd>

<p>If <code><code>value</code></code> in</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">key</span> <span class="operator">=&gt;</span> <span class="variable">value</span><span class="operator">;</span>
</code></code></pre>

<p>is a string, it is interpreted as a method name - which may (in the usual way) be inherited from another class.</p>

</dd>
<dt id="Overloading-of-an-operation-is-inherited-by-derived-classes">Overloading of an operation is inherited by derived classes</dt>
<dd>

<p>Any class derived from an overloaded class is also overloaded and inherits its operator implementations. If the same operator is overloaded in more than one ancestor then the implementation is determined by the usual inheritance rules.</p>

<p>For example, if <code><code>A</code></code> inherits from <code><code>B</code></code> and <code><code>C</code></code> (in that order), <code><code>B</code></code> overloads <code><code>+</code></code> with <code><code>\&amp;D::plus_sub</code></code>, and <code><code>C</code></code> overloads <code><code>+</code></code> by <code><code>&quot;plus_meth&quot;</code></code>, then the subroutine <code><code>D::plus_sub</code></code> will be called to implement operation <code><code>+</code></code> for an object in package <code><code>A</code></code>.</p>

</dd>
</dl>

<p>Note that since the value of the <code><code>fallback</code></code> key is not a subroutine, its inheritance is not governed by the above rules. In the current implementation, the value of <code><code>fallback</code></code> in the first overloaded ancestor is used, but this is accidental and subject to change.</p>

<h2 id="Run-time-Overloading">Run-time Overloading</h2>

<p>Since all <code><code>use</code></code> directives are executed at compile-time, the only way to change overloading during run-time is to</p>

<pre><code><code>    <span class="keyword">eval</span> <span class="string">'use overload "+" =&gt; \&amp;addmethod'</span><span class="operator">;</span>
</code></code></pre>

<p>You can also use</p>

<pre><code><code>    <span class="keyword">eval</span> <span class="string">'no overload "+", "--", "&lt;="'</span><span class="operator">;</span>
</code></code></pre>

<p>though the use of these constructs during run-time is questionable.</p>

<h2 id="Public-Functions">Public Functions</h2>

<p>Package <code><code>overload.pm</code></code> provides the following public functions:</p>

<dl>

<dt id="overload::StrVal-arg-">overload::StrVal(arg)</dt>
<dd>

<p>Gives the string value of <code><code>arg</code></code> as in the absence of stringify overloading. If you are using this to get the address of a reference (useful for checking if two references point to the same thing) then you may be better off using <code><code>Scalar::Util::refaddr()</code></code>, which is faster.</p>

</dd>
<dt id="overload::Overloaded-arg-">overload::Overloaded(arg)</dt>
<dd>

<p>Returns true if <code><code>arg</code></code> is subject to overloading of some operations.</p>

</dd>
<dt id="overload::Method-obj-op-">overload::Method(obj,op)</dt>
<dd>

<p>Returns <code><code>undef</code></code> or a reference to the method that implements <code><code>op</code></code>.</p>

</dd>
</dl>

<h2 id="Overloading-Constants">Overloading Constants</h2>

<p>For some applications, the Perl parser mangles constants too much. It is possible to hook into this process via <code><code>overload::constant()</code></code> and <code><code>overload::remove_constant()</code></code> functions.</p>

<p>These functions take a hash as an argument. The recognized keys of this hash are:</p>

<dl>

<dt id="integer">integer</dt>
<dd>

<p>to overload integer constants,</p>

</dd>
<dt id="float">float</dt>
<dd>

<p>to overload floating point constants,</p>

</dd>
<dt id="binary">binary</dt>
<dd>

<p>to overload octal and hexadecimal constants,</p>

</dd>
<dt id="q">q</dt>
<dd>

<p>to overload <code><code>q</code></code>-quoted strings, constant pieces of <code><code>qq</code></code>- and <code><code>qx</code></code>-quoted strings and here-documents,</p>

</dd>
<dt id="qr">qr</dt>
<dd>

<p>to overload constant pieces of regular expressions.</p>

</dd>
</dl>

<p>The corresponding values are references to functions which take three arguments: the first one is the <i>initial</i> string form of the constant, the second one is how Perl interprets this constant, the third one is how the constant is used. Note that the initial string form does not contain string delimiters, and has backslashes in backslash-delimiter combinations stripped (thus the value of delimiter is not relevant for processing of this string). The return value of this function is how this constant is going to be interpreted by Perl. The third argument is undefined unless for overloaded <code><code>q</code></code>- and <code><code>qr</code></code>- constants, it is <code><code>q</code></code> in single-quote context (comes from strings, regular expressions, and single-quote HERE documents), it is <code><code>tr</code></code> for arguments of <code><code>tr</code></code>/<code><code>y</code></code> operators, it is <code><code>s</code></code> for right-hand side of <code><code>s</code></code>-operator, and it is <code><code>qq</code></code> otherwise.</p>

<p>Since an expression <code><code>&quot;ab$cd,,&quot;</code></code> is just a shortcut for <code><code>&#39;ab&#39; . $cd . &#39;,,&#39;</code></code>, it is expected that overloaded constant strings are equipped with reasonable overloaded catenation operator, otherwise absurd results will result. Similarly, negative numbers are considered as negations of positive constants.</p>

<p>Note that it is probably meaningless to call the functions overload::constant() and overload::remove_constant() from anywhere but import() and unimport() methods. From these methods they may be called as</p>

<pre><code><code>    <span class="keyword">sub</span><span class="variable"> import </span><span class="operator">{</span>
       <span class="keyword">shift</span><span class="operator">;</span>
       <span class="keyword">return</span> <span class="keyword">unless</span> <span class="variable">@_</span><span class="operator">;</span>
       <span class="keyword">die</span> <span class="string">"unknown import: </span><span class="variable">@_</span><span class="string">"</span> <span class="keyword">unless</span> <span class="variable">@_</span> <span class="operator">==</span> <span class="number">1</span> <span class="keyword">and</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="keyword">eq</span> <span class="string">':constant'</span><span class="operator">;</span>
       <span class="variable">overload::constant</span> <span class="string">integer</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">Math::BigInt</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="keyword">shift</span><span class="operator">)};</span>
    <span class="operator">}</span>
</code></code></pre>

<h1 id="IMPLEMENTATION">IMPLEMENTATION</h1>

<p>What follows is subject to change RSN.</p>

<p>The table of methods for all operations is cached in magic for the symbol table hash for the package. The cache is invalidated during processing of <code><code>use overload</code></code>, <code><code>no overload</code></code>, new function definitions, and changes in @ISA. However, this invalidation remains unprocessed until the next <code><code>bless</code></code>ing into the package. Hence if you want to change overloading structure dynamically, you&#39;ll need an additional (fake) <code><code>bless</code></code>ing to update the table.</p>

<p>(Every SVish thing has a magic queue, and magic is an entry in that queue. This is how a single variable may participate in multiple forms of magic simultaneously. For instance, environment variables regularly have two forms at once: their %ENV magic and their taint magic. However, the magic which implements overloading is applied to the stashes, which are rarely used directly, thus should not slow down Perl.)</p>

<p>If an object belongs to a package using overload, it carries a special flag. Thus the only speed penalty during arithmetic operations without overloading is the checking of this flag.</p>

<p>In fact, if <code><code>use overload</code></code> is not present, there is almost no overhead for overloadable operations, so most programs should not suffer measurable performance penalties. A considerable effort was made to minimize the overhead when overload is used in some package, but the arguments in question do not belong to packages using overload. When in doubt, test your speed with <code><code>use overload</code></code> and without it. So far there have been no reports of substantial speed degradation if Perl is compiled with optimization turned on.</p>

<p>There is no size penalty for data if overload is not used. The only size penalty if overload is used in some package is that <i>all</i> the packages acquire a magic during the next <code><code>bless</code></code>ing into the package. This magic is three-words-long for packages without overloading, and carries the cache table if the package is overloaded.</p>

<p>It is expected that arguments to methods that are not explicitly supposed to be changed are constant (but this is not enforced).</p>

<h1 id="COOKBOOK">COOKBOOK</h1>

<p>Please add examples to what follows!</p>

<h2 id="Two-face-Scalars">Two-face Scalars</h2>

<p>Put this in <i>two_face.pm</i> in your Perl library directory:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">two_face</span><span class="operator">;</span>             <span class="comment"># Scalars with separate string and</span>
                                <span class="comment"># numeric values.</span>
  <span class="keyword">sub</span><span class="variable"> new </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">bless</span> <span class="operator">[</span><span class="variable">@_</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$p</span> <span class="operator">}</span>
  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'""'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">str</span><span class="operator">,</span> <span class="string">'0+'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">num</span><span class="operator">,</span> <span class="string">fallback</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> num </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> str </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">}</span>
</code></code></pre>

<p>Use it as follows:</p>

<pre><code><code>  <span class="keyword">require</span> <span class="variable">two_face</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$seven</span> <span class="operator">=</span> <span class="variable">two_face</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="string">"vii"</span><span class="operator">,</span> <span class="number">7</span><span class="operator">);</span>
  <span class="keyword">printf</span> <span class="string">"seven=</span><span class="variable">$seven</span><span class="string">, seven=%d, eight=%d\n"</span><span class="operator">,</span> <span class="variable">$seven</span><span class="operator">,</span> <span class="variable">$seven</span><span class="operator">+</span><span class="number">1</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"seven contains 'i'\n"</span> <span class="keyword">if</span> <span class="variable">$seven</span> <span class="operator">=~</span> <span class="regex">/i/</span><span class="operator">;</span>
</code></code></pre>

<p>(The second line creates a scalar which has both a string value, and a numeric value.) This prints:</p>

<pre><code><code>  seven=vii, seven=7, eight=8
  seven contains &#39;i&#39;</code></code></pre>

<h2 id="Two-face-References">Two-face References</h2>

<p>Suppose you want to create an object which is accessible as both an array reference and a hash reference.</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">two_refs</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'%{}'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">gethash</span><span class="operator">,</span> <span class="string">'@{}'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="operator">$ {</span><span class="keyword">shift</span><span class="operator">()}</span> <span class="operator">};</span>
  <span class="keyword">sub</span><span class="variable"> new </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="operator">\</span> <span class="operator">[</span><span class="variable">@_</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> gethash </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">%h</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">tie</span> <span class="variable">%h</span><span class="operator">,</span> <span class="keyword">ref</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">$self</span><span class="operator">;</span>
    <span class="operator">\</span><span class="variable">%h</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> TIEHASH </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">bless</span> <span class="operator">\</span> <span class="keyword">shift</span><span class="operator">,</span> <span class="variable">$p</span> <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">%fields</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$fields</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$i</span><span class="operator">++</span> <span class="keyword">foreach</span> <span class="string">qw{zero one two three}</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> STORE </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="variable">$fields</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">defined</span> <span class="variable">$key</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Out of band access"</span><span class="operator">;</span>
    <span class="variable">$$self</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="variable">$key</span><span class="operator">]</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> FETCH </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="variable">$fields</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">defined</span> <span class="variable">$key</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Out of band access"</span><span class="operator">;</span>
    <span class="variable">$$self</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="variable">$key</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Now one can access an object using both the array and hash syntax:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$bar</span> <span class="operator">=</span> <span class="variable">two_refs</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">3</span><span class="operator">,</span><span class="number">4</span><span class="operator">,</span><span class="number">5</span><span class="operator">,</span><span class="number">6</span><span class="operator">);</span>
  <span class="variable">$bar</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">=</span> <span class="number">11</span><span class="operator">;</span>
  <span class="variable">$bar</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">two</span><span class="operator">}</span> <span class="operator">==</span> <span class="number">11</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">'bad hash fetch'</span><span class="operator">;</span>
</code></code></pre>

<p>Note several important features of this example. First of all, the <i>actual</i> type of $bar is a scalar reference, and we do not overload the scalar dereference. Thus we can get the <i>actual</i> non-overloaded contents of $bar by just using <code><code>$$bar</code></code> (what we do in functions which overload dereference). Similarly, the object returned by the TIEHASH() method is a scalar reference.</p>

<p>Second, we create a new tied hash each time the hash syntax is used. This allows us not to worry about a possibility of a reference loop, which would lead to a memory leak.</p>

<p>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is <i>implemented</i> as a hash itself, the only problem one has to circumvent is how to access this <i>actual</i> hash (as opposed to the <i>virtual</i> hash exhibited by the overloaded dereference operator). Here is one possible fetching routine:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> access_hash </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$self</span><span class="operator">,</span> <span class="variable">$key</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">shift</span><span class="operator">,</span> <span class="keyword">shift</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$class</span> <span class="operator">=</span> <span class="keyword">ref</span> <span class="variable">$self</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="variable">$self</span><span class="operator">,</span> <span class="string">'overload::dummy'</span><span class="operator">;</span> <span class="comment"># Disable overloading of %{}</span>
    <span class="keyword">my</span> <span class="variable">$out</span> <span class="operator">=</span> <span class="variable">$self</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="variable">$key</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">$class</span><span class="operator">;</span>        <span class="comment"># Restore overloading</span>
    <span class="variable">$out</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>To remove creation of the tied hash on each access, one may an extra level of indirection which allows a non-circular structure of references:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">two_refs1</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'%{}'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">},</span>
               <span class="string">'@{}'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">};</span>
  <span class="keyword">sub</span><span class="variable"> new </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$a</span> <span class="operator">=</span> <span class="operator">[</span><span class="variable">@_</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">%h</span><span class="operator">;</span>
    <span class="keyword">tie</span> <span class="variable">%h</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="operator">\</span> <span class="operator">[</span><span class="variable">$a</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%h</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> gethash </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">%h</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">tie</span> <span class="variable">%h</span><span class="operator">,</span> <span class="keyword">ref</span> <span class="variable">$self</span><span class="operator">,</span> <span class="variable">$self</span><span class="operator">;</span>
    <span class="operator">\</span><span class="variable">%h</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">sub</span><span class="variable"> TIEHASH </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">bless</span> <span class="operator">\</span> <span class="keyword">shift</span><span class="operator">,</span> <span class="variable">$p</span> <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">%fields</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$i</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$fields</span><span class="operator">{</span><span class="variable">$_</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$i</span><span class="operator">++</span> <span class="keyword">foreach</span> <span class="string">qw{zero one two three}</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> STORE </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="variable">$fields</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">defined</span> <span class="variable">$key</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Out of band access"</span><span class="operator">;</span>
    <span class="variable">$a</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="variable">$key</span><span class="operator">]</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> FETCH </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$key</span> <span class="operator">=</span> <span class="variable">$fields</span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">defined</span> <span class="variable">$key</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Out of band access"</span><span class="operator">;</span>
    <span class="variable">$a</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="variable">$key</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Now if $baz is overloaded like this, then <code><code>$baz</code></code> is a reference to a reference to the intermediate array, which keeps a reference to an actual array, and the access hash. The tie()ing object for the access hash is a reference to a reference to the actual array, so</p>

<ul>

<li><p>There are no loops of references.</p>

</li>
<li><p>Both &quot;objects&quot; which are blessed into the class <code><code>two_refs1</code></code> are references to a reference to an array, thus references to a <i>scalar</i>. Thus the accessor expression <code><code>$$foo-&gt;[$ind]</code></code> involves no overloaded operations.</p>

</li>
</ul>

<h2 id="Symbolic-Calculator">Symbolic Calculator</h2>

<p>Put this in <i>symbolic.pm</i> in your Perl library directory:</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">symbolic</span><span class="operator">;</span>             <span class="comment"># Primitive symbolic calculator</span>
  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">nomethod</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">wrap</span><span class="operator">;</span>
  
  <span class="keyword">sub</span><span class="variable"> new </span><span class="operator">{</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">bless</span> <span class="operator">[</span><span class="string">'n'</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">]</span> <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> wrap </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">,</span> <span class="variable">$inv</span><span class="operator">,</span> <span class="variable">$meth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">(</span><span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$other</span><span class="operator">,</span> <span class="variable">$obj</span><span class="operator">)</span> <span class="keyword">if</span> <span class="variable">$inv</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="operator">[</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>This module is very unusual as overloaded modules go: it does not provide any usual overloaded operators, instead it provides an implementation for <a><code><code>nomethod</code></code></a>. In this example the <code><code>nomethod</code></code> subroutine returns an object which encapsulates operations done over the objects: <code><code>symbolic-&gt;new(3)</code></code> contains <code><code>[&#39;n&#39;, 3]</code></code>, <code><code>2 + symbolic-&gt;new(3)</code></code> contains <code><code>[&#39;+&#39;, 2, [&#39;n&#39;, 3]]</code></code>.</p>

<p>Here is an example of the script which &quot;calculates&quot; the side of circumscribed octagon using the above package:</p>

<pre><code><code>  <span class="keyword">require</span> <span class="variable">symbolic</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$iter</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>                 <span class="comment"># 2**($iter+2) = 8</span>
  <span class="keyword">my</span> <span class="variable">$side</span> <span class="operator">=</span> <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$iter</span><span class="operator">;</span>
  
  <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$cnt</span><span class="operator">--)</span> <span class="operator">{</span>
    <span class="variable">$side</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">sqrt</span><span class="operator">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">$side</span><span class="operator">**</span><span class="number">2</span><span class="operator">)</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">)/</span><span class="variable">$side</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">print</span> <span class="string">"OK\n"</span><span class="operator">;</span>
</code></code></pre>

<p>The value of $side is</p>

<pre><code><code>  [&#39;/&#39;, [&#39;-&#39;, [&#39;sqrt&#39;, [&#39;+&#39;, 1, [&#39;**&#39;, [&#39;n&#39;, 1], 2]],
                       undef], 1], [&#39;n&#39;, 1]]</code></code></pre>

<p>Note that while we obtained this value using a nice little script, there is no simple way to <i>use</i> this value. In fact this value may be inspected in debugger (see <a href="../lib/pods/perldebug.html">perldebug</a>), but only if <code><code>bareStringify</code></code> <b>O</b>ption is set, and not via <code><code>p</code></code> command.</p>

<p>If one attempts to print this value, then the overloaded operator <code><code>&quot;&quot;</code></code> will be called, which will call <code><code>nomethod</code></code> operator. The result of this operator will be stringified again, but this result is again of type <code><code>symbolic</code></code>, which will lead to an infinite loop.</p>

<p>Add a pretty-printer method to the module <i>symbolic.pm</i>:</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> pretty </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span><span class="operator">+</span><span class="keyword">shift</span><span class="operator">}</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="string">'u'</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="string">'u'</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">pretty</span> <span class="keyword">if</span> <span class="keyword">ref</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">pretty</span> <span class="keyword">if</span> <span class="keyword">ref</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="string">"[</span><span class="variable">$meth</span><span class="string"> </span><span class="variable">$a</span><span class="string"> </span><span class="variable">$b</span><span class="string">]"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Now one can finish the script by</p>

<pre><code><code>  <span class="keyword">print</span> <span class="string">"side = "</span><span class="operator">,</span> <span class="variable">$side</span><span class="operator">-&gt;</span><span class="variable">pretty</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>The method <code><code>pretty</code></code> is doing object-to-string conversion, so it is natural to overload the operator <code><code>&quot;&quot;</code></code> using this method. However, inside such a method it is not necessary to pretty-print the <i>components</i> $a and $b of an object. In the above subroutine <code><code>&quot;[$meth $a $b]&quot;</code></code> is a catenation of some strings and components $a and $b. If these components use overloading, the catenation operator will look for an overloaded operator <code><code>.</code></code>; if not present, it will look for an overloaded operator <code><code>&quot;&quot;</code></code>. Thus it is enough to use</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">nomethod</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">wrap</span><span class="operator">,</span> <span class="string">'""'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">str</span><span class="operator">;</span>
  <span class="keyword">sub</span><span class="variable"> str </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span><span class="operator">+</span><span class="keyword">shift</span><span class="operator">}</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="string">'u'</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="string">'u'</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$b</span><span class="operator">;</span>
    <span class="string">"[</span><span class="variable">$meth</span><span class="string"> </span><span class="variable">$a</span><span class="string"> </span><span class="variable">$b</span><span class="string">]"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Now one can change the last line of the script to</p>

<pre><code><code>  <span class="keyword">print</span> <span class="string">"side = </span><span class="variable">$side</span><span class="string">\n"</span><span class="operator">;</span>
</code></code></pre>

<p>which outputs</p>

<pre><code><code>  side = [/ [- [sqrt [+ 1 [** [n 1 u] 2]] u] 1] [n 1 u]]</code></code></pre>

<p>and one can inspect the value in debugger using all the possible methods.</p>

<p>Something is still amiss: consider the loop variable $cnt of the script. It was a number, not an object. We cannot make this value of type <code><code>symbolic</code></code>, since then the loop will not terminate.</p>

<p>Indeed, to terminate the cycle, the $cnt should become false. However, the operator <code><code>bool</code></code> for checking falsity is overloaded (this time via overloaded <code><code>&quot;&quot;</code></code>), and returns a long string, thus any object of type <code><code>symbolic</code></code> is true. To overcome this, we need a way to compare an object to 0. In fact, it is easier to write a numeric conversion routine.</p>

<p>Here is the text of <i>symbolic.pm</i> with such a routine added (and slightly modified str()):</p>

<pre><code><code>  <span class="keyword">package</span> <span class="variable">symbolic</span><span class="operator">;</span>             <span class="comment"># Primitive symbolic calculator</span>
  <span class="keyword">use</span> <span class="variable">overload</span>
    <span class="string">nomethod</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">wrap</span><span class="operator">,</span> <span class="string">'""'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">str</span><span class="operator">,</span> <span class="string">'0+'</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">num</span><span class="operator">;</span>
  
  <span class="keyword">sub</span><span class="variable"> new </span><span class="operator">{</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">bless</span> <span class="operator">[</span><span class="string">'n'</span><span class="operator">,</span> <span class="variable">@_</span><span class="operator">]</span> <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> wrap </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">,</span> <span class="variable">$inv</span><span class="operator">,</span> <span class="variable">$meth</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
    <span class="operator">(</span><span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$other</span><span class="operator">,</span> <span class="variable">$obj</span><span class="operator">)</span> <span class="keyword">if</span> <span class="variable">$inv</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="operator">[</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$other</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> str </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span><span class="operator">+</span><span class="keyword">shift</span><span class="operator">}</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="string">'u'</span> <span class="keyword">unless</span> <span class="keyword">defined</span> <span class="variable">$a</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="string">"[</span><span class="variable">$meth</span><span class="string"> </span><span class="variable">$a</span><span class="string"> </span><span class="variable">$b</span><span class="string">]"</span><span class="operator">;</span>
    <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
      <span class="string">"[</span><span class="variable">$meth</span><span class="string"> </span><span class="variable">$a</span><span class="string">]"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">%subr</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">n</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">},</span>
               <span class="string">sqrt</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">sqrt</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">},</span>
               <span class="string">'-'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span> <span class="operator">-</span> <span class="keyword">shift</span><span class="operator">()},</span>
               <span class="string">'+'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span> <span class="operator">+</span> <span class="keyword">shift</span><span class="operator">()},</span>
               <span class="string">'/'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span> <span class="operator">/</span> <span class="keyword">shift</span><span class="operator">()},</span>
               <span class="string">'*'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span> <span class="operator">*</span> <span class="keyword">shift</span><span class="operator">()},</span>
               <span class="string">'**'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="keyword">shift</span><span class="operator">()</span> <span class="operator">**</span> <span class="keyword">shift</span><span class="operator">()},</span>
             <span class="operator">);</span>
  <span class="keyword">sub</span><span class="variable"> num </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$meth</span><span class="operator">,</span> <span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@</span><span class="operator">{</span><span class="operator">+</span><span class="keyword">shift</span><span class="operator">}</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$subr</span> <span class="operator">=</span> <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$meth</span><span class="operator">}</span>
      <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Do not know how to (</span><span class="variable">$meth</span><span class="string">) in symbolic"</span><span class="operator">;</span>
    <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">num</span> <span class="keyword">if</span> <span class="keyword">ref</span> <span class="variable">$a</span> <span class="keyword">eq</span> <span class="keyword">__PACKAGE__</span><span class="operator">;</span>
    <span class="variable">$b</span> <span class="operator">=</span> <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">num</span> <span class="keyword">if</span> <span class="keyword">ref</span> <span class="variable">$b</span> <span class="keyword">eq</span> <span class="keyword">__PACKAGE__</span><span class="operator">;</span>
    <span class="variable">$subr</span><span class="operator">-&gt;(</span><span class="variable">$a</span><span class="operator">,</span><span class="variable">$b</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>All the work of numeric conversion is done in %subr and num(). Of course, %subr is not complete, it contains only operators used in the example below. Here is the extra-credit question: why do we need an explicit recursion in num()? (Answer is at the end of this section.)</p>

<p>Use this module like this:</p>

<pre><code><code>  <span class="keyword">require</span> <span class="variable">symbolic</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$iter</span> <span class="operator">=</span> <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>  <span class="comment"># 16-gon</span>
  <span class="keyword">my</span> <span class="variable">$side</span> <span class="operator">=</span> <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$iter</span><span class="operator">;</span>
  
  <span class="keyword">while</span> <span class="operator">(</span><span class="variable">$cnt</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$cnt</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">;</span>            <span class="comment"># Mutator '--' not implemented</span>
    <span class="variable">$side</span> <span class="operator">=</span> <span class="operator">(</span><span class="keyword">sqrt</span><span class="operator">(</span><span class="number">1</span> <span class="operator">+</span> <span class="variable">$side</span><span class="operator">**</span><span class="number">2</span><span class="operator">)</span> <span class="operator">-</span> <span class="number">1</span><span class="operator">)/</span><span class="variable">$side</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">printf</span> <span class="string">"%s=%f\n"</span><span class="operator">,</span> <span class="variable">$side</span><span class="operator">,</span> <span class="variable">$side</span><span class="operator">;</span>
  <span class="keyword">printf</span> <span class="string">"pi=%f\n"</span><span class="operator">,</span> <span class="variable">$side</span><span class="operator">*(</span><span class="number">2</span><span class="operator">**(</span><span class="variable">$iter</span><span class="operator">+</span><span class="number">2</span><span class="operator">));</span>
</code></code></pre>

<p>It prints (without so many line breaks)</p>

<pre><code><code>  [/ [- [sqrt [+ 1 [** [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1]
                          [n 1]] 2]]] 1]
     [/ [- [sqrt [+ 1 [** [n 1] 2]]] 1] [n 1]]]=0.198912
  pi=3.182598</code></code></pre>

<p>The above module is very primitive. It does not implement mutator methods (<code><code>++</code></code>, <code><code>-=</code></code> and so on), does not do deep copying (not required without mutators!), and implements only those arithmetic operations which are used in the example.</p>

<p>To implement most arithmetic operations is easy; one should just use the tables of operations, and change the code which fills %subr to</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">%subr</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'n'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">}</span> <span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="variable">$overload::ops</span><span class="operator">{</span><span class="string">with_assign</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$subr</span><span class="operator">{</span><span class="string">"</span><span class="variable">$op</span><span class="string">="</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {shift() </span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">@bins</span> <span class="operator">=</span> <span class="string">qw(binary 3way_comparison num_comparison str_comparison)</span><span class="operator">;</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="string">"</span><span class="variable">@overload</span><span class="string">::ops{ </span><span class="variable">@bins</span><span class="string"> }"</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {shift() </span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="string">"</span><span class="variable">@overload</span><span class="string">::ops{qw(unary func)}"</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"defining '</span><span class="variable">$op</span><span class="string">'\n"</span><span class="operator">;</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {</span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Since subroutines implementing assignment operators are not required to modify their operands (see <a href="#Overloadable-Operations">&quot;Overloadable Operations&quot;</a> above), we do not need anything special to make <code><code>+=</code></code> and friends work, besides adding these operators to %subr and defining a copy constructor (needed since Perl has no way to know that the implementation of <code><code>&#39;+=&#39;</code></code> does not mutate the argument - see <a href="#Copy-Constructor">&quot;Copy Constructor&quot;</a>).</p>

<p>To implement a copy constructor, add <code><code>&#39;=&#39; =&gt; \&amp;cpy</code></code> to <code><code>use overload</code></code> line, and code (this code assumes that mutators change things one level deep only, so recursive copying is not needed):</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> cpy </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$self</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="keyword">bless</span> <span class="operator">[</span><span class="variable">@$self</span><span class="operator">]</span><span class="operator">,</span> <span class="keyword">ref</span> <span class="variable">$self</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>To make <code><code>++</code></code> and <code><code>--</code></code> work, we need to implement actual mutators, either directly, or in <code><code>nomethod</code></code>. We continue to do things inside <code><code>nomethod</code></code>, thus add</p>

<pre><code><code>    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$meth</span> <span class="keyword">eq</span> <span class="string">'++'</span> <span class="keyword">or</span> <span class="variable">$meth</span> <span class="keyword">eq</span> <span class="string">'--'</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">@$obj</span> <span class="operator">=</span> <span class="operator">(</span><span class="variable">$meth</span><span class="operator">,</span> <span class="operator">(</span><span class="keyword">bless</span> <span class="operator">[</span><span class="variable">@$obj</span><span class="operator">]</span><span class="operator">),</span> <span class="number">1</span><span class="operator">);</span> <span class="comment"># Avoid circular reference</span>
      <span class="keyword">return</span> <span class="variable">$obj</span><span class="operator">;</span>
    <span class="operator">}</span>
</code></code></pre>

<p>after the first line of wrap(). This is not a most effective implementation, one may consider</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> inc </span><span class="operator">{</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">=</span> <span class="keyword">bless</span> <span class="operator">[</span><span class="string">'++'</span><span class="operator">,</span> <span class="keyword">shift</span><span class="operator">,</span> <span class="number">1</span><span class="operator">]</span><span class="operator">;</span> <span class="operator">}</span>
</code></code></pre>

<p>instead.</p>

<p>As a final remark, note that one can fill %subr by</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">%subr</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'n'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">}</span> <span class="operator">);</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="variable">$overload::ops</span><span class="operator">{</span><span class="string">with_assign</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$subr</span><span class="operator">{</span><span class="string">"</span><span class="variable">$op</span><span class="string">="</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {shift() </span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">my</span> <span class="variable">@bins</span> <span class="operator">=</span> <span class="string">qw(binary 3way_comparison num_comparison str_comparison)</span><span class="operator">;</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="string">"</span><span class="variable">@overload</span><span class="string">::ops{ </span><span class="variable">@bins</span><span class="string"> }"</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {shift() </span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">foreach</span> <span class="keyword">my</span> <span class="variable">$op</span> <span class="operator">(</span><span class="keyword">split</span> <span class="string">" "</span><span class="operator">,</span> <span class="string">"</span><span class="variable">@overload</span><span class="string">::ops{qw(unary func)}"</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$subr</span><span class="operator">{</span><span class="variable">$op</span><span class="operator">}</span> <span class="operator">=</span> <span class="keyword">eval</span> <span class="string">"sub {</span><span class="variable">$op</span><span class="string"> shift()}"</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="variable">$subr</span><span class="operator">{</span><span class="string">'++'</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$subr</span><span class="operator">{</span><span class="string">'+'</span><span class="operator">}</span><span class="operator">;</span>
  <span class="variable">$subr</span><span class="operator">{</span><span class="string">'--'</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">$subr</span><span class="operator">{</span><span class="string">'-'</span><span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>This finishes implementation of a primitive symbolic calculator in 50 lines of Perl code. Since the numeric values of subexpressions are not cached, the calculator is very slow.</p>

<p>Here is the answer for the exercise: In the case of str(), we need no explicit recursion since the overloaded <code><code>.</code></code>-operator will fall back to an existing overloaded operator <code><code>&quot;&quot;</code></code>. Overloaded arithmetic operators <i>do not</i> fall back to numeric conversion if <code><code>fallback</code></code> is not explicitly requested. Thus without an explicit recursion num() would convert <code><code>[&#39;+&#39;, $a, $b]</code></code> to <code><code>$a + $b</code></code>, which would just rebuild the argument of num().</p>

<p>If you wonder why defaults for conversion are different for str() and num(), note how easy it was to write the symbolic calculator. This simplicity is due to an appropriate choice of defaults. One extra note: due to the explicit recursion num() is more fragile than sym(): we need to explicitly check for the type of $a and $b. If components $a and $b happen to be of some related type, this may lead to problems.</p>

<h2 id="Really-Symbolic-Calculator"><i>Really</i> Symbolic Calculator</h2>

<p>One may wonder why we call the above calculator symbolic. The reason is that the actual calculation of the value of expression is postponed until the value is <i>used</i>.</p>

<p>To see it in action, add a method</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> STORE </span><span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$obj</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
    <span class="variable">$#$obj</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="variable">@$obj</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span> <span class="operator">=</span> <span class="operator">(</span><span class="string">'='</span><span class="operator">,</span> <span class="keyword">shift</span><span class="operator">);</span>
  <span class="operator">}</span>
</code></code></pre>

<p>to the package <code><code>symbolic</code></code>. After this change one can do</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$a</span> <span class="operator">=</span> <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">3</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$b</span> <span class="operator">=</span> <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="number">4</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$c</span> <span class="operator">=</span> <span class="keyword">sqrt</span><span class="operator">(</span><span class="variable">$a</span><span class="operator">**</span><span class="number">2</span> <span class="operator">+</span> <span class="variable">$b</span><span class="operator">**</span><span class="number">2</span><span class="operator">);</span>
</code></code></pre>

<p>and the numeric value of $c becomes 5. However, after calling</p>

<pre><code><code>  <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="number">12</span><span class="operator">);</span>  <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">STORE</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span>
</code></code></pre>

<p>the numeric value of $c becomes 13. There is no doubt now that the module symbolic provides a <i>symbolic</i> calculator indeed.</p>

<p>To hide the rough edges under the hood, provide a tie()d interface to the package <code><code>symbolic</code></code>. Add methods</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> TIESCALAR </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$pack</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="variable">$pack</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span><span class="variable">@_</span><span class="operator">)</span> <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> FETCH </span><span class="operator">{</span> <span class="keyword">shift</span> <span class="operator">}</span>
  <span class="keyword">sub</span><span class="variable"> nop </span><span class="operator">{</span>  <span class="operator">}</span>          <span class="comment"># Around a bug</span>
</code></code></pre>

<p>(the bug, fixed in Perl 5.14, is described in <a href="#BUGS">&quot;BUGS&quot;</a>). One can use this new interface as</p>

<pre><code><code>  <span class="keyword">tie</span> <span class="variable">$a</span><span class="operator">,</span> <span class="string">'symbolic'</span><span class="operator">,</span> <span class="number">3</span><span class="operator">;</span>
  <span class="keyword">tie</span> <span class="variable">$b</span><span class="operator">,</span> <span class="string">'symbolic'</span><span class="operator">,</span> <span class="number">4</span><span class="operator">;</span>
  <span class="variable">$a</span><span class="operator">-&gt;</span><span class="variable">nop</span><span class="operator">;</span>  <span class="variable">$b</span><span class="operator">-&gt;</span><span class="variable">nop</span><span class="operator">;</span>    <span class="comment"># Around a bug</span>
  
  <span class="keyword">my</span> <span class="variable">$c</span> <span class="operator">=</span> <span class="keyword">sqrt</span><span class="operator">(</span><span class="variable">$a</span><span class="operator">**</span><span class="number">2</span> <span class="operator">+</span> <span class="variable">$b</span><span class="operator">**</span><span class="number">2</span><span class="operator">);</span>
</code></code></pre>

<p>Now numeric value of $c is 5. After <code><code><span class="variable">$a</span> <span class="operator">=</span> <span class="number">12</span><span class="operator">;</span> <span class="variable">$b</span> <span class="operator">=</span> <span class="number">5</span>
</code></code> the numeric value of $c becomes 13. To insulate the user of the module add a method</p>

<pre><code><code>  <span class="keyword">sub</span><span class="variable"> vars </span><span class="operator">{</span> <span class="keyword">my</span> <span class="variable">$p</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span> <span class="keyword">tie</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span> <span class="variable">$p</span><span class="operator">),</span> <span class="variable">$_</span><span class="operator">-&gt;</span><span class="variable">nop</span> <span class="keyword">foreach</span> <span class="variable">@_</span><span class="operator">;</span> <span class="operator">}</span>
</code></code></pre>

<p>Now</p>

<pre><code><code>  <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">);</span>
  <span class="variable">symbolic</span><span class="operator">-&gt;</span><span class="variable">vars</span><span class="operator">(</span><span class="variable">$a</span><span class="operator">,</span> <span class="variable">$b</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$c</span> <span class="operator">=</span> <span class="keyword">sqrt</span><span class="operator">(</span><span class="variable">$a</span><span class="operator">**</span><span class="number">2</span> <span class="operator">+</span> <span class="variable">$b</span><span class="operator">**</span><span class="number">2</span><span class="operator">);</span>
  
  <span class="variable">$a</span> <span class="operator">=</span> <span class="number">3</span><span class="operator">;</span> <span class="variable">$b</span> <span class="operator">=</span> <span class="number">4</span><span class="operator">;</span>
  <span class="keyword">printf</span> <span class="string">"c5  %s=%f\n"</span><span class="operator">,</span> <span class="variable">$c</span><span class="operator">,</span> <span class="variable">$c</span><span class="operator">;</span>
  
  <span class="variable">$a</span> <span class="operator">=</span> <span class="number">12</span><span class="operator">;</span> <span class="variable">$b</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>
  <span class="keyword">printf</span> <span class="string">"c13  %s=%f\n"</span><span class="operator">,</span> <span class="variable">$c</span><span class="operator">,</span> <span class="variable">$c</span><span class="operator">;</span>
</code></code></pre>

<p>shows that the numeric value of $c follows changes to the values of $a and $b.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Ilya Zakharevich &lt;<i>ilya@math.mps.ohio-state.edu</i>&gt;.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p>The <code><code>overloading</code></code> pragma can be used to enable or disable overloaded operations within a lexical scope - see <a href="../lib/overloading.html">overloading</a>.</p>

<h1 id="DIAGNOSTICS">DIAGNOSTICS</h1>

<p>When Perl is run with the <b>-Do</b> switch or its equivalent, overloading induces diagnostic messages.</p>

<p>Using the <code><code>m</code></code> command of Perl debugger (see <a href="../lib/pods/perldebug.html">perldebug</a>) one can deduce which operations are overloaded (and which ancestor triggers this overloading). Say, if <code><code>eq</code></code> is overloaded, then the method <code><code>(eq</code></code> is shown by debugger. The method <code><code>()</code></code> corresponds to the <code><code>fallback</code></code> key (in fact a presence of this method shows that this package has overloading enabled, and it is what is used by the <code><code>Overloaded</code></code> function of module <code><code>overload</code></code>).</p>

<p>The module might issue the following warnings:</p>

<dl>

<dt id="Odd-number-of-arguments-for-overload::constant">Odd number of arguments for overload::constant</dt>
<dd>

<p>(W) The call to overload::constant contained an odd number of arguments. The arguments should come in pairs.</p>

</dd>
<dt id="s-is-not-an-overloadable-type">&#39;%s&#39; is not an overloadable type</dt>
<dd>

<p>(W) You tried to overload a constant type the overload package is unaware of.</p>

</dd>
<dt id="s-is-not-a-code-reference">&#39;%s&#39; is not a code reference</dt>
<dd>

<p>(W) The second (fourth, sixth, ...) argument of overload::constant needs to be a code reference. Either an anonymous subroutine, or a reference to a subroutine.</p>

</dd>
<dt id="overload-arg-s-is-invalid">overload arg &#39;%s&#39; is invalid</dt>
<dd>

<p>(W) <code><code>use overload</code></code> was passed an argument it did not recognize. Did you mistype an operator?</p>

</dd>
</dl>

<h1 id="BUGS-AND-PITFALLS">BUGS AND PITFALLS</h1>

<ul>

<li><p>No warning is issued for invalid <code><code>use overload</code></code> keys. Such errors are not always obvious:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">"+0"</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="operator">...;</span> <span class="operator">},</span>   <span class="comment"># should be "0+"</span>
            <span class="string">"not"</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="operator">...;</span> <span class="operator">};</span>           <span class="comment"># should be "!"</span>
</code></code></pre>

<p>(Bug #74098)</p>

</li>
<li><p>A pitfall when fallback is TRUE and Perl resorts to a built-in implementation of an operator is that some operators have more than one semantic, for example <code><code>|</code></code>:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'0+'</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">n</span><span class="operator">}</span><span class="operator">;</span> <span class="operator">},</span>
            <span class="string">fallback</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$x</span> <span class="operator">=</span> <span class="keyword">bless</span> <span class="operator">{</span> <span class="string">n</span> <span class="operator">=&gt;</span> <span class="number">4</span> <span class="operator">}</span><span class="operator">,</span> <span class="string">"main"</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$y</span> <span class="operator">=</span> <span class="keyword">bless</span> <span class="operator">{</span> <span class="string">n</span> <span class="operator">=&gt;</span> <span class="number">8</span> <span class="operator">}</span><span class="operator">,</span> <span class="string">"main"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$x</span> <span class="operator">|</span> <span class="variable">$y</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>You might expect this to output &quot;12&quot;. In fact, it prints &quot;&lt;&quot;: the ASCII result of treating &quot;|&quot; as a bitwise string operator - that is, the result of treating the operands as the strings &quot;4&quot; and &quot;8&quot; rather than numbers. The fact that numify (<code><code>0+</code></code>) is implemented but stringify (<code><code>&quot;&quot;</code></code>) isn&#39;t makes no difference since the latter is simply autogenerated from the former.</p>

<p>The only way to change this is to provide your own subroutine for <code><code>&#39;|&#39;</code></code>.</p>

</li>
<li><p>Magic autogeneration increases the potential for inadvertently creating self-referential structures. Currently Perl will not free self-referential structures until cycles are explicitly broken. For example,</p>

<pre><code><code>    <span class="keyword">use</span> <span class="variable">overload</span> <span class="string">'+'</span> <span class="operator">=&gt;</span> <span class="string">'add'</span><span class="operator">;</span>
    <span class="keyword">sub</span><span class="variable"> add </span><span class="operator">{</span> <span class="keyword">bless</span> <span class="operator">[</span> <span class="operator">\</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">]</span> <span class="operator">};</span>
</code></code></pre>

<p>is asking for trouble, since</p>

<pre><code><code>    <span class="variable">$obj</span> <span class="operator">+=</span> <span class="variable">$y</span><span class="operator">;</span>
</code></code></pre>

<p>will effectively become</p>

<pre><code><code>    <span class="variable">$obj</span> <span class="operator">=</span> <span class="variable">add</span><span class="operator">(</span><span class="variable">$obj</span><span class="operator">,</span> <span class="variable">$y</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">);</span>
</code></code></pre>

<p>with the same result as</p>

<pre><code><code>    <span class="variable">$obj</span> <span class="operator">=</span> <span class="operator">[</span><span class="operator">\</span><span class="variable">$obj</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$foo</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>Even if no <i>explicit</i> assignment-variants of operators are present in the script, they may be generated by the optimizer. For example,</p>

<pre><code><code>    &quot;obj = $obj\n&quot;</code></code></pre>

<p>may be optimized to</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$tmp</span> <span class="operator">=</span> <span class="string">'obj = '</span> <span class="operator">.</span> <span class="variable">$obj</span><span class="operator">;</span>  <span class="variable">$tmp</span> <span class="operator">.=</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

</li>
<li><p>Because it is used for overloading, the per-package hash <code><code>%OVERLOAD</code></code> now has a special meaning in Perl. The symbol table is filled with names looking like line-noise.</p>

</li>
<li><p>For the purpose of inheritance every overloaded package behaves as if <code><code>fallback</code></code> is present (possibly undefined). This may create interesting effects if some package is not overloaded, but inherits from two overloaded packages.</p>

</li>
<li><p>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the <i>previous</i> class of the tie()d variable.</p>

<p>This happened because the presence of overloading was checked too early, before any tie()d access was attempted. If the class of the value FETCH()ed from the tied variable does not change, a simple workaround for code that is to run on older Perl versions is to access the value (via <code><code>() = $foo</code></code> or some such) immediately after tie()ing, so that after this call the <i>previous</i> class coincides with the current one.</p>

</li>
<li><p>Barewords are not covered by overloaded string constants.</p>

</li>
</ul>


</body>

</html>


