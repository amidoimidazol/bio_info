<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#MODULE-DOCUMENTATION">MODULE DOCUMENTATION</a></li>
  <li><a href="#THE-DBI-CLASS">THE DBI CLASS</a>
    <ul>
      <li><a href="#DBI-Class-Methods">DBI Class Methods</a>
        <ul>
          <li><a href="#connect">connect</a></li>
          <li><a href="#connect_cached">connect_cached</a></li>
          <li><a href="#data_sources">data_sources</a></li>
        </ul>
      </li>
      <li><a href="#Methods-Common-To-All-Handles">Methods Common To All Handles</a>
        <ul>
          <li><a href="#err">err</a></li>
          <li><a href="#errstr">errstr</a></li>
          <li><a href="#state">state</a></li>
          <li><a href="#trace">trace</a></li>
          <li><a href="#trace_msg">trace_msg</a></li>
          <li><a href="#parse_trace_flag-and-parse_trace_flags">parse_trace_flag and parse_trace_flags</a></li>
          <li><a href="#func">func</a></li>
          <li><a href="#private_attribute_info">private_attribute_info</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ATTRIBUTES-COMMON-TO-ALL-HANDLES">ATTRIBUTES COMMON TO ALL HANDLES</a>
    <ul>
      <li>
        <ul>
          <li><a href="#InactiveDestroy-boolean-">InactiveDestroy (boolean)</a></li>
          <li><a href="#RaiseError-boolean-inherited-">RaiseError (boolean, inherited)</a></li>
          <li><a href="#PrintError-boolean-inherited-">PrintError (boolean, inherited)</a></li>
          <li><a href="#ShowErrorStatement-boolean-inherited-">ShowErrorStatement (boolean, inherited)</a></li>
          <li><a href="#Warn-boolean-inherited-">Warn (boolean, inherited)</a></li>
          <li><a href="#Executed-boolean-read-only-">Executed (boolean, read-only)</a></li>
          <li><a href="#TraceLevel-integer-inherited-">TraceLevel (integer, inherited)</a></li>
          <li><a href="#Active-boolean-read-only-">Active (boolean, read-only)</a></li>
          <li><a href="#Kids-integer-read-only-">Kids (integer, read-only)</a></li>
          <li><a href="#ActiveKids-integer-read-only-">ActiveKids (integer, read-only)</a></li>
          <li><a href="#CachedKids-hash-ref-">CachedKids (hash ref)</a></li>
          <li><a href="#ChildHandles-array-ref-">ChildHandles (array ref)</a></li>
          <li><a href="#PrintWarn-boolean-inherited-">PrintWarn (boolean, inherited)</a></li>
          <li><a href="#HandleError-boolean-inherited-">HandleError (boolean, inherited)</a></li>
          <li><a href="#HandleSetErr-code-ref-inherited-">HandleSetErr (code ref, inherited)</a></li>
          <li><a href="#ErrCount-unsigned-integer-">ErrCount (unsigned integer)</a></li>
          <li><a href="#FetchHashKeyName-string-inherited-">FetchHashKeyName (string, inherited)</a></li>
          <li><a href="#ChopBlanks-boolean-inherited-">ChopBlanks (boolean, inherited)</a></li>
          <li><a href="#Taint-boolean-inherited-">Taint (boolean, inherited)</a></li>
          <li><a href="#TaintIn-boolean-inherited-">TaintIn (boolean, inherited)</a></li>
          <li><a href="#TaintOut-boolean-inherited-">TaintOut (boolean, inherited)</a></li>
          <li><a href="#Profile-inherited-">Profile (inherited)</a></li>
          <li><a href="#Type-scalar-">Type (scalar)</a></li>
          <li><a href="#LongReadLen">LongReadLen</a></li>
          <li><a href="#LongTruncOk">LongTruncOk</a></li>
          <li><a href="#CompatMode">CompatMode</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#DBI-DATABASE-HANDLE-OBJECTS">DBI DATABASE HANDLE OBJECTS</a>
    <ul>
      <li><a href="#Database-Handle-Methods">Database Handle Methods</a>
        <ul>
          <li><a href="#selectall_arrayref">selectall_arrayref</a></li>
          <li><a href="#selectall_hashref">selectall_hashref</a></li>
          <li><a href="#selectcol_arrayref">selectcol_arrayref</a></li>
          <li><a href="#prepare">prepare</a>
            <ul>
              <li><a href="#Placeholders">Placeholders</a></li>
            </ul>
          </li>
          <li><a href="#prepare_cached">prepare_cached</a></li>
          <li><a href="#do">do</a></li>
          <li><a href="#last_insert_id">last_insert_id</a></li>
          <li><a href="#commit">commit</a></li>
          <li><a href="#rollback">rollback</a></li>
          <li><a href="#begin_work">begin_work</a></li>
          <li><a href="#disconnect">disconnect</a></li>
          <li><a href="#quote">quote</a></li>
          <li><a href="#quote_identifier">quote_identifier</a></li>
          <li><a href="#pg_notifies">pg_notifies</a></li>
          <li><a href="#ping">ping</a></li>
          <li><a href="#pg_ping">pg_ping</a></li>
          <li><a href="#get_info">get_info</a></li>
          <li><a href="#table_info">table_info</a></li>
          <li><a href="#column_info">column_info</a></li>
          <li><a href="#primary_key_info">primary_key_info</a></li>
          <li><a href="#primary_key">primary_key</a></li>
          <li><a href="#foreign_key_info">foreign_key_info</a></li>
          <li><a href="#statistics_info">statistics_info</a></li>
          <li><a href="#tables">tables</a></li>
          <li><a href="#type_info_all">type_info_all</a></li>
          <li><a href="#type_info">type_info</a></li>
          <li><a href="#pg_server_trace">pg_server_trace</a></li>
          <li><a href="#pg_server_untrace">pg_server_untrace</a></li>
          <li><a href="#selectrow_array">selectrow_array</a></li>
          <li><a href="#selectrow_arrayref">selectrow_arrayref</a></li>
          <li><a href="#selectrow_hashref">selectrow_hashref</a></li>
          <li><a href="#clone">clone</a></li>
        </ul>
      </li>
      <li><a href="#Database-Handle-Attributes">Database Handle Attributes</a>
        <ul>
          <li><a href="#AutoCommit-boolean-">AutoCommit (boolean)</a></li>
          <li><a href="#pg_bool_tf-boolean-">pg_bool_tf (boolean)</a></li>
          <li><a href="#ReadOnly-boolean-">ReadOnly (boolean)</a></li>
          <li><a href="#pg_server_prepare-integer-">pg_server_prepare (integer)</a></li>
          <li><a href="#pg_placeholder_dollaronly-boolean-">pg_placeholder_dollaronly (boolean)</a></li>
          <li><a href="#pg_enable_utf8-boolean-">pg_enable_utf8 (boolean)</a></li>
          <li><a href="#pg_errorlevel-integer-">pg_errorlevel (integer)</a></li>
          <li><a href="#pg_lib_version-integer-read-only-">pg_lib_version (integer, read-only)</a></li>
          <li><a href="#pg_server_version-integer-read-only-">pg_server_version (integer, read-only)</a></li>
          <li><a href="#Name-string-read-only-">Name (string, read-only)</a></li>
          <li><a href="#Username-string-read-only-">Username (string, read-only)</a></li>
          <li><a href="#pg_db-string-read-only-">pg_db (string, read-only)</a></li>
          <li><a href="#pg_user-string-read-only-">pg_user (string, read-only)</a></li>
          <li><a href="#pg_host-string-read-only-">pg_host (string, read-only)</a></li>
          <li><a href="#pg_port-integer-read-only-">pg_port (integer, read-only)</a></li>
          <li><a href="#pg_socket-integer-read-only-">pg_socket (integer, read-only)</a></li>
          <li><a href="#pg_pass-string-read-only-">pg_pass (string, read-only)</a></li>
          <li><a href="#pg_options-string-read-only-">pg_options (string, read-only)</a></li>
          <li><a href="#pg_default_port-integer-read-only-">pg_default_port (integer, read-only)</a></li>
          <li><a href="#pg_pid-integer-read-only-">pg_pid (integer, read-only)</a></li>
          <li><a href="#pg_prepare_now-boolean-">pg_prepare_now (boolean)</a></li>
          <li><a href="#pg_expand_array-boolean-">pg_expand_array (boolean)</a></li>
          <li><a href="#pg_async_status-integer-read-only-">pg_async_status (integer, read-only)</a></li>
          <li><a href="#pg_standard_conforming_strings-boolean-read-only-">pg_standard_conforming_strings (boolean, read-only)</a></li>
          <li><a href="#pg_INV_READ-integer-read-only-">pg_INV_READ (integer, read-only)</a></li>
          <li><a href="#pg_INV_WRITE-integer-read-only-">pg_INV_WRITE (integer, read-only)</a></li>
          <li><a href="#Driver-handle-read-only-">Driver (handle, read-only)</a></li>
          <li><a href="#pg_protocol-integer-read-only-">pg_protocol (integer, read-only)</a></li>
          <li><a href="#RowCacheSize">RowCacheSize</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#DBI-STATEMENT-HANDLE-OBJECTS">DBI STATEMENT HANDLE OBJECTS</a>
    <ul>
      <li><a href="#Statement-Handle-Methods">Statement Handle Methods</a>
        <ul>
          <li><a href="#bind_param">bind_param</a></li>
          <li><a href="#bind_param_inout">bind_param_inout</a></li>
          <li><a href="#bind_param_array">bind_param_array</a></li>
          <li><a href="#execute">execute</a></li>
          <li><a href="#execute_array">execute_array</a></li>
          <li><a href="#execute_for_fetch">execute_for_fetch</a></li>
          <li><a href="#fetchrow_arrayref">fetchrow_arrayref</a></li>
          <li><a href="#fetchrow_array">fetchrow_array</a></li>
          <li><a href="#fetchrow_hashref">fetchrow_hashref</a></li>
          <li><a href="#fetchall_arrayref">fetchall_arrayref</a></li>
          <li><a href="#fetchall_hashref">fetchall_hashref</a></li>
          <li><a href="#finish">finish</a></li>
          <li><a href="#rows">rows</a></li>
          <li><a href="#bind_col">bind_col</a></li>
          <li><a href="#bind_columns">bind_columns</a></li>
          <li><a href="#dump_results">dump_results</a></li>
          <li><a href="#blob_read">blob_read</a></li>
        </ul>
      </li>
      <li><a href="#Statement-Handle-Attributes">Statement Handle Attributes</a>
        <ul>
          <li><a href="#NUM_OF_FIELDS-integer-read-only-">NUM_OF_FIELDS (integer, read-only)</a></li>
          <li><a href="#NUM_OF_PARAMS-integer-read-only-">NUM_OF_PARAMS (integer, read-only)</a></li>
          <li><a href="#NAME-arrayref-read-only-">NAME (arrayref, read-only)</a></li>
          <li><a href="#NAME_lc-arrayref-read-only-">NAME_lc (arrayref, read-only)</a></li>
          <li><a href="#NAME_uc-arrayref-read-only-">NAME_uc (arrayref, read-only)</a></li>
          <li><a href="#NAME_hash-hashref-read-only-">NAME_hash (hashref, read-only)</a></li>
          <li><a href="#NAME_lc_hash-hashref-read-only-">NAME_lc_hash (hashref, read-only)</a></li>
          <li><a href="#NAME_uc_hash-hashref-read-only-">NAME_uc_hash (hashref, read-only)</a></li>
          <li><a href="#TYPE-arrayref-read-only-">TYPE (arrayref, read-only)</a></li>
          <li><a href="#PRECISION-arrayref-read-only-">PRECISION (arrayref, read-only)</a></li>
          <li><a href="#SCALE-arrayref-read-only-">SCALE (arrayref, read-only)</a></li>
          <li><a href="#NULLABLE-arrayref-read-only-">NULLABLE (arrayref, read-only)</a></li>
          <li><a href="#Database-dbh-read-only-">Database (dbh, read-only)</a></li>
          <li><a href="#ParamValues-hash-ref-read-only-">ParamValues (hash ref, read-only)</a></li>
          <li><a href="#ParamTypes-hash-ref-read-only-">ParamTypes (hash ref, read-only)</a></li>
          <li><a href="#Statement-string-read-only-">Statement (string, read-only)</a></li>
          <li><a href="#pg_current_row-integer-read-only-">pg_current_row (integer, read-only)</a></li>
          <li><a href="#pg_numbound-integer-read-only-">pg_numbound (integer, read-only)</a></li>
          <li><a href="#pg_bound-hashref-read-only-">pg_bound (hashref, read-only)</a></li>
          <li><a href="#pg_size-arrayref-read-only-">pg_size (arrayref, read-only)</a></li>
          <li><a href="#pg_type-arrayref-read-only-">pg_type (arrayref, read-only)</a></li>
          <li><a href="#pg_segments-arrayref-read-only-">pg_segments (arrayref, read-only)</a></li>
          <li><a href="#pg_oid_status-integer-read-only-">pg_oid_status (integer, read-only)</a></li>
          <li><a href="#pg_cmd_status-integer-read-only-">pg_cmd_status (integer, read-only)</a></li>
          <li><a href="#pg_direct-boolean-">pg_direct (boolean)</a></li>
          <li><a href="#pg_prepare_now-boolean-1">pg_prepare_now (boolean)</a></li>
          <li><a href="#pg_prepare_name-string-">pg_prepare_name (string)</a></li>
          <li><a href="#pg_server_prepare-integer-1">pg_server_prepare (integer)</a></li>
          <li><a href="#pg_placeholder_dollaronly-boolean-1">pg_placeholder_dollaronly (boolean)</a></li>
          <li><a href="#pg_async-integer-">pg_async (integer)</a></li>
          <li><a href="#RowsInCache">RowsInCache</a></li>
          <li><a href="#RowCache">RowCache</a></li>
          <li><a href="#CursorName">CursorName</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#FURTHER-INFORMATION">FURTHER INFORMATION</a>
    <ul>
      <li><a href="#Transactions">Transactions</a></li>
      <li><a href="#Savepoints">Savepoints</a>
        <ul>
          <li><a href="#"></a></li>
          <li><a href="#1"></a></li>
          <li><a href="#2"></a></li>
        </ul>
      </li>
      <li><a href="#Asynchronous-Queries">Asynchronous Queries</a>
        <ul>
          <li><a href="#Asynchronous-Constants">Asynchronous Constants</a></li>
          <li><a href="#Asynchronous-Methods">Asynchronous Methods</a></li>
          <li><a href="#Asynchronous-Examples">Asynchronous Examples</a></li>
        </ul>
      </li>
      <li><a href="#Array-support">Array support</a></li>
      <li><a href="#COPY-support">COPY support</a>
        <ul>
          <li><a href="#pg_getcopydata">pg_getcopydata</a></li>
          <li><a href="#pg_putcopydata">pg_putcopydata</a></li>
          <li><a href="#pg_putcopyend">pg_putcopyend</a></li>
        </ul>
      </li>
      <li><a href="#Large-Objects">Large Objects</a></li>
      <li><a href="#Cursors">Cursors</a></li>
      <li><a href="#Datatype-bool">Datatype bool</a></li>
      <li><a href="#Schema-support">Schema support</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#DEVELOPMENT">DEVELOPMENT</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBD::Pg - PostgreSQL database driver for the DBI module</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
  <span class="comment"># The AutoCommit attribute should always be explicitly set</span>
  
  <span class="comment"># For some advanced uses you may need PostgreSQL type values:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
  
  <span class="comment"># For asynchronous calls, import the async constants:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:async)</span><span class="operator">;</span>
  
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'INSERT INTO mytable(a) VALUES (1)'</span><span class="operator">);</span>
  
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'INSERT INTO mytable(a) VALUES (?)'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</code></code></pre>

<h1 id="VERSION">VERSION</h1>

<p>This documents version 2.19.3 of the DBD::Pg module</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>DBD::Pg is a Perl module that works with the DBI module to provide access to PostgreSQL databases.</p>

<h1 id="MODULE-DOCUMENTATION">MODULE DOCUMENTATION</h1>

<p>This documentation describes driver specific behavior and restrictions. It is not supposed to be used as the only reference for the user. In any case consult the <b>DBI</b> documentation first!</p>



<a href="http://search.cpan.org/~timb/DBI/DBI.pm">Latest DBI docmentation.</a>

<h1 id="THE-DBI-CLASS">THE DBI CLASS</h1>

<h2 id="DBI-Class-Methods">DBI Class Methods</h2>

<h3 id="connect"><b>connect</b></h3>

<p>This method creates a database handle by connecting to a database, and is the DBI equivalent of the &quot;new&quot; method. To connect to a Postgres database with a minimum of parameters, use the following syntax:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>This connects to the database named in the <code><code>$dbname</code></code> variable on the default port (usually 5432) without any user authentication.</p>

<p>The following connect statement shows almost all possible parameters:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">;host=</span><span class="variable">$host</span><span class="string">;port=</span><span class="variable">$port</span><span class="string">;options=</span><span class="variable">$options</span><span class="string">"</span><span class="operator">,</span>
                      <span class="variable">$username</span><span class="operator">,</span>
                      <span class="variable">$password</span><span class="operator">,</span>
                      <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">PrintError</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span>
                     <span class="operator">);</span>
</code></code></pre>

<p>If a parameter is not given, the connect() method will first look for specific environment variables, and then fall back to hard-coded defaults:</p>

<pre><code><code>  parameter    environment variable    hard coded default
  ------------------------------------------------------
  host         PGHOST                  local domain socket
  hostaddr     PGHOSTADDR              local domain socket
  port         PGPORT                  5432
  dbname*      PGDATABASE              current userid
  username     PGUSER                  current userid
  password     PGPASSWORD              (none)
  options      PGOPTIONS               (none)
  service      PGSERVICE               (none)
  sslmode      PGSSLMODE               (none)</code></code></pre>

<p>* May also use the aliases <code><code>db</code></code> or <code><code>database</code></code></p>

<p>If the username and password values passed via <code><code>connect()</code></code> are undefined (as opposed to merely being empty strings), DBI will use the environment variables <i>DBI_USER</i> and <i>DBI_PASS</i> if they exist.</p>

<p>You can also connect by using a service connection file, which is named <i>pg_service.conf</i>. The location of this file can be controlled by setting the <i>PGSYSCONFDIR</i> environment variable. To use one of the named services within the file, set the name by using either the <i>service</i> parameter or the environment variable <i>PGSERVICE</i>. Note that when connecting this way, only the minimum parameters should be used. For example, to connect to a service named &quot;zephyr&quot;, you could use:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:service=zephyr"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
</code></code></pre>

<p>You could also set <code><code><span class="variable">$ENV</span><span class="operator">{</span><span class="string">PGSERVICE</span><span class="operator">}</span>
</code></code> to &quot;zephyr&quot; and connect like this:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">"dbi:Pg:"</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">);</span>
</code></code></pre>

<p>The format of the <i>pg_service.conf</i> file is simply a bracketed service name, followed by one parameter per line in the format name=value. For example:</p>

<pre><code><code>  [zephyr]
  dbname=winds
  user=wisp
  password=W$2Hc00YSgP
  port=6543</code></code></pre>

<p>There are four valid arguments to the <i>sslmode</i> parameter, which controls whether to use SSL to connect to the database:</p>

<ul>

<li><p>disable: SSL connections are never used</p>

</li>
<li><p>allow: try non-SSL, then SSL</p>

</li>
<li><p>prefer: try SSL, then non-SSL</p>

</li>
<li><p>require: connect only with SSL</p>

</li>
</ul>

<p>You can also connect using sockets in a specific directory. This may be needed if the server you are connecting to has a different default socket directory from the one used to compile DBD::Pg. Use the complete path to the socket directory as the name of the host, like this:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=foo;host=/var/tmp/socket'</span><span class="operator">,</span>
    <span class="variable">$username</span><span class="operator">,</span>
    <span class="variable">$password</span><span class="operator">,</span>
    <span class="operator">{</span><span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span> <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>The attribute hash can also contain a key named <code><code>dbd_verbose</code></code>, which simply calls <code><code>$dbh-&gt;trace(&#39;DBD&#39;)</code></code> after the handle is created. This attribute is not recommended, as it is clearer to simply explicitly call <code><code>trace</code></code> explicitly in your script.</p>

<h3 id="connect_cached"><b>connect_cached</b></h3>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect_cached</span><span class="operator">(</span><span class="string">"dbi:Pg:dbname=</span><span class="variable">$dbname</span><span class="string">"</span><span class="operator">,</span> <span class="variable">$username</span><span class="operator">,</span> <span class="variable">$password</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%options</span><span class="operator">);</span>
</code></code></pre>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="data_sources"><b>data_sources</b></h3>

<pre><code><code>  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'Pg'</span><span class="operator">);</span>
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">();</span>
</code></code></pre>

<p>Returns a list of available databases. Unless the environment variable <code><code>DBI_DSN</code></code> is set, a connection will be attempted to the database <code><code>template1</code></code>. The normal connection environment variables also apply, such as <code><code>PGHOST</code></code>, <code><code>PGPORT</code></code>, <code><code>DBI_USER</code></code>, <code><code>DBI_PASS</code></code>, and <code><code>PGSERVICE</code></code>.</p>

<p>You can also pass in options to add to the connection string For example, to specify an alternate port and host:</p>

<pre><code><code>  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'Pg'</span><span class="operator">,</span> <span class="string">'port=5824;host=example.com'</span><span class="operator">);</span>
  
  <span class="keyword">or</span><span class="operator">:</span>
  
  <span class="variable">@data_sources</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">data_sources</span><span class="operator">(</span><span class="string">'port=5824;host=example.com'</span><span class="operator">);</span>
</code></code></pre>

<h2 id="Methods-Common-To-All-Handles">Methods Common To All Handles</h2>

<p>For all of the methods below, <b>$h</b> can be either a database handle (<b>$dbh</b>) or a statement handle (<b>$sth</b>). Note that <i>$dbh</i> and <i>$sth</i> can be replaced with any variable name you choose: these are just the names most often used. Another common variable used in this documentation is $<i>rv</i>, which stands for &quot;return value&quot;.</p>

<h3 id="err"><b>err</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">err</span><span class="operator">;</span>
</code></code></pre>

<p>Returns the error code from the last method called. For the connect method it returns <code><code>PQstatus</code></code>, which is a number used by <i>libpq</i> (the Postgres connection library). A value of 0 indicates no error (CONNECTION_OK), while any other number indicates a failed connection. The only other number commonly seen is 1 (CONNECTION_BAD). See the libpq documentation for the complete list of return codes.</p>

<p>In all other non-connect methods <code><code>$h-&gt;err</code></code> returns the <code><code>PQresultStatus</code></code> of the current handle. This is a number used by libpq and is one of:</p>

<pre><code><code>  0  Empty query string
  1  A command that returns no data successfully completed.
  2  A command that returns data sucessfully completed.
  3  A COPY OUT command is still in progress.
  4  A COPY IN command is still in progress.
  5  A bad response was received from the backend.
  6  A nonfatal error occurred (a notice or warning message)
  7  A fatal error was returned: the last query failed.</code></code></pre>

<h3 id="errstr"><b>errstr</b></h3>

<pre><code><code>  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</code></code></pre>

<p>Returns the last error that was reported by Postgres. This message is affected by the <a href="#pg_errorlevel">&quot;pg_errorlevel&quot;</a> setting.</p>

<h3 id="state"><b>state</b></h3>

<pre><code><code>  <span class="variable">$str</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">state</span><span class="operator">;</span>
</code></code></pre>

<p>Returns a five-character &quot;SQLSTATE&quot; code. Success is indicated by a <code><code>00000</code></code> code, which gets mapped to an empty string by DBI. A code of <code><code>S8006</code></code> indicates a connection failure, usually because the connection to the Postgres server has been lost.</p>

<p>While this method can be called as either <code><code>$sth-&gt;state</code></code> or <code><code>$dbh-&gt;state</code></code>, it is usually clearer to always use <code><code>$dbh-&gt;state</code></code>.</p>

<p>The list of codes used by PostgreSQL can be found at: <a href="http://www.postgresql.org/docs/current/static/errcodes-appendix.html">http://www.postgresql.org/docs/current/static/errcodes-appendix.html</a></p>

<p>Note that these codes are part of the SQL standard and only a small number of them will be used by PostgreSQL.</p>

<p>Common codes:</p>

<pre><code><code>  00000 Successful completion
  25P01 No active SQL transaction
  25P02 In failed SQL transaction
  S8006 Connection failure</code></code></pre>

<h3 id="trace"><b>trace</b></h3>

<pre><code><code>  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$trace_settings</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$trace_settings</span><span class="operator">,</span> <span class="variable">$trace_filename</span><span class="operator">);</span>
  <span class="variable">$trace_settings</span> <span class="operator">=</span> <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">;</span>
</code></code></pre>

<p>Changes the trace settings on a database or statement handle. The optional second argument specifies a file to write the trace information to. If no filename is given, the information is written to <i>STDERR</i>. Note that tracing can be set globally as well by setting <code><code>DBI-&gt;trace</code></code>, or by using the environment variable <i>DBI_TRACE</i>.</p>

<p>The value is either a numeric level or a named flag. For the flags that DBD::Pg uses, see <a href="#parse_trace_flag-and-parse_trace_flags">parse_trace_flag</a>.</p>

<h3 id="trace_msg"><b>trace_msg</b></h3>

<pre><code><code>  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace_msg</span><span class="operator">(</span><span class="variable">$message_text</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace_msg</span><span class="operator">(</span><span class="variable">$message_text</span><span class="operator">,</span> <span class="variable">$min_level</span><span class="operator">);</span>
</code></code></pre>

<p>Writes a message to the current trace output (as set by the <a href="#trace">&quot;trace&quot;</a> method). If a second argument is given, the message is only written if the current tracing level is equal to or greater than the <code><code>$min_level</code></code>.</p>

<h3 id="parse_trace_flag-and-parse_trace_flags"><b>parse_trace_flag</b> and <b>parse_trace_flags</b></h3>

<pre><code><code>  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'SQL|pglibpq'</span><span class="operator">));</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flags</span><span class="operator">(</span><span class="string">'1|pgstart'</span><span class="operator">));</span>
  
  <span class="comment">## Simpler:</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="string">'SQL|pglibpq'</span><span class="operator">);</span>
  <span class="variable">$h</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="string">'1|pgstart'</span><span class="operator">);</span>
  
  <span class="keyword">my</span> <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">DBD::Pg</span><span class="operator">-&gt;</span><span class="variable">parse_trace_flag</span><span class="operator">(</span><span class="string">'pglibpq'</span><span class="operator">);</span>
  <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">trace</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">);</span>
</code></code></pre>

<p>The parse_trace_flags method is used to convert one or more named flags to a number which can passed to the <a href="#trace">&quot;trace&quot;</a> method. DBD::Pg currently supports the DBI-specific flag, <code><code>SQL</code></code>, as well as the ones listed below.</p>

<p>Flags can be combined by using the parse_trace_flags method, which simply calls <code><code>parse_trace_flag</code></code> on each item and combines them.</p>

<p>Sometimes you may wish to turn the tracing on before you connect to the database. The second example above shows a way of doing this: the call to <code><code>DBD::Pg-&gt;parse_trace_flags</code></code> provides a number than can be fed to <code><code>DBI-&gt;trace</code></code> before you create a database handle.</p>

<p>DBD::Pg supports the following trace flags:</p>

<dl>

<dt id="SQL">SQL</dt>
<dd>

<p>Outputs all SQL statements. Note that the output provided will not necessarily be in a form suitable to passing directly to Postgres, as server-side prepared statements are used extensively by DBD::Pg. For maximum portability of output (but with a potential performance hit), use with <code><code><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span>
</code></code>.</p>

</dd>
<dt id="DBD">DBD</dt>
<dd>

<p>Turns on all non-DBI flags, in other words, only the ones that are specific to DBD::Pg (all those below which start with the letters &#39;pg&#39;).</p>

</dd>
<dt id="pglibpq">pglibpq</dt>
<dd>

<p>Outputs the name of each libpq function (without arguments) immediately before running it. This is a good way to trace the flow of your program at a low level. This information is also output if the trace level is set to 4 or greater.</p>

</dd>
<dt id="pgstart">pgstart</dt>
<dd>

<p>Outputs the name of each internal DBD::Pg function, and other information such as the function arguments or important global variables, as each function starts. This information is also output if the trace level is set to 4 or greater.</p>

</dd>
<dt id="pgend">pgend</dt>
<dd>

<p>Outputs a simple message at the very end of each internal DBD::Pg function. This is also output if the trace level is set to 4 or greater.</p>

</dd>
<dt id="pgprefix">pgprefix</dt>
<dd>

<p>Forces each line of trace output to begin with the string <b><code><code>dbdpg: </code></code></b>. This helps to differentiate it from the normal DBI trace output.</p>

</dd>
<dt id="pglogin">pglogin</dt>
<dd>

<p>Outputs a message showing the connection string right before a new database connection is attempted, a message when the connection was successful, and a message right after the database has been disconnected. Also output if trace level is 5 or greater.</p>

</dd>
</dl>



See the <a href="http://search.cpan.org/~timb/DBI/DBI.pm#TRACING">DBI section on TRACING</a> for more information.<br />

<h3 id="func"><b>func</b></h3>

<p>DBD::Pg uses the <code><code>func</code></code> method to support a variety of functions. Note that the name of the function comes <i>last</i>, after the arguments.</p>

<dl>

<dt id="table_attributes">table_attributes</dt>
<dd>

<pre><code><code>  <span class="variable">$attrs</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="variable">$table</span><span class="operator">,</span> <span class="string">'table_attributes'</span><span class="operator">);</span>
</code></code></pre>

<p>Use of the tables_attributes function is no longer recommended. Instead, you can use the more portable <code><code>column_info</code></code> and <code><code>primary_key</code></code> methods to access the same information.</p>

<p>The table_attributes method returns, for the given table argument, a reference to an array of hashes, each of which contains the following keys:</p>

<pre><code><code>  NAME        attribute name
  TYPE        attribute type
  SIZE        attribute size (-1 for variable size)
  NULLABLE    flag nullable
  DEFAULT     default value
  CONSTRAINT  constraint
  PRIMARY_KEY flag is_primary_key
  REMARKS     attribute description</code></code></pre>

</dd>
<dt id="pg_lo_creat">pg_lo_creat</dt>
<dd>

<pre><code><code>  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_creat</span><span class="operator">(</span><span class="variable">$mode</span><span class="operator">);</span>
</code></code></pre>

<p>Creates a new large object and returns the object-id. <code><code>$mode</code></code> is a bitmask describing read and write access to the new object. This setting is ignored since Postgres version 8.1. For backwards compatibility, however, you should set a valid mode anyway (see <a href="#pg_lo_open">&quot;pg_lo_open&quot;</a> for a list of valid modes).</p>

<p>Upon failure it returns <code><code>undef</code></code>. This function cannot be used if AutoCommit is enabled.</p>

<p>The old way of calling large objects functions is deprecated: $dbh-&gt;func(.., &#39;lo_);</p>

</dd>
<dt id="lo_open">lo_open</dt>
<dd>

<pre><code><code>  <span class="variable">$lobj_fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_open</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">,</span> <span class="variable">$mode</span><span class="operator">);</span>
</code></code></pre>

<p>Opens an existing large object and returns an object-descriptor for use in subsequent <code><code>lo_*</code></code> calls. <code><code>$mode</code></code> is a bitmask describing read and write access to the opened object. It may be one of:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_READ</span><span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_WRITE</span><span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_READ</span><span class="operator">}</span> <span class="operator">|</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_INV_WRITE</span><span class="operator">}</span>
</code></code></pre>

<p><code><code>pg_INV_WRITE</code></code> and <code><code>pg_INV_WRITE | pg_INV_READ</code></code> modes are identical; in both modes, the large object can be read from or written to. Reading from the object will provide the object as written in other committed transactions, along with any writes performed by the current transaction. Objects opened with <code><code>pg_INV_READ</code></code> cannot be written to. Reading from this object will provide the stored data at the time of the transaction snapshot which was active when <code><code>lo_write</code></code> was called.</p>

<p>Returns <code><code>undef</code></code> upon failure. Note that 0 is a perfectly correct (and common) object descriptor! This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_write">lo_write</dt>
<dd>

<pre><code><code>  <span class="variable">$nbytes</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_write</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</code></code></pre>

<p>Writes <code><code>$len</code></code> bytes of c&lt;$buffer&gt; into the large object <code><code>$lobj_fd</code></code>. Returns the number of bytes written and <code><code>undef</code></code> upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_read">lo_read</dt>
<dd>

<pre><code><code>  <span class="variable">$nbytes</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_read</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</code></code></pre>

<p>Reads <code><code>$len</code></code> bytes into c&lt;$buffer&gt; from large object <code><code>$lobj_fd</code></code>. Returns the number of bytes read and <code><code>undef</code></code> upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_lseek">lo_lseek</dt>
<dd>

<pre><code><code>  <span class="variable">$loc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_lseek</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$whence</span><span class="operator">);</span>
</code></code></pre>

<p>Changes the current read or write location on the large object <code><code>$obj_id</code></code>. Currently <code><code>$whence</code></code> can only be 0 (which is L_SET). Returns the current location and <code><code>undef</code></code> upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_tell">lo_tell</dt>
<dd>

<pre><code><code>  <span class="variable">$loc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_tell</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">);</span>
</code></code></pre>

<p>Returns the current read or write location on the large object <code><code>$lobj_fd</code></code> and <code><code>undef</code></code> upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_close">lo_close</dt>
<dd>

<pre><code><code>  <span class="variable">$lobj_fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_close</span><span class="operator">(</span><span class="variable">$lobj_fd</span><span class="operator">);</span>
</code></code></pre>

<p>Closes an existing large object. Returns true upon success and false upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_unlink">lo_unlink</dt>
<dd>

<pre><code><code>  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_unlink</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">);</span>
</code></code></pre>

<p>Deletes an existing large object. Returns true upon success and false upon failure. This function cannot be used if AutoCommit is enabled.</p>

</dd>
<dt id="lo_import">lo_import</dt>
<dd>

<pre><code><code>  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_import</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">);</span>
</code></code></pre>

<p>Imports a Unix file as a large object and returns the object id of the new object or <code><code>undef</code></code> upon failure.</p>

</dd>
<dt id="lo_import_with_oid">lo_import_with_oid</dt>
<dd>

<pre><code><code>  <span class="variable">$lobjId</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_import</span><span class="operator">(</span><span class="variable">$filename</span><span class="operator">,</span> <span class="variable">$OID</span><span class="operator">);</span>
</code></code></pre>

<p>Same as lo_import, but attempts to use the supplied OID as the large object number. If this number is 0, it falls back to the behavior of lo_import (which assigns the next available OID).</p>

<p>This is only available when DBD::Pg is compiled against a Postgres server version 8.4 or later.</p>

</dd>
<dt id="lo_export">lo_export</dt>
<dd>

<pre><code><code>  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_lo_export</span><span class="operator">(</span><span class="variable">$lobjId</span><span class="operator">,</span> <span class="variable">$filename</span><span class="operator">);</span>
</code></code></pre>

<p>Exports a large object into a Unix file. Returns false upon failure, true otherwise.</p>

</dd>
<dt id="getfd">getfd</dt>
<dd>

<pre><code><code>  <span class="variable">$fd</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span><span class="string">'getfd'</span><span class="operator">);</span>
</code></code></pre>

<p>Deprecated, use <a href="#pg_socket">$dbh-&gt;{pg_socket}</a> instead.</p>

</dd>
</dl>

<h3 id="private_attribute_info"><b>private_attribute_info</b></h3>

<pre><code><code>  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
  <span class="variable">$hashref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">private_attribute_info</span><span class="operator">();</span>
</code></code></pre>

<p>Returns a hash of all private attributes used by DBD::Pg, for either a database or a statement handle. Currently, all the hash values are undef.</p>

<h1 id="ATTRIBUTES-COMMON-TO-ALL-HANDLES">ATTRIBUTES COMMON TO ALL HANDLES</h1>

<h3 id="InactiveDestroy-boolean-"><b>InactiveDestroy</b> (boolean)</h3>

<p>If set to true, then the <a href="#disconnect">&quot;disconnect&quot;</a> method will not be automatically called when the database handle goes out of scope. This is required if you are forking, and even then you must tread carefully and ensure that either the parent or the child (but not both!) handles all database calls from that point forwards, so that messages from the Postgres backend are only handled by one of the processes. If you don&#39;t set things up properly, you will see messages such as &quot;<i>server closed the connection unexpectedly</i>&quot;, and &quot;<i>message type 0x32 arrived from server while idle</i>&quot;. The best solution is to either have the child process reconnect to the database with a fresh database handle, or to rewrite your application not to use use forking. See the section on <a href="#Asynchronous-Queries">&quot;Asynchronous Queries&quot;</a> for a way to have your script continue to work while the database is processing a request.</p>

<h3 id="RaiseError-boolean-inherited-"><b>RaiseError</b> (boolean, inherited)</h3>

<p>Forces errors to always raise an exception. Although it defaults to off, it is recommended that this be turned on, as the alternative is to check the return value of every method (prepare, execute, fetch, etc.) manually, which is easy to forget to do.</p>

<h3 id="PrintError-boolean-inherited-"><b>PrintError</b> (boolean, inherited)</h3>

<p>Forces database errors to also generate warnings, which can then be filtered with methods such as locally redefining <i>$SIG{__WARN__}</i> or using modules such as <code><code>CGI::Carp</code></code>. This attribute is on by default.</p>

<h3 id="ShowErrorStatement-boolean-inherited-"><b>ShowErrorStatement</b> (boolean, inherited)</h3>

<p>Appends information about the current statement to error messages. If placeholder information is available, adds that as well. Defaults to false.</p>

<h3 id="Warn-boolean-inherited-"><b>Warn</b> (boolean, inherited)</h3>

<p>Enables warnings. This is on by default, and should only be turned off in a local block for a short a time only when absolutely needed.</p>

<h3 id="Executed-boolean-read-only-"><b>Executed</b> (boolean, read-only)</h3>

<p>Indicates if a handle has been executed. For database handles, this value is true after the <a href="#do">&quot;do&quot;</a> method has been called, or when one of the child statement handles has issued an <a href="#execute">&quot;execute&quot;</a>. Issuing a <a href="#commit">&quot;commit&quot;</a> or <a href="#rollback">&quot;rollback&quot;</a> always resets the attribute to false for database handles. For statement handles, any call to <a href="#execute">&quot;execute&quot;</a> or its variants will flip the value to true for the lifetime of the statement handle.</p>

<h3 id="TraceLevel-integer-inherited-"><b>TraceLevel</b> (integer, inherited)</h3>

<p>Sets the trace level, similar to the <a href="#trace">&quot;trace&quot;</a> method. See the sections on <a href="#trace">&quot;trace&quot;</a> and <a href="#parse_trace_flag">&quot;parse_trace_flag&quot;</a> for more details.</p>

<h3 id="Active-boolean-read-only-"><b>Active</b> (boolean, read-only)</h3>

<p>Indicates if a handle is active or not. For database handles, this indicates if the database has been disconnected or not. For statement handles, it indicates if all the data has been fetched yet or not. Use of this attribute is not encouraged.</p>

<h3 id="Kids-integer-read-only-"><b>Kids</b> (integer, read-only)</h3>

<p>Returns the number of child processes created for each handle type. For a driver handle, indicates the number of database handles created. For a database handle, indicates the number of statement handles created. For statement handles, it always returns zero, because statement handles do not create kids.</p>

<h3 id="ActiveKids-integer-read-only-"><b>ActiveKids</b> (integer, read-only)</h3>

<p>Same as <code><code>Kids</code></code>, but only returns those that are active.</p>

<h3 id="CachedKids-hash-ref-"><b>CachedKids</b> (hash ref)</h3>

<p>Returns a hashref of handles. If called on a database handle, returns all statement handles created by use of the <code><code>prepare_cached</code></code> method. If called on a driver handle, returns all database handles created by the <a href="#connect_cached">&quot;connect_cached&quot;</a> method.</p>

<h3 id="ChildHandles-array-ref-"><b>ChildHandles</b> (array ref)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="PrintWarn-boolean-inherited-"><b>PrintWarn</b> (boolean, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="HandleError-boolean-inherited-"><b>HandleError</b> (boolean, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="HandleSetErr-code-ref-inherited-"><b>HandleSetErr</b> (code ref, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="ErrCount-unsigned-integer-"><b>ErrCount</b> (unsigned integer)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="FetchHashKeyName-string-inherited-"><b>FetchHashKeyName</b> (string, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="ChopBlanks-boolean-inherited-"><b>ChopBlanks</b> (boolean, inherited)</h3>

<p>Supported by DBD::Pg as proposed by DBI. This method is similar to the SQL function <code><code>RTRIM</code></code>.</p>

<h3 id="Taint-boolean-inherited-"><b>Taint</b> (boolean, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="TaintIn-boolean-inherited-"><b>TaintIn</b> (boolean, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="TaintOut-boolean-inherited-"><b>TaintOut</b> (boolean, inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="Profile-inherited-"><b>Profile</b> (inherited)</h3>

<p>Implemented by DBI, no driver-specific impact.</p>

<h3 id="Type-scalar-"><b>Type</b> (scalar)</h3>

<p>Returns <code><code>dr</code></code> for a driver handle, <code><code>db</code></code> for a database handle, and <code><code>st</code></code> for a statement handle. Should be rarely needed.</p>

<h3 id="LongReadLen"><b>LongReadLen</b></h3>

<p>Not used by DBD::Pg</p>

<h3 id="LongTruncOk"><b>LongTruncOk</b></h3>

<p>Not used by DBD::Pg</p>

<h3 id="CompatMode"><b>CompatMode</b></h3>

<p>Not used by DBD::Pg</p>

<h1 id="DBI-DATABASE-HANDLE-OBJECTS">DBI DATABASE HANDLE OBJECTS</h1>

<h2 id="Database-Handle-Methods">Database Handle Methods</h2>

<h3 id="selectall_arrayref"><b>selectall_arrayref</b></h3>

<pre><code><code>  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Returns a reference to an array containing the rows returned by preparing and executing the SQL string. See the DBI documentation for full details.</p>

<h3 id="selectall_hashref"><b>selectall_hashref</b></h3>

<pre><code><code>  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="variable">$key_field</span><span class="operator">);</span>
</code></code></pre>

<p>Returns a reference to a hash containing the rows returned by preparing and executing the SQL string. See the DBI documentation for full details.</p>

<h3 id="selectcol_arrayref"><b>selectcol_arrayref</b></h3>

<pre><code><code>  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectcol_arrayref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Returns a reference to an array containing the first column from each rows returned by preparing and executing the SQL string. It is possible to specify exactly which columns to return. See the DBI documentation for full details.</p>

<h3 id="prepare"><b>prepare</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</code></code></pre>

<p>WARNING: DBD::Pg now (as of version 1.40) uses true prepared statements by sending them to the backend to be prepared by the Postgres server. Statements that were legal before may no longer work. See below for details.</p>

<p>The prepare method prepares a statement for later execution. PostgreSQL supports prepared statements, which enables DBD::Pg to only send the query once, and simply send the arguments for every subsequent call to <a href="#execute">&quot;execute&quot;</a>. DBD::Pg can use these server-side prepared statements, or it can just send the entire query to the server each time. The best way is automatically chosen for each query. This will be sufficient for most users: keep reading for a more detailed explanation and some optional flags.</p>

<p>Queries that do not begin with the word &quot;SELECT&quot;, &quot;INSERT&quot;, &quot;UPDATE&quot;, or &quot;DELETE&quot; are never sent as server-side prepared statements.</p>

<p>Deciding whether or not to use prepared statements depends on many factors, but you can force them to be used or not used by using the <a href="#pg_server_prepare">&quot;pg_server_prepare&quot;</a> attribute when calling <a href="#prepare">&quot;prepare&quot;</a>. Setting this to &quot;0&quot; means to never use prepared statements. Setting <a href="#pg_server_prepare">&quot;pg_server_prepare&quot;</a> to &quot;1&quot; means that prepared statements should be used whenever possible. This is the default when connected to Postgres servers version 8.0 or higher. Servers that are version 7.4 get a special default value of &quot;2&quot;, because server-side statements were only partially supported in that version. In this case, it only uses server-side prepares if all parameters are specifically bound.</p>

<p>The <a href="#pg_server_prepare">&quot;pg_server_prepare&quot;</a> attribute can also be set at connection time like so:</p>

<pre><code><code>  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="variable">$DBNAME</span><span class="operator">,</span> <span class="variable">$DBUSER</span><span class="operator">,</span> <span class="variable">$DBPASS</span><span class="operator">,</span>
                      <span class="operator">{</span> <span class="string">AutoCommit</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span>
                        <span class="string">RaiseError</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span>
                        <span class="string">pg_server_prepare</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">,</span>
                      <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>or you may set it after your database handle is created:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>To enable it for just one particular statement:</p>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT id FROM mytable WHERE val = ?"</span><span class="operator">,</span>
                       <span class="operator">{</span> <span class="string">pg_server_prepare</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>You can even toggle between the two as you go:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">22</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">44</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_server_prepare</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">66</span><span class="operator">);</span>
</code></code></pre>

<p>In the above example, the first execute will use the previously prepared statement. The second execute will not, but will build the query into a single string and send it to the server. The third one will act like the first and only send the arguments. Even if you toggle back and forth, a statement is only prepared once.</p>

<p>Using prepared statements is in theory quite a bit faster: not only does the PostgreSQL backend only have to prepare the query only once, but DBD::Pg no longer has to worry about quoting each value before sending it to the server.</p>

<p>However, there are some drawbacks. The server cannot always choose the ideal parse plan because it will not know the arguments before hand. But for most situations in which you will be executing similar data many times, the default plan will probably work out well. Programs such as PgBouncer which cache connections at a low level should not use prepared statements via DBD::Pg, or must take extra care in the application to account for the fact that prepared statements are not shared across database connections. Further discussion on this subject is beyond the scope of this documentation: please consult the pgsql-performance mailing list, <a href="http://archives.postgresql.org/pgsql-performance/">http://archives.postgresql.org/pgsql-performance/</a></p>

<p>Only certain commands will be sent to a server-side prepare: currently these include <code><code>SELECT</code></code>, <code><code>INSERT</code></code>, <code><code>UPDATE</code></code>, and <code><code>DELETE</code></code>. DBD::Pg uses a simple naming scheme for the prepared statements themselves: <b>dbdpg_XY_Z</b>, where <b>Y</b> is the current PID, <b>X</b> is either &#39;p&#39; or &#39;n&#39; (depending on if the PID is a positive or negative number), and <b>Z</b> is a number that starts at 1 and increases each time a new statement is prepared. This number is tracked at the database handle level, so multiple statement handles will not collide.</p>

<p>You cannot send more than one command at a time in the same prepare command (by separating them with semi-colons) when using server-side prepares.</p>

<p>The actual <code><code>PREPARE</code></code> is usually not performed until the first execute is called, due to the fact that information on the data types (provided by <a href="#bind_param">&quot;bind_param&quot;</a>) may be provided after the prepare but before the execute.</p>

<p>A server-side prepare may happen before the first <a href="#execute">&quot;execute&quot;</a>, but only if the server can handle the server-side prepare, and the statement contains no placeholders. It will also be prepared if the <a href="#pg_prepare_now">&quot;pg_prepare_now&quot;</a> attribute is passed in and set to a true value. Similarly, the <a href="#pg_prepare_now">&quot;pg_prepare_now&quot;</a> attribute can be set to 0 to ensure that the statement is <b>not</b> prepared immediately, although the cases in which you would want this are very rare. Finally, you can set the default behavior of all prepare statements by setting the <a href="#pg_prepare_now">&quot;pg_prepare_now&quot;</a> attribute on the database handle:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_prepare_now</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</code></code></pre>

<p>The following two examples will be prepared right away:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123"</span><span class="operator">);</span> <span class="comment">## no placeholders</span>
  
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123, ?"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_prepare_now</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>The following two examples will NOT be prepared right away:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123, ?"</span><span class="operator">);</span> <span class="comment">## has a placeholder</span>
  
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 123"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_prepare_now</span> <span class="operator">=&gt;</span> <span class="number">0</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>There are times when you may want to prepare a statement yourself. To do this, simply send the <code><code>PREPARE</code></code> statement directly to the server (e.g. with the <a href="#do">&quot;do&quot;</a> method). Create a statement handle and set the prepared name via the <a href="#pg_prepare_name">&quot;pg_prepare_name&quot;</a> attribute. The statement handle can be created with a dummy statement, as it will not be executed. However, it should have the same number of placeholders as your prepared statement. Example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'PREPARE mystat AS SELECT COUNT(*) FROM pg_class WHERE reltuples &lt; ?'</span><span class="operator">);</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'SELECT ?'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="variable">SQL_INTEGER</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_prepare_name</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'mystat'</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">);</span>
</code></code></pre>

<p>The above will run the equivalent of this query on the backend:</p>

<pre><code><code>  <span class="variable">EXECUTE</span> <span class="variable">mystat</span><span class="operator">(</span><span class="number">123</span><span class="operator">);</span>
</code></code></pre>

<p>which is the equivalent of:</p>

<pre><code><code>  <span class="variable">SELECT</span> <span class="variable">COUNT</span><span class="operator">(*)</span> <span class="variable">FROM</span> <span class="variable">pg_class</span> <span class="variable">WHERE</span> <span class="variable">reltuples</span> <span class="operator">&lt;</span> <span class="number">123</span><span class="operator">;</span>
</code></code></pre>

<p>You can force DBD::Pg to send your query directly to the server by adding the <a href="#pg_direct">&quot;pg_direct&quot;</a> attribute to your prepare call. This is not recommended, but is added just in case you need it.</p>

<h4 id="Placeholders"><b>Placeholders</b></h4>

<p>There are three types of placeholders that can be used in DBD::Pg. The first is the &quot;question mark&quot; type, in which each placeholder is represented by a single question mark character. This is the method recommended by the DBI specs and is the most portable. Each question mark is internally replaced by a &quot;dollar sign number&quot; in the order in which they appear in the query (important when using <a href="#bind_param">&quot;bind_param&quot;</a>).</p>

<p>The method second type of placeholder is &quot;dollar sign numbers&quot;. This is the method that Postgres uses internally and is overall probably the best method to use if you do not need compatibility with other database systems. DBD::Pg, like PostgreSQL, allows the same number to be used more than once in the query. Numbers must start with &quot;1&quot; and increment by one value (but can appear in any order within the query). If the same number appears more than once in a query, it is treated as a single parameter and all instances are replaced at once. Examples:</p>

<p>Not legal:</p>

<pre><code><code>  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $2'</span><span class="operator">;</span> <span class="comment"># Does not start with 1</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $3'</span><span class="operator">;</span> <span class="comment"># Missing 2</span>
</code></code></pre>

<p>Legal:</p>

<pre><code><code>  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $1'</span><span class="operator">;</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2'</span><span class="operator">;</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $2 AND $1'</span><span class="operator">;</span> <span class="comment"># legal but confusing</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages BETWEEN $1 AND $2 AND reltuples &gt; $1'</span><span class="operator">;</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'SELECT count(*) FROM pg_class WHERE relpages &gt; $1 AND reltuples &gt; $1'</span><span class="operator">;</span>
</code></code></pre>

<p>In the final statement above, DBI thinks there is only one placeholder, so this statement will replace both placeholders:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">2045</span><span class="operator">);</span>
</code></code></pre>

<p>While a simple execute with no bind_param calls requires only a single argument as well:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">2045</span><span class="operator">);</span>
</code></code></pre>

<p>The final placeholder type is &quot;named parameters&quot; in the format &quot;:foo&quot;. While this syntax is supported by DBD::Pg, its use is discouraged in favor of dollar-sign numbers.</p>

<p>The different types of placeholders cannot be mixed within a statement, but you may use different ones for each statement handle you have. This is confusing at best, so stick to one style within your program.</p>

<p>If your queries use operators that contain question marks (e.g. some of the native Postgres geometric operators) or array slices (e.g. <code><code>data[100:300]</code></code>), you can tell DBD::Pg to ignore any non-dollar sign placeholders by setting the <a href="#pg_placeholder_dollaronly">&quot;pg_placeholder_dollaronly&quot;</a> attribute at either the database handle or the statement handle level. Examples:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_placeholder_dollaronly</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT * FROM mytable WHERE lseg1 ?# lseg2 AND name = $1}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'segname'</span><span class="operator">);</span>
</code></code></pre>

<p>Alternatively, you can set it at prepare time:</p>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT * FROM mytable WHERE lseg1 ?-| lseg2 AND name = $1}</span><span class="operator">,</span>
    <span class="operator">{</span><span class="variable">pg_placeholder_dollaronly</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'segname'</span><span class="operator">);</span>
</code></code></pre>

<h3 id="prepare_cached"><b>prepare_cached</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare_cached</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</code></code></pre>

<p>Implemented by DBI, no driver-specific impact. This method is most useful when using a server that supports server-side prepares, and you have asked the prepare to happen immediately via the <a href="#pg_prepare_now">&quot;pg_prepare_now&quot;</a> attribute.</p>

<h3 id="do"><b>do</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Prepare and execute a single statement. Returns the number of rows affected if the query was successful, returns undef if an error occurred, and returns -1 if the number of rows is unknown or not available. Note that this method will return <b>0E0</b> instead of 0 for &#39;no rows were affected&#39;, in order to always return a true value if no error occurred.</p>

<p>If neither <code><code>\%attr</code></code> nor <code><code>@bind_values</code></code> is given, the query will be sent directly to the server without the overhead of internally creating a statement handle and running prepare and execute, for a measurable speed increase.</p>

<p>Note that an empty statement (a string with no length) will not be passed to the server; if you want a simple test, use &quot;SELECT 123&quot; or the <a href="#ping">&quot;ping&quot;</a> method.</p>

<h3 id="last_insert_id"><b>last_insert_id</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="operator">{</span><span class="string">sequence</span> <span class="operator">=&gt;</span> <span class="variable">$seqname</span><span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p>Attempts to return the id of the last value to be inserted into a table. You can either provide a sequence name (preferred) or provide a table name with optional schema, and DBD::Pg will attempt to find the sequence itself. The current value of the sequence is returned by a call to the <code><code>CURRVAL()</code></code> PostgreSQL function. This will fail if the sequence has not yet been used in the current database connection.</p>

<p>If you do not know the name of the sequence, you can provide a table name and DBD::Pg will attempt to return the correct value. To do this, there must be at least one column in the table with a <code><code>NOT NULL</code></code> constraint, that has a unique constraint, and which uses a sequence as a default value. If more than one column meets these conditions, the primary key will be used. This involves some looking up of things in the system table, so DBD::Pg will cache the sequence name for subsequent calls. If you need to disable this caching for some reason, (such as the sequence name changing), you can control it by adding <code><code>pg_cache =&gt; 0</code></code> to the final (hashref) argument for last_insert_id.</p>

<p>Please keep in mind that this method is far from foolproof, so make your script use it properly. Specifically, make sure that it is called immediately after the insert, and that the insert does not add a value to the column that is using the sequence as a default value. However, because we are using sequences, you can be sure that the value you got back has not been used by any other process.</p>

<p>Some examples:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'CREATE SEQUENCE lii_seq START 1'</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{CREATE TABLE lii (
    foobar INTEGER NOT NULL UNIQUE DEFAULT nextval('lii_seq'),
    baz VARCHAR)}</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'INSERT INTO lii(baz) VALUES (?)'</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="string">qw(uno dos tres cuatro)</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$newid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="operator">{</span><span class="string">sequence</span><span class="operator">=&gt;</span><span class="string">'lii_seq'</span><span class="operator">}</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"Last insert id was </span><span class="variable">$newid</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>If you did not want to worry about the sequence name:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'CREATE TABLE lii2 (
    foobar SERIAL UNIQUE,
    baz VARCHAR)'</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">'INSERT INTO lii2(baz) VALUES (?)'</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="operator">(</span><span class="string">qw(uno dos tres cuatro)</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$newid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">last_insert_id</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">,</span><span class="string">"lii2"</span><span class="operator">,</span><span class="keyword">undef</span><span class="operator">);</span>
    <span class="keyword">print</span> <span class="string">"Last insert id was </span><span class="variable">$newid</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h3 id="commit"><b>commit</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">;</span>
</code></code></pre>

<p>Issues a COMMIT to the server, indicating that the current transaction is finished and that all changes made will be visible to other processes. If AutoCommit is enabled, then a warning is given and no COMMIT is issued. Returns true on success, false on error. See also the the section on <a href="#Transactions">&quot;Transactions&quot;</a>.</p>

<h3 id="rollback"><b>rollback</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">rollback</span><span class="operator">;</span>
</code></code></pre>

<p>Issues a ROLLBACK to the server, which discards any changes made in the current transaction. If AutoCommit is enabled, then a warning is given and no ROLLBACK is issued. Returns true on success, and false on error. See also the the section on <a href="#Transactions">&quot;Transactions&quot;</a>.</p>

<h3 id="begin_work"><b>begin_work</b></h3>

<p>This method turns on transactions until the next call to <a href="#commit">&quot;commit&quot;</a> or <a href="#rollback">&quot;rollback&quot;</a>, if <a href="#AutoCommit">&quot;AutoCommit&quot;</a> is currently enabled. If it is not enabled, calling begin_work will issue an error. Note that the transaction will not actually begin until the first statement after begin_work is called. Example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">'INSERT INTO foo VALUES (123)'</span><span class="operator">);</span> <span class="comment">## Changes committed immediately</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">begin_work</span><span class="operator">();</span>
  <span class="comment">## Not in a transaction yet, but AutoCommit is set to 0</span>
  
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"INSERT INTO foo VALUES (345)"</span><span class="operator">);</span>
  <span class="comment">## DBD::PG actually issues two statements here:</span>
  <span class="comment">## BEGIN;</span>
  <span class="comment">## INSERT INTO foo VALUES (345)</span>
  <span class="comment">## We are now in a transaction</span>
  
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">();</span>
  <span class="comment">## AutoCommit is now set to 1 again</span>
</code></code></pre>

<h3 id="disconnect"><b>disconnect</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">disconnect</span><span class="operator">;</span>
</code></code></pre>

<p>Disconnects from the Postgres database. Any uncommitted changes will be rolled back upon disconnection. It&#39;s good policy to always explicitly call commit or rollback at some point before disconnecting, rather than relying on the default rollback behavior.</p>

<p>This method may give warnings about &quot;disconnect invalidates X active statement handle(s)&quot;. This means that you called <code><code>$sth-&gt;execute()</code></code> but did not finish fetching all the rows from them. To avoid seeing this warning, either fetch all the rows or call <code><code>$sth-&gt;finish()</code></code> for each executed statement handle.</p>

<p>If the script exits before disconnect is called (or, more precisely, if the database handle is no longer referenced by anything), then the database handle&#39;s DESTROY method will call the rollback() and disconnect() methods automatically. It is best to explicitly disconnect rather than rely on this behavior.</p>

<h3 id="quote"><b>quote</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">,</span> <span class="variable">$data_type</span><span class="operator">);</span>
</code></code></pre>

<p>This module implements its own <code><code>quote</code></code> method. For simple string types, both backslashes and single quotes are doubled. You may also quote arrayrefs and receive a string suitable for passing into Postgres array columns.</p>

<p>If the value contains backslashes, and the server is version 8.1 or higher, then the escaped string syntax will be used (which places a capital E before the first single quote). This syntax is always used when quoting bytea values on servers 8.1 and higher.</p>

<p>The <code><code>data_type</code></code> argument is optional and should be one of the type constants exported by DBD::Pg (such as PG_BYTEA). In addition to string, bytea, char, bool, and other standard types, the following geometric types are supported: point, line, lseg, box, path, polygon, and circle (PG_POINT, PG_LINE, PG_LSEG, PG_BOX, PG_PATH, PG_POLYGON, and PG_CIRCLE respectively). To quote a Postgres-specific data type, you must use a &#39;hashref&#39; argument like so:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$quotedval</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote</span><span class="operator">(</span><span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_VARCHAR</span> <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<p><b>NOTE:</b> The undocumented (and invalid) support for the <code><code>SQL_BINARY</code></code> data type is officially deprecated. Use <code><code>PG_BYTEA</code></code> with <code><code>bind_param()</code></code> instead:</p>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span>
                         <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_BYTEA</span> <span class="operator">}</span><span class="operator">);</span>
</code></code></pre>

<h3 id="quote_identifier"><b>quote_identifier</b></h3>

<pre><code><code>  <span class="variable">$string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span> <span class="variable">$name</span> <span class="operator">);</span>
  <span class="variable">$string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">);</span>
</code></code></pre>

<p>Returns a quoted version of the supplied string, which is commonly a schema, table, or column name. The three argument form will return the schema and the table together, separated by a dot. Examples:</p>

<pre><code><code>  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="string">'grapefruit'</span><span class="operator">);</span> <span class="comment">## Prints: "grapefruit"</span>
  
  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="string">'juicy fruit'</span><span class="operator">);</span> <span class="comment">## Prints: "juicy fruit"</span>
  
  <span class="keyword">print</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">quote_identifier</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="string">'public'</span><span class="operator">,</span> <span class="string">'pg_proc'</span><span class="operator">);</span>
  <span class="comment">## Prints: "public"."pg_proc"</span>
</code></code></pre>

<h3 id="pg_notifies"><b>pg_notifies</b></h3>

<pre><code><code>  <span class="variable">$ret</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_notifies</span><span class="operator">;</span>
</code></code></pre>

<p>Looks for any asynchronous notifications received and returns either <code><code>undef</code></code> or a reference to a three-element array consisting of an event name, the PID of the backend that sent the NOTIFY command, and the optional payload string. Note that this does not check if the connection to the database is still valid first - for that, use the c&lt;ping&gt; method. You may need to commit if not in autocommit mode - new notices will not be picked up while in the middle of a transaction. An example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"LISTEN abc"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"LISTEN def"</span><span class="operator">);</span>
  
  <span class="comment">## Hang around until we get the message we want</span>
  <span class="variable">LISTENLOOP</span><span class="operator">:</span> <span class="operator">{</span>
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$notify</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_notifies</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$name</span><span class="operator">,</span> <span class="variable">$pid</span><span class="operator">,</span> <span class="variable">$payload</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@$notify</span><span class="operator">;</span>
      <span class="keyword">print</span> <span class="string">qq{I received notice "</span><span class="variable">$name</span><span class="string">" from PID </span><span class="variable">$pid</span><span class="string">, payload was "</span><span class="variable">$payload</span><span class="string">"\n}</span><span class="operator">;</span>
      <span class="comment">## Do something based on the notice received</span>
    <span class="operator">}</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ping</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">qq{Ping failed!}</span><span class="operator">;</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">commit</span><span class="operator">();</span>
    <span class="keyword">sleep</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span>
    <span class="keyword">redo</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<p>Payloads will always be an empty string unless you are connecting to a Postgres server version 9.0 or higher.</p>

<h3 id="ping"><b>ping</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ping</span><span class="operator">;</span>
</code></code></pre>

<p>This <code><code>ping</code></code> method is used to check the validity of a database handle. The value returned is either 0, indicating that the connection is no longer valid, or a positive integer, indicating the following:</p>

<pre><code><code>  Value    Meaning
  --------------------------------------------------
    1      Database is idle (not in a transaction)
    2      Database is active, there is a command in progress (usually seen after a COPY command)
    3      Database is idle within a transaction
    4      Database is idle, within a failed transaction</code></code></pre>

<p>Additional information on why a handle is not valid can be obtained by using the <a href="#pg_ping">&quot;pg_ping&quot;</a> method.</p>

<h3 id="pg_ping"><b>pg_ping</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ping</span><span class="operator">;</span>
</code></code></pre>

<p>This is a DBD::Pg-specific extension to the <a href="#ping">&quot;ping&quot;</a> method. This will check the validity of a database handle in exactly the same way as <code><code>ping</code></code>, but instead of returning a 0 for an invalid connection, it will return a negative number. So in addition to returning the positive numbers documented for <code><code>ping</code></code>, it may also return the following:</p>

<pre><code><code>  Value    Meaning
  --------------------------------------------------
   -1      There is no connection to the database at all (e.g. after disconnect)
   -2      An unknown transaction status was returned (e.g. after forking)
   -3      The handle exists, but no data was returned from a test query.</code></code></pre>

<p>In practice, you should only ever see -1 and -2.</p>

<h3 id="get_info"><b>get_info</b></h3>

<pre><code><code>  <span class="variable">$value</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">get_info</span><span class="operator">(</span><span class="variable">$info_type</span><span class="operator">);</span>
</code></code></pre>

<p>Supports a very large set (&gt; 250) of the information types, including the minimum recommended by DBI.</p>

<h3 id="table_info"><b>table_info</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">);</span>
</code></code></pre>

<p>Returns all tables and views visible to the current user. The schema and table arguments will do a <code><code>LIKE</code></code> search if a percent sign (<code><code>%</code></code>) or an underscore (<code><code>_</code></code>) is detected in the argument. The <code><code>$type</code></code> argument accepts a value of either &quot;TABLE&quot; or &quot;VIEW&quot; (using both is the default action). Note that a statement handle is returned, and not a direct list of tables. See the examples below for ways to handle this.</p>

<p>The following fields are returned:</p>

<p><b>TABLE_CAT</b>: Always NULL, as Postgres does not have the concept of catalogs.</p>

<p><b>TABLE_SCHEM</b>: The name of the schema that the table or view is in.</p>

<p><b>TABLE_NAME</b>: The name of the table or view.</p>

<p><b>TABLE_TYPE</b>: The type of object returned. Will be one of &quot;TABLE&quot;, &quot;VIEW&quot;, or &quot;SYSTEM TABLE&quot;.</p>

<p>The TABLE_SCHEM and TABLE_NAME will be quoted via <code><code>quote_ident()</code></code>.</p>

<p>Two additional fields specific to DBD::Pg are returned:</p>

<p><b>pg_schema</b>: the unquoted name of the schema</p>

<p><b>pg_table</b>: the unquoted name of the table</p>

<p>If your database supports tablespaces (version 8.0 or greater), two additional DBD::Pg specific fields are returned:</p>

<p><b>pg_tablespace_name</b>: the name of the tablespace the table is in</p>

<p><b>pg_tablespace_location</b>: the location of the tablespace the table is in</p>

<p>Tables that have not been assigned to a particular tablespace (or views) will return NULL (<code><code>undef</code></code>) for both of the above field.</p>

<p>Rows are returned alphabetically, with all tables first, and then all views.</p>

<p>Examples of use:</p>

<pre><code><code>  <span class="comment">## Display all tables and views in the public schema:</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="string">'public'</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$rel</span> <span class="operator">(</span><span class="variable">@</span><span class="operator">{</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span><span class="operator">{}</span><span class="operator">)</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"</span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_TYPE} name is </span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_NAME}\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  
  <span class="comment"># Display the schema of all tables named 'foo':</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">table_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="string">'foo'</span><span class="operator">,</span> <span class="string">'TABLE'</span><span class="operator">);</span>
  <span class="keyword">for</span> <span class="keyword">my</span> <span class="variable">$rel</span> <span class="operator">(</span><span class="variable">@</span><span class="operator">{</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span><span class="operator">{}</span><span class="operator">)</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Table name is </span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_SCHEM}.</span><span class="variable">$rel</span><span class="string">-&gt;{TABLE_NAME}\n"</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h3 id="column_info"><b>column_info</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">column_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$column</span> <span class="operator">);</span>
</code></code></pre>

<p>Supported by this driver as proposed by DBI with the follow exceptions. These fields are currently always returned with NULL (<code><code>undef</code></code>) values:</p>

<pre><code><code>   TABLE_CAT
   BUFFER_LENGTH
   DECIMAL_DIGITS
   NUM_PREC_RADIX
   SQL_DATA_TYPE
   SQL_DATETIME_SUB
   CHAR_OCTET_LENGTH</code></code></pre>

<p>Also, six additional non-standard fields are returned:</p>

<p><b>pg_type</b>: data type with additional info i.e. &quot;character varying(20)&quot;</p>

<p><b>pg_constraint</b>: holds column constraint definition</p>

<p><b>pg_schema</b>: the unquoted name of the schema</p>

<p><b>pg_table</b>: the unquoted name of the table</p>

<p><b>pg_column</b>: the unquoted name of the column</p>

<p><b>pg_enum_values</b>: an array reference of allowed values for an enum column</p>

<p>Note that the TABLE_SCHEM, TABLE_NAME, and COLUMN_NAME fields all return output wrapped in quote_ident(). If you need the unquoted version, use the pg_ fields above.</p>

<h3 id="primary_key_info"><b>primary_key_info</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
</code></code></pre>

<p>Supported by this driver as proposed by DBI. There are no search patterns allowed, but leaving the $schema argument blank will cause the first table found in the schema search path to be used. An additional field, &quot;DATA_TYPE&quot;, is returned and shows the data type for each of the arguments in the &quot;COLUMN_NAME&quot; field.</p>

<p>This method will also return tablespace information for servers that support tablespaces. See the <a href="#table_info">&quot;table_info&quot;</a> entry for more information.</p>

<p>The five additional custom fields returned are:</p>

<p><b>pg_tablespace_name</b>: name of the tablespace, if any</p>

<p><b>pg_tablespace_location</b>: location of the tablespace</p>

<p><b>pg_schema</b>: the unquoted name of the schema</p>

<p><b>pg_table</b>: the unquoted name of the table</p>

<p><b>pg_column</b>: the unquoted name of the column</p>

<p>In addition to the standard format of returning one row for each column found for the primary key, you can pass the <code><code>pg_onerow</code></code> attribute to force a single row to be used. If the primary key has multiple columns, the &quot;KEY_SEQ&quot;, &quot;COLUMN_NAME&quot;, and &quot;DATA_TYPE&quot; fields will return a comma-delimited string. If the <code><code>pg_onerow</code></code> attribute is set to &quot;2&quot;, the fields will be returned as an arrayref, which can be useful when multiple columns are involved:</p>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key_info</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">'dbd_pg_test'</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_onerow</span> <span class="operator">=&gt;</span> <span class="number">2</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="keyword">defined</span> <span class="variable">$sth</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$pk</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">print</span> <span class="string">"Table </span><span class="variable">$pk</span><span class="string">-&gt;[2] has a primary key on these columns:\n"</span><span class="operator">;</span>
    <span class="keyword">for</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$x</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span> <span class="keyword">defined</span> <span class="variable">$pk</span><span class="operator">-&gt;</span><span class="operator">[</span><span class="number">3</span><span class="operator">][</span><span class="variable">$x</span><span class="operator">]</span><span class="operator">;</span> <span class="variable">$x</span><span class="operator">++)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="string">"Column: </span><span class="variable">$pk</span><span class="string">-&gt;[3][</span><span class="variable">$x</span><span class="string">]  (data type: </span><span class="variable">$pk</span><span class="string">-&gt;[6][</span><span class="variable">$x</span><span class="string">])\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
</code></code></pre>

<h3 id="primary_key"><b>primary_key</b></h3>

<pre><code><code>  <span class="variable">@key_column_names</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">primary_key</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">);</span>
</code></code></pre>

<p>Simple interface to the <a href="#primary_key_info">&quot;primary_key_info&quot;</a> method. Returns a list of the column names that comprise the primary key of the specified table. The list is in primary key column sequence order. If there is no primary key then an empty list is returned.</p>

<h3 id="foreign_key_info"><b>foreign_key_info</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">foreign_key_info</span><span class="operator">(</span> <span class="variable">$pk_catalog</span><span class="operator">,</span> <span class="variable">$pk_schema</span><span class="operator">,</span> <span class="variable">$pk_table</span><span class="operator">,</span>
                                 <span class="variable">$fk_catalog</span><span class="operator">,</span> <span class="variable">$fk_schema</span><span class="operator">,</span> <span class="variable">$fk_table</span> <span class="operator">);</span>
</code></code></pre>

<p>Supported by this driver as proposed by DBI, using the SQL/CLI variant. There are no search patterns allowed, but leaving the <code><code>$schema</code></code> argument blank will cause the first table found in the schema search path to be used. Two additional fields, &quot;UK_DATA_TYPE&quot; and &quot;FK_DATA_TYPE&quot;, are returned to show the data type for the unique and foreign key columns. Foreign keys that have no named constraint (where the referenced column only has an unique index) will return <code><code>undef</code></code> for the &quot;UK_NAME&quot; field.</p>

<h3 id="statistics_info"><b>statistics_info</b></h3>

<pre><code><code>  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">statistics_info</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$unique_only</span><span class="operator">,</span> <span class="variable">$quick</span> <span class="operator">);</span>
</code></code></pre>

<p>Returns a statement handle that can be fetched from to give statistics information on a specific table and its indexes. The <code><code>$table</code></code> argument is mandatory. The <code><code>$schema</code></code> argument is optional but recommended. The <code><code>$unique_only</code></code> argument, if true, causes only information about unique indexes to be returned. The <code><code>$quick</code></code> argument is not used by DBD::Pg. For information on the format of the rows returned, please see the DBI documentation.</p>



<a href="http://search.cpan.org/~timb/DBI/DBI.pm#statistics_info">DBI section on statistics_info</a>

<h3 id="tables"><b>tables</b></h3>

<pre><code><code>  <span class="variable">@names</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">(</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">$schema</span><span class="operator">,</span> <span class="variable">$table</span><span class="operator">,</span> <span class="variable">$type</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
</code></code></pre>

<p>Supported by this driver as proposed by DBI. This method returns all tables and/or views which are visible to the current user: see <a href="#table_info">&quot;table_info&quot;</a> for more information about the arguments. The name of the schema appears before the table or view name. This can be turned off by adding in the <code><code>pg_noprefix</code></code> attribute:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">@tables</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">tables</span><span class="operator">(</span> <span class="string">''</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="string">'dbd_pg_test'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_noprefix</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">}</span> <span class="operator">);</span>
</code></code></pre>

<h3 id="type_info_all"><b>type_info_all</b></h3>

<pre><code><code>  <span class="variable">$type_info_all</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">type_info_all</span><span class="operator">;</span>
</code></code></pre>

<p>Supported by this driver as proposed by DBI. Information is only provided for SQL datatypes and for frequently used datatypes. The mapping between the PostgreSQL typename and the SQL92 datatype (if possible) has been done according to the following table:</p>

<pre><code><code>  +---------------+------------------------------------+
  | typname       | SQL92                              |
  |---------------+------------------------------------|
  | bool          | BOOL                               |
  | text          | /                                  |
  | bpchar        | CHAR(n)                            |
  | varchar       | VARCHAR(n)                         |
  | int2          | SMALLINT                           |
  | int4          | INT                                |
  | int8          | /                                  |
  | money         | /                                  |
  | float4        | FLOAT(p)   p&lt;7=float4, p&lt;16=float8 |
  | float8        | REAL                               |
  | abstime       | /                                  |
  | reltime       | /                                  |
  | tinterval     | /                                  |
  | date          | /                                  |
  | time          | /                                  |
  | datetime      | /                                  |
  | timespan      | TINTERVAL                          |
  | timestamp     | TIMESTAMP                          |
  +---------------+------------------------------------+</code></code></pre>

<h3 id="type_info"><b>type_info</b></h3>

<pre><code><code>  <span class="variable">@type_info</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">type_info</span><span class="operator">(</span><span class="variable">$data_type</span><span class="operator">);</span>
</code></code></pre>

<p>Returns a list of hash references holding information about one or more variants of $data_type. See the DBI documentation for more details.</p>

<h3 id="pg_server_trace"><b>pg_server_trace</b></h3>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_trace</span><span class="operator">(</span><span class="variable">$filehandle</span><span class="operator">);</span>
</code></code></pre>

<p>Writes debugging information from the PostgreSQL backend to a file. This is not related to the DBI <a href="#trace">&quot;trace&quot;</a> method and you should not use this method unless you know what you are doing. If you do enable this, be aware that the file will grow very large, very quick. To stop logging to the file, use the <a href="#pg_server_untrace">&quot;pg_server_untrace&quot;</a> method. The first argument must be a file handle, not a filename. Example:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$pid</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_pid</span><span class="operator">}</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$file</span> <span class="operator">=</span> <span class="string">"pgbackend.</span><span class="variable">$pid</span><span class="string">.debug.log"</span><span class="operator">;</span>
  <span class="keyword">open</span><span class="operator">(</span><span class="keyword">my</span> <span class="variable">$fh</span><span class="operator">,</span> <span class="string">"&gt;</span><span class="variable">$file</span><span class="string">"</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">qq{Could not open "</span><span class="variable">$file</span><span class="string">": $!\n}</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_trace</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">);</span>
  <span class="comment">## Run code you want to trace here</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_untrace</span><span class="operator">;</span>
  <span class="keyword">close</span><span class="operator">(</span><span class="variable">$fh</span><span class="operator">);</span>
</code></code></pre>

<h3 id="pg_server_untrace"><b>pg_server_untrace</b></h3>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_server_untrace</span><span class="operator">;</span>
</code></code></pre>

<p>Stop server logging to a previously opened file.</p>

<h3 id="selectrow_array"><b>selectrow_array</b></h3>

<pre><code><code>  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">@row_ary</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Returns an array of row information after preparing and executing the provided SQL string. The rows are returned by calling <a href="#fetchrow_array">&quot;fetchrow_array&quot;</a>. The string can also be a statement handle generated by a previous prepare. Note that only the first row of data is returned. If called in a scalar context, only the first column of the first row is returned. Because this is not portable, it is not recommended that you use this method in that way.</p>

<h3 id="selectrow_arrayref"><b>selectrow_arrayref</b></h3>

<pre><code><code>  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_arrayref</span><span class="operator">(</span><span class="variable">$statement</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Exactly the same as <a href="#selectrow_array">&quot;selectrow_array&quot;</a>, except that it returns a reference to an array, by internal use of the <a href="#fetchrow_arrayref">&quot;fetchrow_arrayref&quot;</a> method.</p>

<h3 id="selectrow_hashref"><b>selectrow_hashref</b></h3>

<pre><code><code>  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_hashref</span><span class="operator">(</span><span class="variable">$sql</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Exactly the same as <a href="#selectrow_array">&quot;selectrow_array&quot;</a>, except that it returns a reference to an hash, by internal use of the <a href="#fetchrow_hashref">&quot;fetchrow_hashref&quot;</a> method.</p>

<h3 id="clone"><b>clone</b></h3>

<pre><code><code>  <span class="variable">$other_dbh</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">();</span>
</code></code></pre>

<p>Creates a copy of the database handle by connecting with the same parameters as the original handle, then trying to merge the attributes. See the DBI documentation for complete usage.</p>

<h2 id="Database-Handle-Attributes">Database Handle Attributes</h2>

<h3 id="AutoCommit-boolean-"><b>AutoCommit</b> (boolean)</h3>

<p>Supported by DBD::Pg as proposed by DBI. According to the classification of DBI, PostgreSQL is a database in which a transaction must be explicitly started. Without starting a transaction, every change to the database becomes immediately permanent. The default of AutoCommit is on, but this may change in the future, so it is highly recommended that you explicitly set it when calling <a href="#connect">&quot;connect&quot;</a>. For details see the notes about <a href="#Transactions">&quot;Transactions&quot;</a> elsewhere in this document.</p>

<h3 id="pg_bool_tf-boolean-"><b>pg_bool_tf</b> (boolean)</h3>

<p>DBD::Pg specific attribute. If true, boolean values will be returned as the characters &#39;t&#39; and &#39;f&#39; instead of &#39;1&#39; and &#39;0&#39;.</p>

<h3 id="ReadOnly-boolean-"><b>ReadOnly</b> (boolean)</h3>

<p>$dbh-&gt;{ReadOnly} = 1;</p>

<p>Specifies if the current database connection should be in read-only mode or not. In this mode, changes that change the database are not allowed and will throw an error. Note: this method will <b>not</b> work if <a href="#AutoCommit">&quot;AutoCommit&quot;</a> is true. The read-only effect is accomplished by sending a <span style="white-space: nowrap;">SET TRANSACTION READ ONLY</span> after every begin. For more details, please see:</p>

<p>http://www.postgresql.org/docs/current/interactive/sql-set-transaction.html</p>

<p>Please not that this method is not foolproof: there are still ways to update the database. Consider this a safety net to catch applications that should not be issuing commands such as INSERT, UPDATE, or DELETE.</p>

<p>This method method requires DBI version 1.55 or better.</p>

<h3 id="pg_server_prepare-integer-"><b>pg_server_prepare</b> (integer)</h3>

<p>DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side prepared statements. The default value, 1, indicates that prepared statements should be used whenever possible. See the section on the <a href="#prepare">&quot;prepare&quot;</a> method for more information.</p>

<h3 id="pg_placeholder_dollaronly-boolean-"><b>pg_placeholder_dollaronly</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Defaults to false. When true, question marks inside of statements are not treated as <a href="#Placeholders">placeholders</a>. Useful for statements that contain unquoted question marks, such as geometric operators.</p>

<h3 id="pg_enable_utf8-boolean-"><b>pg_enable_utf8</b> (boolean)</h3>

<p>DBD::Pg specific attribute. If true, then the <code><code>utf8</code></code> flag will be turned on for returned character data (if the data is valid UTF-8). For details about the <code><code>utf8</code></code> flag, see the <code><code>Encode</code></code> module. This attribute is only relevant under perl 5.8 and later.</p>

<h3 id="pg_errorlevel-integer-"><b>pg_errorlevel</b> (integer)</h3>

<p>DBD::Pg specific attribute. Sets the amount of information returned by the server&#39;s error messages. Valid entries are 0, 1, and 2. Any other number will be forced to the default value of 1.</p>

<p>A value of 0 (&quot;TERSE&quot;) will show severity, primary text, and position only and will usually fit on a single line. A value of 1 (&quot;DEFAULT&quot;) will also show any detail, hint, or context fields. A value of 2 (&quot;VERBOSE&quot;) will show all available information.</p>

<h3 id="pg_lib_version-integer-read-only-"><b>pg_lib_version</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Indicates which version of PostgreSQL that DBD::Pg was compiled against. In other words, which libraries were used. Returns a number with major, minor, and revision together; version 8.1.4 would be returned as <code><code>80104</code></code>.</p>

<h3 id="pg_server_version-integer-read-only-"><b>pg_server_version</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Indicates which version of PostgreSQL that the current database handle is connected to. Returns a number with major, minor, and revision together; version 8.0.1 would be <code><code>80001</code></code>.</p>

<h3 id="Name-string-read-only-"><b>Name</b> (string, read-only)</h3>

<p>Returns the name of the current database. This is the same as the DSN, without the &quot;dbi:Pg:&quot; part. Before version 2.0.0, this only returned the bare database name (e.g. &#39;foo&#39;). From version 2.0.0 onwards, it returns the more correct output (e.g. &#39;dbname=foo&#39;)</p>

<h3 id="Username-string-read-only-"><b>Username</b> (string, read-only)</h3>

<p>Returns the name of the user connected to the database.</p>

<h3 id="pg_db-string-read-only-"><b>pg_db</b> (string, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the name of the current database.</p>

<h3 id="pg_user-string-read-only-"><b>pg_user</b> (string, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the name of the user that connected to the server.</p>

<h3 id="pg_host-string-read-only-"><b>pg_host</b> (string, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the host of the current server connection. Locally connected hosts will return an empty string.</p>

<h3 id="pg_port-integer-read-only-"><b>pg_port</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the port of the connection to the server.</p>

<h3 id="pg_socket-integer-read-only-"><b>pg_socket</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the file description number of the connection socket to the server.</p>

<h3 id="pg_pass-string-read-only-"><b>pg_pass</b> (string, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the password used to connect to the server.</p>

<h3 id="pg_options-string-read-only-"><b>pg_options</b> (string, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the command-line options passed to the server. May be an empty string.</p>

<h3 id="pg_default_port-integer-read-only-"><b>pg_default_port</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the default port used if none is specifically given.</p>

<h3 id="pg_pid-integer-read-only-"><b>pg_pid</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the process id (PID) of the backend server process handling the connection.</p>

<h3 id="pg_prepare_now-boolean-"><b>pg_prepare_now</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Default is off. If true, then the <a href="#prepare">&quot;prepare&quot;</a> method will immediately prepare commands, rather than waiting until the first execute.</p>

<h3 id="pg_expand_array-boolean-"><b>pg_expand_array</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Defaults to true. If false, arrays returned from the server will not be changed into a Perl arrayref, but remain as a string.</p>

<h3 id="pg_async_status-integer-read-only-"><b>pg_async_status</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the current status of an <a href="#Asynchronous-Queries">asynchronous</a> command. 0 indicates no asynchronous command is in progress, 1 indicates that an asynchronous command has started and -1 indicated that an asynchronous command has been cancelled.</p>

<h3 id="pg_standard_conforming_strings-boolean-read-only-"><b>pg_standard_conforming_strings</b> (boolean, read-only)</h3>

<p>DBD::Pg specific attribute. Returns true if the server is currently using standard conforming strings. Only available if the target server is version 8.2 or better.</p>

<h3 id="pg_INV_READ-integer-read-only-"><b>pg_INV_READ</b> (integer, read-only)</h3>

<p>Constant to be used for the mode in <a href="#lo_creat">&quot;lo_creat&quot;</a> and <a href="#lo_open">&quot;lo_open&quot;</a>.</p>

<h3 id="pg_INV_WRITE-integer-read-only-"><b>pg_INV_WRITE</b> (integer, read-only)</h3>

<p>Constant to be used for the mode in <a href="#lo_creat">&quot;lo_creat&quot;</a> and <a href="#lo_open">&quot;lo_open&quot;</a>.</p>

<h3 id="Driver-handle-read-only-"><b>Driver</b> (handle, read-only)</h3>

<p>Holds the handle of the parent driver. The only recommended use for this is to find the name of the driver using:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Driver</span><span class="operator">}</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">Name</span><span class="operator">}</span>
</code></code></pre>

<h3 id="pg_protocol-integer-read-only-"><b>pg_protocol</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the version of the PostgreSQL server. If DBD::Pg is unable to figure out the version, it will return a &quot;0&quot;. Otherwise, a &quot;3&quot; is returned.</p>

<h3 id="RowCacheSize"><b>RowCacheSize</b></h3>

<p>Not used by DBD::Pg</p>

<h1 id="DBI-STATEMENT-HANDLE-OBJECTS">DBI STATEMENT HANDLE OBJECTS</h1>

<h2 id="Statement-Handle-Methods">Statement Handle Methods</h2>

<h3 id="bind_param"><b>bind_param</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="variable">$bind_type</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="variable">$bind_value</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span><span class="operator">);</span>
</code></code></pre>

<p>Allows the user to bind a value and/or a data type to a placeholder. This is especially important when using server-side prepares. See the <a href="#prepare">&quot;prepare&quot;</a> method for more information.</p>

<p>The value of <code><code>$param_num</code></code> is a number if using the &#39;?&#39; or &#39;$1&#39; style placeholders. If using &quot;:foo&quot; style placeholders, the complete name (e.g. &quot;:foo&quot;) must be given. For numeric values, you can either use a number or use a literal &#39;$1&#39;. See the examples below.</p>

<p>The <code><code>$bind_value</code></code> argument is fairly self-explanatory. A value of <code><code>undef</code></code> will bind a <code><code>NULL</code></code> to the placeholder. Using <code><code>undef</code></code> is useful when you want to change just the type and will be overwriting the value later. (Any value is actually usable, but <code><code>undef</code></code> is easy and efficient).</p>

<p>The <code><code>\%attr</code></code> hash is used to indicate the data type of the placeholder. The default value is &quot;varchar&quot;. If you need something else, you must use one of the values provided by DBI or by DBD::Pg. To use a SQL value, modify your &quot;use DBI&quot; statement at the top of your script as follows:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
</code></code></pre>

<p>This will import some constants into your script. You can plug those directly into the <a href="#bind_param">&quot;bind_param&quot;</a> call. Some common ones that you will encounter are:</p>

<pre><code><code>  SQL_INTEGER</code></code></pre>

<p>To use PostgreSQL data types, import the list of values like this:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
</code></code></pre>

<p>You can then set the data types by setting the value of the <code><code>pg_type</code></code> key in the hash passed to <a href="#bind_param">&quot;bind_param&quot;</a>. The current list of Postgres data types exported is:</p>

<pre><code><code> PG_ABSTIME PG_ABSTIMEARRAY PG_ACLITEM PG_ACLITEMARRAY PG_ANY PG_ANYARRAY
 PG_ANYELEMENT PG_ANYENUM PG_ANYNONARRAY PG_BIT PG_BITARRAY PG_BOOL
 PG_BOOLARRAY PG_BOX PG_BOXARRAY PG_BPCHAR PG_BPCHARARRAY PG_BYTEA
 PG_BYTEAARRAY PG_CHAR PG_CHARARRAY PG_CID PG_CIDARRAY PG_CIDR
 PG_CIDRARRAY PG_CIRCLE PG_CIRCLEARRAY PG_CSTRING PG_CSTRINGARRAY PG_DATE
 PG_DATEARRAY PG_FDW_HANDLER PG_FLOAT4 PG_FLOAT4ARRAY PG_FLOAT8 PG_FLOAT8ARRAY
 PG_GTSVECTOR PG_GTSVECTORARRAY PG_INET PG_INETARRAY PG_INT2 PG_INT2ARRAY
 PG_INT2VECTOR PG_INT2VECTORARRAY PG_INT4 PG_INT4ARRAY PG_INT8 PG_INT8ARRAY
 PG_INTERNAL PG_INTERVAL PG_INTERVALARRAY PG_LANGUAGE_HANDLER PG_LINE PG_LINEARRAY
 PG_LSEG PG_LSEGARRAY PG_MACADDR PG_MACADDRARRAY PG_MONEY PG_MONEYARRAY
 PG_NAME PG_NAMEARRAY PG_NUMERIC PG_NUMERICARRAY PG_OID PG_OIDARRAY
 PG_OIDVECTOR PG_OIDVECTORARRAY PG_OPAQUE PG_PATH PG_PATHARRAY PG_PG_ATTRIBUTE
 PG_PG_CLASS PG_PG_NODE_TREE PG_PG_PROC PG_PG_TYPE PG_POINT PG_POINTARRAY
 PG_POLYGON PG_POLYGONARRAY PG_RECORD PG_RECORDARRAY PG_REFCURSOR PG_REFCURSORARRAY
 PG_REGCLASS PG_REGCLASSARRAY PG_REGCONFIG PG_REGCONFIGARRAY PG_REGDICTIONARY PG_REGDICTIONARYARRAY
 PG_REGOPER PG_REGOPERARRAY PG_REGOPERATOR PG_REGOPERATORARRAY PG_REGPROC PG_REGPROCARRAY
 PG_REGPROCEDURE PG_REGPROCEDUREARRAY PG_REGTYPE PG_REGTYPEARRAY PG_RELTIME PG_RELTIMEARRAY
 PG_SMGR PG_TEXT PG_TEXTARRAY PG_TID PG_TIDARRAY PG_TIME
 PG_TIMEARRAY PG_TIMESTAMP PG_TIMESTAMPARRAY PG_TIMESTAMPTZ PG_TIMESTAMPTZARRAY PG_TIMETZ
 PG_TIMETZARRAY PG_TINTERVAL PG_TINTERVALARRAY PG_TRIGGER PG_TSQUERY PG_TSQUERYARRAY
 PG_TSVECTOR PG_TSVECTORARRAY PG_TXID_SNAPSHOT PG_TXID_SNAPSHOTARRAY PG_UNKNOWN PG_UUID
 PG_UUIDARRAY PG_VARBIT PG_VARBITARRAY PG_VARCHAR PG_VARCHARARRAY PG_VOID
 PG_XID PG_XIDARRAY PG_XML PG_XMLARRAY</code></code></pre>

<p>Data types are &quot;sticky,&quot; in that once a data type is set to a certain placeholder, it will remain for that placeholder, unless it is explicitly set to something else afterwards. If the statement has already been prepared, and you switch the data type to something else, DBD::Pg will re-prepare the statement for you before doing the next execute.</p>

<p>Examples:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBI</span> <span class="string">qw(:sql_types)</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">qw(:pg_types)</span><span class="operator">;</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"SELECT id FROM ptable WHERE size &gt; ? AND title = ?"</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  
  <span class="comment">## Both arguments below are bound to placeholders as "varchar"</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
  
  <span class="comment">## Reset the datatype for the first placeholder to an integer</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="keyword">undef</span><span class="operator">,</span> <span class="variable">SQL_INTEGER</span><span class="operator">);</span>
  
  <span class="comment">## The "undef" bound above is not used, since we supply params to execute</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">123</span><span class="operator">,</span> <span class="string">"Merk"</span><span class="operator">);</span>
  
  <span class="comment">## Set the first placeholder's value and data type</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">PG_TIMESTAMP</span> <span class="operator">}</span><span class="operator">);</span>
  
  <span class="comment">## Set the second placeholder's value and data type.</span>
  <span class="comment">## We don't send a third argument, so the default "varchar" is used</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$2'</span><span class="operator">,</span> <span class="string">"Zool"</span><span class="operator">);</span>
  
  <span class="comment">## We realize that the wrong data type was set above, so we change it:</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">'$1'</span><span class="operator">,</span> <span class="number">234</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">pg_type</span> <span class="operator">=&gt;</span> <span class="variable">SQL_INTEGER</span> <span class="operator">}</span><span class="operator">);</span>
  
  <span class="comment">## We also got the wrong value, so we change that as well.</span>
  <span class="comment">## Because the data type is sticky, we don't need to change it</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="number">567</span><span class="operator">);</span>
  
  <span class="comment">## This executes the statement with 567 (integer) and "Zool" (varchar)</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</code></code></pre>

<h3 id="bind_param_inout"><b>bind_param_inout</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="variable">$param_num</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$scalar</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
</code></code></pre>

<p>Experimental support for this feature is provided. The first argument to bind_param_inout should be a placeholder number. The second argument should be a reference to a scalar variable in your script. The third argument is not used and should simply be set to 0. Note that what this really does is assign a returned column to the variable, in the order in which the column appears. For example:</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">123</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 1+?::int"</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$foo</span><span class="operator">,</span> <span class="number">0</span><span class="operator">);</span>
  <span class="variable">$foo</span> <span class="operator">=</span> <span class="number">222</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">444</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">;</span>
</code></code></pre>

<p>The above will cause $foo to have a new value of &quot;223&quot; after the final fetch. Note that the variables bound in this manner are very sticky, and will trump any values passed in to execute. This is because the binding is done as late as possible, at the execute() stage, allowing the value to be changed between the time it was bound and the time the query is executed. Thus, the above execute is the same as:</p>

<pre><code><code>  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
</code></code></pre>

<h3 id="bind_param_array"><b>bind_param_array</b></h3>

<pre><code><code>  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, $bind_type)
  $rv = $sth-&gt;bind_param_array($param_num, $array_ref_or_value, \%attr)</code></code></pre>

<p>Binds an array of values to a placeholder, so that each is used in turn by a call to the <a href="#execute_array">&quot;execute_array&quot;</a> method.</p>

<h3 id="execute"><b>execute</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="variable">@bind_values</span><span class="operator">);</span>
</code></code></pre>

<p>Executes a previously prepared statement. In addition to <code><code>UPDATE</code></code>, <code><code>DELETE</code></code>, <code><code>INSERT</code></code> statements, for which it returns always the number of affected rows, the <code><code>execute</code></code> method can also be used for <code><code>SELECT ... INTO table</code></code> statements.</p>

<p>The &quot;prepare/bind/execute&quot; process has changed significantly for PostgreSQL servers 7.4 and later: please see the <code><code>prepare()</code></code> and <code><code>bind_param()</code></code> entries for much more information.</p>

<p>Setting one of the bind_values to &quot;undef&quot; is the equivalent of setting the value to NULL in the database. Setting the bind_value to $DBDPG_DEFAULT is equivalent to sending the literal string &#39;DEFAULT&#39; to the backend. Note that using this option will force server-side prepares off until such time as PostgreSQL supports using DEFAULT in prepared statements.</p>

<p>DBD::Pg also supports passing in arrays to execute: simply pass in an arrayref, and DBD::Pg will flatten it into a string suitable for input on the backend.</p>

<p>If you are using Postgres version 8.2 or greater, you can also use any of the fetch methods to retrieve the values of a <code><code>RETURNING</code></code> clause after you execute an <code><code>UPDATE</code></code>, <code><code>DELETE</code></code>, or <code><code>INSERT</code></code>. For example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">q{CREATE TABLE abc (id SERIAL, country TEXT)}</span><span class="operator">);</span>
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">q{INSERT INTO abc (country) VALUES (?) RETURNING id}</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'France'</span><span class="operator">);</span>
  <span class="variable">$countryid</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="string">'New Zealand'</span><span class="operator">);</span>
  <span class="variable">$countryid</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetch</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<h3 id="execute_array"><b>execute_array</b></h3>

<pre><code><code>  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">()</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_array</span><span class="operator">(\</span><span class="variable">%attr</span><span class="operator">,</span> <span class="variable">@bind_values</span><span class="operator">)</span> <span class="keyword">or</span> <span class="keyword">die</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span>
</code></code></pre>

<p>Execute a prepared statement once for each item in a passed-in hashref, or items that were previously bound via the <a href="#bind_param_array">&quot;bind_param_array&quot;</a> method. See the DBI documentation for more details.</p>

<h3 id="execute_for_fetch"><b>execute_for_fetch</b></h3>

<pre><code><code>  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="variable">$tuples</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
  
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">);</span>
  <span class="operator">(</span><span class="variable">$tuples</span><span class="operator">,</span> <span class="variable">$rows</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute_for_fetch</span><span class="operator">(</span><span class="variable">$fetch_tuple_sub</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@tuple_status</span><span class="operator">);</span>
</code></code></pre>

<p>Used internally by the <a href="#execute_array">&quot;execute_array&quot;</a> method, and rarely used directly. See the DBI documentation for more details.</p>

<h3 id="fetchrow_arrayref"><b>fetchrow_arrayref</b></h3>

<pre><code><code>  <span class="variable">$ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_arrayref</span><span class="operator">;</span>
</code></code></pre>

<p>Fetches the next row of data from the statement handle, and returns a reference to an array holding the column values. Any columns that are NULL are returned as undef within the array.</p>

<p>If there are no more rows or if an error occurs, the this method return undef. You should check <code><code>$sth-&gt;err</code></code> afterwards (or use the <a href="#RaiseError">&quot;RaiseError&quot;</a> attribute) to discover if the undef returned was due to an error.</p>

<p>Note that the same array reference is returned for each fetch, so don&#39;t store the reference and then use it after a later fetch. Also, the elements of the array are also reused for each row, so take care if you want to take a reference to an element. See also <a href="#bind_columns">&quot;bind_columns&quot;</a>.</p>

<h3 id="fetchrow_array"><b>fetchrow_array</b></h3>

<pre><code><code>  <span class="variable">@ary</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">;</span>
</code></code></pre>

<p>Similar to the <a href="#fetchrow_arrayref">&quot;fetchrow_arrayref&quot;</a> method, but returns a list of column information rather than a reference to a list. Do not use this in a scalar context.</p>

<h3 id="fetchrow_hashref"><b>fetchrow_hashref</b></h3>

<pre><code><code>  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">;</span>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">(</span><span class="variable">$name</span><span class="operator">);</span>
</code></code></pre>

<p>Fetches the next row of data and returns a hashref containing the name of the columns as the keys and the data itself as the values. Any NULL value is returned as as undef value.</p>

<p>If there are no more rows or if an error occurs, the this method return undef. You should check <code><code>$sth-&gt;err</code></code> afterwards (or use the <a href="#RaiseError">&quot;RaiseError&quot;</a> attribute) to discover if the undef returned was due to an error.</p>

<p>The optional <code><code>$name</code></code> argument should be either <code><code>NAME</code></code>, <code><code>NAME_lc</code></code> or <code><code>NAME_uc</code></code>, and indicates what sort of transformation to make to the keys in the hash.</p>

<h3 id="fetchall_arrayref"><b>fetchall_arrayref</b></h3>

<pre><code><code>  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">();</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span> <span class="operator">);</span>
  <span class="variable">$tbl_ary_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">(</span> <span class="variable">$slice</span><span class="operator">,</span> <span class="variable">$max_rows</span> <span class="operator">);</span>
</code></code></pre>

<p>Returns a reference to an array of arrays that contains all the remaining rows to be fetched from the statement handle. If there are no more rows, an empty arrayref will be returned. If an error occurs, the data read in so far will be returned. Because of this, you should always check <code><code>$sth-&gt;err</code></code> after calling this method, unless <a href="#RaiseError">&quot;RaiseError&quot;</a> has been enabled.</p>

<p>If <code><code>$slice</code></code> is an array reference, fetchall_arrayref uses the <a href="#fetchrow_arrayref">&quot;fetchrow_arrayref&quot;</a> method to fetch each row as an array ref. If the <code><code>$slice</code></code> array is not empty then it is used as a slice to select individual columns by perl array index number (starting at 0, unlike column and parameter numbers which start at 1).</p>

<p>With no parameters, or if $slice is undefined, fetchall_arrayref acts as if passed an empty array ref.</p>

<p>If <code><code>$slice</code></code> is a hash reference, fetchall_arrayref uses <a href="#fetchrow_hashref">&quot;fetchrow_hashref&quot;</a> to fetch each row as a hash reference.</p>

<p>See the DBI documentation for a complete discussion.</p>

<h3 id="fetchall_hashref"><b>fetchall_hashref</b></h3>

<pre><code><code>  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_hashref</span><span class="operator">(</span> <span class="variable">$key_field</span> <span class="operator">);</span>
</code></code></pre>

<p>Returns a hashref containing all rows to be fetched from the statement handle. See the DBI documentation for a full discussion.</p>

<h3 id="finish"><b>finish</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">finish</span><span class="operator">;</span>
</code></code></pre>

<p>Indicates to DBI that you are finished with the statement handle and are not going to use it again. Only needed when you have not fetched all the possible rows.</p>

<h3 id="rows"><b>rows</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">;</span>
</code></code></pre>

<p>Returns the number of rows returned by the last query. In contrast to many other DBD modules, the number of rows is available immediately after calling <code><code>$sth-&gt;execute</code></code>. Note that the <a href="#execute">&quot;execute&quot;</a> method itself returns the number of rows itself, which means that this method is rarely needed.</p>

<h3 id="bind_col"><b>bind_col</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%attr</span> <span class="operator">);</span>
  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_col</span><span class="operator">(</span><span class="variable">$column_number</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$var_to_bind</span><span class="operator">,</span> <span class="variable">$bind_type</span> <span class="operator">);</span>
</code></code></pre>

<p>Binds a Perl variable and/or some attributes to an output column of a SELECT statement. Column numbers count up from 1. You do not need to bind output columns in order to fetch data.</p>

<p>See the DBI documentation for a discussion of the optional parameters <code><code>\%attr</code></code> and <code><code>$bind_type</code></code></p>

<h3 id="bind_columns"><b>bind_columns</b></h3>

<pre><code><code>  <span class="variable">$rv</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_columns</span><span class="operator">(</span><span class="variable">@list_of_refs_to_vars_to_bind</span><span class="operator">);</span>
</code></code></pre>

<p>Calls the <a href="#bind_col">&quot;bind_col&quot;</a> method for each column in the SELECT statement, using the supplied list.</p>

<h3 id="dump_results"><b>dump_results</b></h3>

<pre><code><code>  <span class="variable">$rows</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">dump_results</span><span class="operator">(</span><span class="variable">$maxlen</span><span class="operator">,</span> <span class="variable">$lsep</span><span class="operator">,</span> <span class="variable">$fsep</span><span class="operator">,</span> <span class="variable">$fh</span><span class="operator">);</span>
</code></code></pre>

<p>Fetches all the rows from the statement handle, calls <code><code>DBI::neat_list</code></code> for each row, and prints the results to <code><code>$fh</code></code> (which defaults to <i>STDOUT</i>). Rows are separated by <code><code>$lsep</code></code> (which defaults to a newline). Columns are separated by <code><code>$fsep</code></code> (which defaults to a comma). The <code><code>$maxlen</code></code> controls how wide the output can be, and defaults to 35.</p>

<p>This method is designed as a handy utility for prototyping and testing queries. Since it uses &quot;neat_list&quot; to format and edit the string for reading by humans, it is not recommended for data transfer applications.</p>

<h3 id="blob_read"><b>blob_read</b></h3>

<pre><code><code>  <span class="variable">$blob</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">blob_read</span><span class="operator">(</span><span class="variable">$id</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$len</span><span class="operator">);</span>
</code></code></pre>

<p>Supported by DBD::Pg. This method is implemented by DBI but not currently documented by DBI, so this method might change.</p>

<p>This method seems to be heavily influenced by the current implementation of blobs in Oracle. Nevertheless we try to be as compatible as possible. Whereas Oracle suffers from the limitation that blobs are related to tables and every table can have only one blob (datatype LONG), PostgreSQL handles its blobs independent of any table by using so-called object identifiers. This explains why the <code><code>blob_read</code></code> method is blessed into the STATEMENT package and not part of the DATABASE package. Here the field parameter has been used to handle this object identifier. The offset and len parameters may be set to zero, in which case the whole blob is fetched at once.</p>

<p>See also the PostgreSQL-specific functions concerning blobs, which are available via the <code><code>func</code></code> interface.</p>

<p>For further information and examples about blobs, please read the chapter about Large Objects in the PostgreSQL Programmer&#39;s Guide at <a href="http://www.postgresql.org/docs/current/static/largeobjects.html">http://www.postgresql.org/docs/current/static/largeobjects.html</a>.</p>

<h2 id="Statement-Handle-Attributes">Statement Handle Attributes</h2>

<h3 id="NUM_OF_FIELDS-integer-read-only-"><b>NUM_OF_FIELDS</b> (integer, read-only)</h3>

<p>Returns the number of columns returned by the current statement. A number will only be returned for SELECT statements, for SHOW statements (which always return <code><code>1</code></code>), and for INSERT, UPDATE, and DELETE statements which contain a RETURNING clause. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="NUM_OF_PARAMS-integer-read-only-"><b>NUM_OF_PARAMS</b> (integer, read-only)</h3>

<p>Returns the number of placeholders in the current statement.</p>

<h3 id="NAME-arrayref-read-only-"><b>NAME</b> (arrayref, read-only)</h3>

<p>Returns an arrayref of column names for the current statement. This method will only work for SELECT statements, for SHOW statements, and for INSERT, UPDATE, and DELETE statements which contain a RETURNING clause. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="NAME_lc-arrayref-read-only-"><b>NAME_lc</b> (arrayref, read-only)</h3>

<p>The same as the <code><code>NAME</code></code> attribute, except that all column names are forced to lower case.</p>

<h3 id="NAME_uc-arrayref-read-only-"><b>NAME_uc</b> (arrayref, read-only)</h3>

<p>The same as the <code><code>NAME</code></code> attribute, except that all column names are forced to upper case.</p>

<h3 id="NAME_hash-hashref-read-only-"><b>NAME_hash</b> (hashref, read-only)</h3>

<p>Similar to the <code><code>NAME</code></code> attribute, but returns a hashref of column names instead of an arrayref. The names of the columns are the keys of the hash, and the values represent the order in which the columns are returned, starting at 0. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="NAME_lc_hash-hashref-read-only-"><b>NAME_lc_hash</b> (hashref, read-only)</h3>

<p>The same as the <code><code>NAME_hash</code></code> attribute, except that all column names are forced to lower case.</p>

<h3 id="NAME_uc_hash-hashref-read-only-"><b>NAME_uc_hash</b> (hashref, read-only)</h3>

<p>The same as the <code><code>NAME_hash</code></code> attribute, except that all column names are forced to lower case.</p>

<h3 id="TYPE-arrayref-read-only-"><b>TYPE</b> (arrayref, read-only)</h3>

<p>Returns an arrayref indicating the data type for each column in the statement. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="PRECISION-arrayref-read-only-"><b>PRECISION</b> (arrayref, read-only)</h3>

<p>Returns an arrayref of integer values for each column returned by the statement. The number indicates the precision for <code><code>NUMERIC</code></code> columns, the size in number of characters for <code><code>CHAR</code></code> and <code><code>VARCHAR</code></code> columns, and for all other types of columns it returns the number of <i>bytes</i>. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="SCALE-arrayref-read-only-"><b>SCALE</b> (arrayref, read-only)</h3>

<p>Returns an arrayref of integer values for each column returned by the statement. The number indicates the scale of the that column. The only type that will return a value is <code><code>NUMERIC</code></code>. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="NULLABLE-arrayref-read-only-"><b>NULLABLE</b> (arrayref, read-only)</h3>

<p>Returns an arrayref of integer values for each column returned by the statement. The number indicates if the column is nullable or not. 0 = not nullable, 1 = nullable, 2 = unknown. This method returns undef if called before <code><code>execute()</code></code>.</p>

<h3 id="Database-dbh-read-only-"><b>Database</b> (dbh, read-only)</h3>

<p>Returns the database handle this statement handle was created from.</p>

<h3 id="ParamValues-hash-ref-read-only-"><b>ParamValues</b> (hash ref, read-only)</h3>

<p>Returns a reference to a hash containing the values currently bound to placeholders. If the &quot;named parameters&quot; type of placeholders are being used (such as &quot;:foo&quot;), then the keys of the hash will be the names of the placeholders (without the colon). If the &quot;dollar sign numbers&quot; type of placeholders are being used, the keys of the hash will be the numbers, without the dollar signs. If the &quot;question mark&quot; type is used, integer numbers will be returned, starting at one and increasing for every placeholder.</p>

<p>If this method is called before <a href="#execute">&quot;execute&quot;</a>, the literal values passed in are returned. If called after <a href="#execute">&quot;execute&quot;</a>, then the quoted versions of the values are returned.</p>

<h3 id="ParamTypes-hash-ref-read-only-"><b>ParamTypes</b> (hash ref, read-only)</h3>

<p>Returns a reference to a hash containing the type names currently bound to placeholders. The keys are the same as returned by the ParamValues method. The values are hashrefs containing a single key value pair, in which the key is either &#39;TYPE&#39; if the type has a generic SQL equivalent, and &#39;pg_type&#39; if the type can only be expressed by a Postgres type. The value is the internal number corresponding to the type originally passed in. (Placeholders that have not yet been bound will return undef as the value). This allows the output of ParamTypes to be passed back to the <a href="#bind_param">&quot;bind_param&quot;</a> method.</p>

<h3 id="Statement-string-read-only-"><b>Statement</b> (string, read-only)</h3>

<p>Returns the statement string passed to the most recent &quot;prepare&quot; method called in this database handle, even if that method failed. This is especially useful where &quot;RaiseError&quot; is enabled and the exception handler checks $@ and sees that a <code><code>prepare</code></code> method call failed.</p>

<h3 id="pg_current_row-integer-read-only-"><b>pg_current_row</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the number of the tuple (row) that was most recently fetched. Returns zero before and after fetching is performed.</p>

<h3 id="pg_numbound-integer-read-only-"><b>pg_numbound</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. Returns the number of placeholders that are currently bound (via bind_param).</p>

<h3 id="pg_bound-hashref-read-only-"><b>pg_bound</b> (hashref, read-only)</h3>

<p>DBD::Pg specific attribute. Returns a hash of all named placeholders. The key is the name of the placeholder, and the value is a 0 or a 1, indicating if the placeholder has been bound yet (e.g. via bind_param)</p>

<h3 id="pg_size-arrayref-read-only-"><b>pg_size</b> (arrayref, read-only)</h3>

<p>DBD::Pg specific attribute. It returns a reference to an array of integer values for each column. The integer shows the size of the column in bytes. Variable length columns are indicated by -1.</p>

<h3 id="pg_type-arrayref-read-only-"><b>pg_type</b> (arrayref, read-only)</h3>

<p>DBD::Pg specific attribute. It returns a reference to an array of strings for each column. The string shows the name of the data_type.</p>

<h3 id="pg_segments-arrayref-read-only-"><b>pg_segments</b> (arrayref, read-only)</h3>

<p>DBD::Pg specific attribute. Returns an arrayref of the query split on the placeholders.</p>

<h3 id="pg_oid_status-integer-read-only-"><b>pg_oid_status</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. It returns the OID of the last INSERT command.</p>

<h3 id="pg_cmd_status-integer-read-only-"><b>pg_cmd_status</b> (integer, read-only)</h3>

<p>DBD::Pg specific attribute. It returns the type of the last command. Possible types are: &quot;INSERT&quot;, &quot;DELETE&quot;, &quot;UPDATE&quot;, &quot;SELECT&quot;.</p>

<h3 id="pg_direct-boolean-"><b>pg_direct</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Default is false. If true, the query is passed directly to the backend without parsing for placeholders.</p>

<h3 id="pg_prepare_now-boolean-1"><b>pg_prepare_now</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Default is off. If true, the query will be immediately prepared, rather than waiting for the <a href="#execute">&quot;execute&quot;</a> call.</p>

<h3 id="pg_prepare_name-string-"><b>pg_prepare_name</b> (string)</h3>

<p>DBD::Pg specific attribute. Specifies the name of the prepared statement to use for this statement handle. Not normally needed, see the section on the <a href="#prepare">&quot;prepare&quot;</a> method for more information.</p>

<h3 id="pg_server_prepare-integer-1"><b>pg_server_prepare</b> (integer)</h3>

<p>DBD::Pg specific attribute. Indicates if DBD::Pg should attempt to use server-side prepared statements for this statement handle. The default value, 1, indicates that prepared statements should be used whenever possible. See the section on the <a href="#prepare">&quot;prepare&quot;</a> method for more information.</p>

<h3 id="pg_placeholder_dollaronly-boolean-1"><b>pg_placeholder_dollaronly</b> (boolean)</h3>

<p>DBD::Pg specific attribute. Defaults to off. When true, question marks inside of the query being prepared are not treated as placeholders. Useful for statements that contain unquoted question marks, such as geometric operators.</p>

<h3 id="pg_async-integer-"><b>pg_async</b> (integer)</h3>

<p>DBD::Pg specific attribute. Indicates the current behavior for asynchronous queries. See the section on <a href="#Asynchronous-Constants">&quot;Asynchronous Constants&quot;</a> for more information.</p>

<h3 id="RowsInCache"><b>RowsInCache</b></h3>

<p>Not used by DBD::Pg</p>

<h3 id="RowCache"><b>RowCache</b></h3>

<p>Not used by DBD::Pg</p>

<h3 id="CursorName"><b>CursorName</b></h3>

<p>Not used by DBD::Pg. See the note about <a href="#Cursors">&quot;Cursors&quot;</a> elsewhere in this document.</p>

<h1 id="FURTHER-INFORMATION">FURTHER INFORMATION</h1>

<h2 id="Transactions">Transactions</h2>

<p>Transaction behavior is controlled via the <a href="#AutoCommit">&quot;AutoCommit&quot;</a> attribute. For a complete definition of <code><code>AutoCommit</code></code> please refer to the DBI documentation.</p>

<p>According to the DBI specification the default for <code><code>AutoCommit</code></code> is a true value. In this mode, any change to the database becomes valid immediately. Any <code><code>BEGIN</code></code>, <code><code>COMMIT</code></code> or <code><code>ROLLBACK</code></code> statements will be rejected. DBD::Pg implements <code><code>AutoCommit</code></code> by issuing a <code><code>BEGIN</code></code> statement immediately before executing a statement, and a <code><code>COMMIT</code></code> afterwards. Note that preparing a statement is not always enough to trigger the first <code><code>BEGIN</code></code>, as the actual <code><code>PREPARE</code></code> is usually postponed until the first call to <a href="#execute">&quot;execute&quot;</a>.</p>

<h2 id="Savepoints">Savepoints</h2>

<p>PostgreSQL version 8.0 introduced the concept of savepoints, which allows transactions to be rolled back to a certain point without affecting the rest of the transaction. DBD::Pg encourages using the following methods to control savepoints:</p>

<h3 id=""><code><code>pg_savepoint</code></code></h3>

<p>Creates a savepoint. This will fail unless you are inside of a transaction. The only argument is the name of the savepoint. Note that PostgreSQL DOES allow multiple savepoints with the same name to exist.</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_savepoint</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</code></code></pre>

<h3 id="1"><code><code>pg_rollback_to</code></code></h3>

<p>Rolls the database back to a named savepoint, discarding any work performed after that point. If more than one savepoint with that name exists, rolls back to the most recently created one.</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_rollback_to</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</code></code></pre>

<h3 id="2"><code><code>pg_release</code></code></h3>

<p>Releases (or removes) a named savepoint. If more than one savepoint with that name exists, it will only destroy the most recently created one. Note that all savepoints created after the one being released are also destroyed.</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_release</span><span class="operator">(</span><span class="string">"mysavepoint"</span><span class="operator">);</span>
</code></code></pre>

<h2 id="Asynchronous-Queries">Asynchronous Queries</h2>

<p>It is possible to send a query to the backend and have your script do other work while the query is running on the backend. Both queries sent by the <a href="#do">&quot;do&quot;</a> method, and by the <a href="#execute">&quot;execute&quot;</a> method can be sent asynchronously. (NOTE: This will only work if DBD::Pg has been compiled against Postgres libraries of version 8.0 or greater) The basic usage is as follows:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
  
  <span class="keyword">print</span> <span class="string">"Async do() example:\n"</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"SELECT long_running_query()"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">do_something_else</span><span class="operator">();</span>
  <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">())</span> <span class="operator">{</span>
      <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
      <span class="keyword">print</span> <span class="string">"Result of do(): </span><span class="variable">$res</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">print</span> <span class="string">"Query is still running...\n"</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">cancel_request_received</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="operator">}</span>
    <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
    <span class="keyword">redo</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">print</span> <span class="string">"Async prepare/execute example:\n"</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT long_running_query(1)"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  
  <span class="comment">## Changed our mind, cancel and run again:</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT 678"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span> <span class="operator">+</span> <span class="variable">PG_OLDQUERY_CANCEL</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  
  <span class="variable">do_something_else</span><span class="operator">();</span>
  
  <span class="keyword">if</span> <span class="operator">(!</span><span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">do_another_thing</span><span class="operator">();</span>
  <span class="operator">}</span>
  
  <span class="comment">## We wait until it is done, and get the result:</span>
  <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
</code></code></pre>

<h3 id="Asynchronous-Constants">Asynchronous Constants</h3>

<p>There are currently three asynchronous constants exported by DBD::Pg. You can import all of them by putting either of these at the top of your script:</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">DBD::Pg</span><span class="operator">;</span>
  
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
</code></code></pre>

<p>You may also use the numbers instead of the constants, but using the constants is recommended as it makes your script more readable.</p>

<dl>

<dt id="PG_ASYNC">PG_ASYNC</dt>
<dd>

<p>This is a constant for the number 1. It is passed to either the <a href="#do">&quot;do&quot;</a> or the <a href="#prepare">&quot;prepare&quot;</a> method as a value to the pg_async key and indicates that the query should be sent asynchronously.</p>

</dd>
<dt id="PG_OLDQUERY_CANCEL">PG_OLDQUERY_CANCEL</dt>
<dd>

<p>This is a constant for the number 2. When passed to either the <a href="#do">&quot;do&quot;</a> or the <a href="#prepare">&quot;prepare&quot;</a> method, it causes any currently running asynchronous query to be cancelled and rolled back. It has no effect if no asynchronous query is currently running.</p>

</dd>
<dt id="PG_OLDQUERY_WAIT">PG_OLDQUERY_WAIT</dt>
<dd>

<p>This is a constant for the number 4. When passed to either the <a href="#do">&quot;do&quot;</a> or the <a href="#prepare">&quot;prepare&quot;</a> method, it waits for any currently running asynchronous query to complete. It has no effect if there is no asynchronous query currently running.</p>

</dd>
</dl>

<h3 id="Asynchronous-Methods">Asynchronous Methods</h3>

<dl>

<dt id="pg_cancel"><b>pg_cancel</b></dt>
<dd>

<p>This database-level method attempts to cancel any currently running asynchronous query. It returns true if the cancel succeeded, and false otherwise. Note that a query that has finished before this method is executed will also return false. <b>WARNING</b>: a successful cancellation may leave the database in an unusable state, so you may need to ROLLBACK or ROLLBACK TO a savepoint. As of version 2.17.0 of DBD::Pg, rollbacks are not done automatically.</p>

<pre><code><code>  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
</code></code></pre>

</dd>
<dt id="pg_ready"><b>pg_ready</b></dt>
<dd>

<p>This method can be called as a database handle method or (for convenience) as a statement handle method. Both simply see if a previously issued asynchronous query has completed yet. It returns true if the statement has finished, in which case you should then call the <a href="#pg_result">&quot;pg_result&quot;</a> method. Calls to <code><code>pg_ready()</code></code> should only be used when you have other things to do while the query is running. If you simply want to wait until the query is done, do not call pg_ready() over and over, but simply call the pg_result() method.</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$time</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(!</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">print</span> <span class="string">"Query is still running. Seconds: </span><span class="variable">$time</span><span class="string">\n"</span><span class="operator">;</span>
    <span class="variable">$time</span><span class="operator">++;</span>
    <span class="keyword">sleep</span> <span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
</code></code></pre>

</dd>
<dt id="pg_result"><b>pg_result</b></dt>
<dd>

<p>This database handle method returns the results of a previously issued asynchronous query. If the query is still running, this method will wait until it has finished. The result returned is the number of rows: the same thing that would have been returned by the asynchronous <a href="#do">&quot;do&quot;</a> or <a href="#execute">&quot;execute&quot;</a> if it had been called without an asynchronous flag.</p>

<pre><code><code>  <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
</code></code></pre>

</dd>
</dl>

<h3 id="Asynchronous-Examples">Asynchronous Examples</h3>

<p>Here are some working examples of asynchronous queries. Note that we&#39;ll use the <b>pg_sleep</b> function to emulate a long-running query.</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Time::HiRes</span> <span class="string">'sleep'</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  
  <span class="comment">## Kick off a long running query on the first database:</span>
  <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"SELECT pg_sleep(?)"</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span><span class="number">5</span><span class="operator">);</span>
  
  <span class="comment">## While that is running, do some other things</span>
  <span class="keyword">print</span> <span class="string">"Your query is processing. Thanks for waiting\n"</span><span class="operator">;</span>
  <span class="variable">check_on_the_kids</span><span class="operator">();</span> <span class="comment">## Expensive sub, takes at least three seconds.</span>
  
  <span class="keyword">while</span> <span class="operator">(!</span><span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">check_on_the_kids</span><span class="operator">();</span>
    <span class="comment">## If the above function returns quickly for some reason, we add a small sleep</span>
    <span class="keyword">sleep</span> <span class="number">0</span><span class="operator">.</span><span class="number">1</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">print</span> <span class="string">"The query has finished. Gathering results\n"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$result</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"Result: </span><span class="variable">$result</span><span class="string">\n"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$info</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">();</span>
</code></code></pre>

<p>Without asynchronous queries, the above script would take about 8 seconds to run: five seconds waiting for the execute to finish, then three for the check_on_the_kids() function to return. With asynchronous queries, the script takes about 6 seconds to run, and gets in two iterations of check_on_the_kids in the process.</p>

<p>Here&#39;s an example showing the ability to cancel a long-running query. Imagine two slave databases in different geographic locations over a slow network. You need information as quickly as possible, so you query both at once. When you get an answer, you tell the other one to stop working on your query, as you don&#39;t need it anymore.</p>

<pre><code><code>  <span class="keyword">use</span> <span class="variable">strict</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">warnings</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">Time::HiRes</span> <span class="string">'sleep'</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Pg</span> <span class="string">':async'</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$dbhslave1</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres;host=slave1'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$dbhslave2</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="variable">connect</span><span class="operator">(</span><span class="string">'dbi:Pg:dbname=postgres;host=slave2'</span><span class="operator">,</span> <span class="string">'postgres'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">,</span> <span class="operator">{</span><span class="string">AutoCommit</span><span class="operator">=&gt;</span><span class="number">0</span><span class="operator">,</span><span class="string">RaiseError</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span><span class="operator">);</span>
  
  <span class="variable">$SQL</span> <span class="operator">=</span> <span class="string">"SELECT count(*) FROM largetable WHERE flavor='blueberry'"</span><span class="operator">;</span>
  
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbhslave1</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span> <span class="operator">=</span> <span class="variable">$dbhslave2</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="variable">$SQL</span><span class="operator">,</span> <span class="operator">{</span><span class="string">pg_async</span> <span class="operator">=&gt;</span> <span class="variable">PG_ASYNC</span><span class="operator">}</span><span class="operator">);</span>
  
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
  
  <span class="keyword">my</span> <span class="variable">$winner</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(!</span><span class="keyword">defined</span> <span class="variable">$winner</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$winner</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="keyword">elsif</span> <span class="operator">(</span><span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_ready</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$winner</span> <span class="operator">=</span> <span class="number">2</span><span class="operator">;</span>
    <span class="operator">}</span>
    <span class="variable">Time::HiRes::sleep</span> <span class="number">0</span><span class="operator">.</span><span class="number">05</span><span class="operator">;</span>
  <span class="operator">}</span>
  
  <span class="keyword">my</span> <span class="variable">$count</span><span class="operator">;</span>
  <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$winner</span> <span class="operator">==</span> <span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">][</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="keyword">else</span> <span class="operator">{</span>
    <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">pg_cancel</span><span class="operator">();</span>
    <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">pg_result</span><span class="operator">();</span>
    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchall_arrayref</span><span class="operator">()-&gt;</span><span class="operator">[</span><span class="number">0</span><span class="operator">][</span><span class="number">0</span><span class="operator">]</span><span class="operator">;</span>
  <span class="operator">}</span>
</code></code></pre>

<h2 id="Array-support">Array support</h2>

<p>DBD::Pg allows arrays (as arrayrefs) to be passed in to both the <a href="#quote">&quot;quote&quot;</a> and the <a href="#execute">&quot;execute&quot;</a> methods. In both cases, the array is flattened into a string representing a Postgres array.</p>

<p>When fetching rows from a table that contains a column with an array type, the result will be passed back to your script as an arrayref.</p>

<p>To turn off the automatic parsing of returned arrays into arrayrefs, you can set the attribute <a href="#pg_expand_array_-boolean-">pg_expand_array</a>, which is true by default.</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">pg_expand_array</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<h2 id="COPY-support">COPY support</h2>

<p>DBD::Pg allows for quick (bulk) reading and storing of data by using the <b>COPY</b> command. The basic process is to use <code><code>$dbh-&gt;do</code></code> to issue a COPY command, and then to either add rows using <a href="#pg_putcopydata">&quot;pg_putcopydata&quot;</a>, or to read them by using <a href="#pg_getcopydata">&quot;pg_getcopydata&quot;</a>.</p>

<p>The first step is to put the server into &quot;COPY&quot; mode. This is done by sending a complete COPY command to the server, by using the <a href="#do">&quot;do&quot;</a> method. For example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY foobar FROM STDIN"</span><span class="operator">);</span>
</code></code></pre>

<p>This would tell the server to enter a COPY IN mode (yes, that&#39;s confusing, but the <i>mode</i> is COPY IN because of the <i>command</i> COPY FROM). It is now ready to receive information via the <a href="#pg_putcopydata">&quot;pg_putcopydata&quot;</a> method. The complete syntax of the COPY command is more complex and not documented here: the canonical PostgreSQL documentation for COPY can be found at:</p>

<p>http://www.postgresql.org/docs/current/static/sql-copy.html</p>

<p>Once a COPY command has been issued, no other SQL commands are allowed until <a href="#pg_putcopyend">&quot;pg_putcopyend&quot;</a> has been issued (for COPY FROM), or the final <a href="#pg_getcopydata">&quot;pg_getcopydata&quot;</a> has been called (for COPY TO).</p>

<p>Note: All other COPY methods (pg_putline, pg_getline, etc.) are now heavily deprecated in favor of the pg_getcopydata, pg_putcopydata, and pg_putcopyend methods.</p>

<h3 id="pg_getcopydata"><b>pg_getcopydata</b></h3>

<p>Used to retrieve data from a table after the server has been put into a COPY OUT mode by calling &quot;COPY tablename TO STDOUT&quot;. Data is always returned one data row at a time. The first argument to pg_getcopydata is the variable into which the data will be stored (this variable should not be undefined, or it may throw a warning, although it may be a reference). The pg_gecopydata method returns a number greater than 1 indicating the new size of the variable, or a -1 when the COPY has finished. Once a -1 has been returned, no other action is necessary, as COPY mode will have already terminated. Example:</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable TO STDOUT"</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">@data</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$x</span><span class="operator">=</span><span class="number">0</span><span class="operator">;</span>
  <span class="number">1</span> <span class="keyword">while</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_getcopydata</span><span class="operator">(</span><span class="variable">$data</span><span class="operator">[</span><span class="variable">$x</span><span class="operator">++</span><span class="operator">]</span><span class="operator">)</span> <span class="operator">&gt;=</span> <span class="number">0</span><span class="operator">;</span>
</code></code></pre>

<p>There is also a variation of this method called <b>pg_getcopydata_async</b>, which, as the name suggests, returns immediately. The only difference from the original method is that this version may return a 0, indicating that the row is not ready to be delivered yet. When this happens, the variable has not been changed, and you will need to call the method again until you get a non-zero result. (Data is still always returned one data row at a time.)</p>

<h3 id="pg_putcopydata"><b>pg_putcopydata</b></h3>

<p>Used to put data into a table after the server has been put into COPY IN mode by calling &quot;COPY tablename FROM STDIN&quot;. The only argument is the data you want inserted. Issue a pg_putcopyend() when you have added all your rows.</p>

<p>The default delimiter is a tab character, but this can be changed in the COPY statement. Returns a 1 on successful input. Examples:</p>

<pre><code><code>  <span class="comment">## Simple example:</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable FROM STDIN"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"123\tPepperoni\t3\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"314\tMushroom\t8\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"6\tAnchovies\t100\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopyend</span><span class="operator">();</span>
  
  <span class="comment">## This example uses explicit columns and a custom delimiter</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"COPY mytable(flavor, slices) FROM STDIN WITH DELIMITER '~'"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Pepperoni~123\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Mushroom~314\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopydata</span><span class="operator">(</span><span class="string">"Anchovies~6\n"</span><span class="operator">);</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">pg_putcopyend</span><span class="operator">();</span>
</code></code></pre>

<h3 id="pg_putcopyend"><b>pg_putcopyend</b></h3>

<p>When you are finished with pg_putcopydata, call pg_putcopyend to let the server know that you are done, and it will return to a normal, non-COPY state. Returns a 1 on success. This method will fail if called when not in COPY IN mode.</p>

<h2 id="Large-Objects">Large Objects</h2>

<p>DBD::Pg supports all largeobject functions provided by libpq via the <code><code>$dbh-&gt;pg_lo*</code></code> methods. Please note that access to a large object, even read-only large objects, must be put into a transaction.</p>

<h2 id="Cursors">Cursors</h2>

<p>Although PostgreSQL supports cursors, they have not been used in the current implementation. When DBD::Pg was created, cursors in PostgreSQL could only be used inside a transaction block. Because only one transaction block at a time is allowed, this would have implied the restriction not to use any nested <code><code>SELECT</code></code> statements. Therefore the <a href="#execute">&quot;execute&quot;</a> method fetches all data at once into data structures located in the front-end application. This fact must to be considered when selecting large amounts of data!</p>

<p>You can use cursors in your application, but you&#39;ll need to do a little work. First you must declare your cursor. Now you can issue queries against the cursor, then select against your queries. This typically results in a double loop, like this:</p>

<pre><code><code>  <span class="comment"># WITH HOLD is not needed if AutoCommit is off</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"DECLARE csr CURSOR WITH HOLD FOR </span><span class="variable">$sql</span><span class="string">"</span><span class="operator">);</span>
  <span class="keyword">while</span> <span class="operator">(</span><span class="number">1</span><span class="operator">)</span> <span class="operator">{</span>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"fetch 1000 from csr"</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">last</span> <span class="keyword">if</span> <span class="number">0</span> <span class="operator">==</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">rows</span><span class="operator">;</span>
  
    <span class="keyword">while</span> <span class="operator">(</span><span class="keyword">my</span> <span class="variable">$row</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_hashref</span><span class="operator">)</span> <span class="operator">{</span>
      <span class="comment"># Do something with the data.</span>
    <span class="operator">}</span>
  <span class="operator">}</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"CLOSE csr"</span><span class="operator">);</span>
</code></code></pre>

<h2 id="Datatype-bool">Datatype bool</h2>

<p>The current implementation of PostgreSQL returns &#39;t&#39; for true and &#39;f&#39; for false. From the Perl point of view, this is a rather unfortunate choice. DBD::Pg therefore translates the result for the <code><code>BOOL</code></code> data type in a Perlish manner: &#39;f&#39; becomes the number <code><code>0</code></code> and &#39;t&#39; becomes the number <code><code>1</code></code>. This way the application does not have to check the database-specific returned values for the data-type <code><code>BOOL</code></code> because Perl treats <code><code>0</code></code> as false and <code><code>1</code></code> as true. You may set the <a href="#pg_bool_tf_-boolean-">pg_bool_tf</a> attribute to a true value to change the values back to &#39;t&#39; and &#39;f&#39; if you wish.</p>

<p>Boolean values can be passed to PostgreSQL as TRUE, &#39;t&#39;, &#39;true&#39;, &#39;y&#39;, &#39;yes&#39; or &#39;1&#39; for true and FALSE, &#39;f&#39;, &#39;false&#39;, &#39;n&#39;, &#39;no&#39; or &#39;0&#39; for false.</p>

<h2 id="Schema-support">Schema support</h2>

<p>The PostgreSQL schema concept may differ from those of other databases. In a nutshell, a schema is a named collection of objects within a single database. Please refer to the PostgreSQL documentation for more details:</p>

<p><a href="http://www.postgresql.org/docs/current/static/ddl-schemas.html">http://www.postgresql.org/docs/current/static/ddl-schemas.html</a></p>

<p>DBD::Pg does not provide explicit support for PostgreSQL schemas. However, schema functionality may be used without any restrictions by explicitly addressing schema objects, e.g.</p>

<pre><code><code>  <span class="keyword">my</span> <span class="variable">$res</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectall_arrayref</span><span class="operator">(</span><span class="string">"SELECT * FROM my_schema.my_table"</span><span class="operator">);</span>
</code></code></pre>

<p>or by manipulating the schema search path with <code><code>SET search_path</code></code>, e.g.</p>

<pre><code><code>  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">do</span><span class="operator">(</span><span class="string">"SET search_path TO my_schema, public"</span><span class="operator">);</span>
</code></code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>



<a href="http://search.cpan.org/~timb/DBI/DBI.pm">The DBI module</a>

<h1 id="BUGS">BUGS</h1>

<p>To report a bug, or view the current list of bugs, please visit http://rt.cpan.org/Public/Dist/Display.html?Name=DBD-Pg</p>

<h1 id="DEVELOPMENT">DEVELOPMENT</h1>

<p>Patches can be submitted to rt.cpan.org. Detailed information on how to help out with this module can be found in the README.dev file. The latest development version can be obtained via: git clone git://bucardo.org/dbdpg.git</p>

<h1 id="AUTHORS">AUTHORS</h1>

<p>DBI by Tim Bunce <a href="http://www.tim.bunce.name">http://www.tim.bunce.name</a></p>

<p>The original DBD-Pg was by Edmund Mergl (E.Mergl@bawue.de) and Jeffrey W. Baker (jwbaker@acm.org). Major developers include David Wheeler &lt;david@justatheory.com&gt;, Jason Stewart &lt;jason@openinformatics.com&gt;, Bruce Momjian &lt;pgman@candle.pha.pa.us&gt;, and Greg Sabino Mullane &lt;greg@turnstep.com&gt;, with help from many others: see the <i>Changes</i> file for a complete list.</p>

<p>Parts of this package were originally copied from DBI and DBD-Oracle.</p>

<p><b>Mailing List</b></p>

<p>The current maintainers may be reached through the &#39;dbd-pg&#39; mailing list: &lt;dbd-pg@perl.org&gt;</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 1994-2012, Greg Sabino Mullane</p>

<p>This module (DBD::Pg) is free software; you can redistribute it and/or modify it under the same terms as Perl 5.10.0. For more details, see the full text of the licenses in the directory LICENSES.</p>


</body>

</html>


