<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#The-sub">The  sub</a></li>
      <li><a href="#Controlling-line-filling.">Controlling line filling.</a></li>
      <li><a href="#Temporary-and-permanent-default-options">Temporary and permanent default options</a></li>
      <li><a href="#Multi-line-format-specifiers-and-interleaving">Multi-line format specifiers and interleaving</a></li>
      <li><a href="#How-hyphenates">How  hyphenates</a></li>
      <li><a href="#The-formatting-algorithm">The  formatting algorithm</a></li>
      <li><a href="#examples"> examples</a></li>
      <li><a href="#How-consumes-strings">How  consumes strings</a></li>
      <li><a href="#Numerical-formatting">Numerical formatting</a></li>
      <li><a href="#Filling-block-fields-with-lists-of-values">Filling block fields with lists of values</a></li>
      <li><a href="#Headers-footers-and-pages">Headers, footers, and pages</a></li>
      <li><a href="#The-option">The  option</a></li>
      <li><a href="#The-sub1">The  sub</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#BUGS">BUGS</a></li>
  <li><a href="#LICENCE-AND-COPYRIGHT">LICENCE AND COPYRIGHT</a></li>
  <li><a href="#DISCLAIMER-OF-WARRANTY">DISCLAIMER OF WARRANTY</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Text::Reform - Manual text wrapping and reformatting</p>

<h1 id="VERSION">VERSION</h1>

<p>This document describes version 1.20 of Text::Reform, released 2009-09-06.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="variable">$template</span><span class="operator">,</span>
                   <span class="variable">$data</span><span class="operator">,</span> <span class="variable">$to</span><span class="operator">,</span> <span class="variable">$fill</span><span class="operator">,</span> <span class="variable">$it</span><span class="operator">,</span> <span class="variable">$with</span><span class="operator">;</span>
        
        
        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw( tag )</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">tag</span> <span class="string">'B'</span><span class="operator">,</span> <span class="variable">$enboldened_text</span><span class="operator">;</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<h2 id="The-sub">The <code><code>form</code></code> sub</h2>

<p>The <code><code>form()</code></code> subroutine may be exported from the module. It takes a series of format (or &quot;picture&quot;) strings followed by replacement values, interpolates those values into each picture string, and returns the result. The effect is similar to the inbuilt perl <code><code>format</code></code> mechanism, although the field specification syntax is simpler and some of the formatting behaviour is more sophisticated.</p>

<p>A picture string consists of sequences of the following characters:</p>

<dl>

<dt id="">&lt;</dt>
<dd>

<p>Left-justified field indicator. A series of two or more sequential &lt;&#39;s specify a left-justified field to be filled by a subsequent value. A single &lt; is formatted as the literal character &#39;&lt;&#39;</p>

</dd>
<dt id="1">&gt;</dt>
<dd>

<p>Right-justified field indicator. A series of two or more sequential &gt;&#39;s specify a right-justified field to be filled by a subsequent value. A single &gt; is formatted as the literal character &#39;&gt;&#39;</p>

</dd>
<dt id="2">&lt;&lt;&lt;&gt;&gt;&gt;</dt>
<dd>

<p>Fully-justified field indicator. Field may be of any width, and brackets need not balance, but there must be at least 2 &#39;&lt;&#39; and 2 &#39;&gt;&#39;.</p>

</dd>
<dt id="pod-">^</dt>
<dd>

<p>Centre-justified field indicator. A series of two or more sequential ^&#39;s specify a centred field to be filled by a subsequent value. A single ^ is formatted as the literal character &#39;^&#39;</p>

</dd>
<dt id="pod.">&gt;&gt;&gt;.&lt;&lt;&lt;&lt;</dt>
<dd>

<p>A numerically formatted field with the specified number of digits to either side of the decimal place. See <a href="#Numerical-formatting">&quot;Numerical formatting&quot;</a> below.</p>

</dd>
<dt id="pod-1">[</dt>
<dd>

<p>Left-justified block field indicator. Just like a &lt; field, except it repeats as required on subsequent lines. See below. A single [ is formatted as the literal character &#39;[&#39;</p>

</dd>
<dt id="pod-2">]</dt>
<dd>

<p>Right-justified block field indicator. Just like a &gt; field, except it repeats as required on subsequent lines. See below. A single ] is formatted as the literal character &#39;]&#39;</p>

</dd>
<dt id="pod-3">[[[]]]</dt>
<dd>

<p>Fully-justified block field indicator. Just like a &lt;&lt;&lt;&gt;&gt;&gt; field, except it repeats as required on subsequent lines. See below. Field may be of any width, and brackets need not balance, but there must be at least 2 &#39;[&#39; and 2 &#39;]&#39;.</p>

</dd>
<dt id="pod-4">|</dt>
<dd>

<p>Centre-justified block field indicator. Just like a ^ field, except it repeats as required on subsequent lines. See below. A single | is formatted as the literal character &#39;|&#39;</p>

</dd>
<dt id="pod-.-">]]].[[[[</dt>
<dd>

<p>A numerically formatted block field with the specified number of digits to either side of the decimal place. Just like a &gt;&gt;&gt;.&lt;&lt;&lt;&lt; field, except it repeats as required on subsequent lines. See below.</p>

</dd>
<dt id="pod-5">~</dt>
<dd>

<p>A one-character wide block field.</p>

</dd>
<dt id="pod-6">\</dt>
<dd>

<p>Literal escape of next character (e.g. <code><code>\~</code></code> is formatted as &#39;~&#39;, not a one character wide block field).</p>

</dd>
<dt id="Any-other-character">Any other character</dt>
<dd>

<p>That literal character.</p>

</dd>
</dl>

<p>Any substitution value which is <code><code>undef</code></code> (either explicitly so, or because it is missing) is replaced by an empty string.</p>

<h2 id="Controlling-line-filling.">Controlling line filling.</h2>

<p>Note that, unlike the a perl <code><code>format</code></code>, <code><code>form</code></code> preserves whitespace (including newlines) unless called with certain options.</p>

<p>The &quot;squeeze&quot; option (when specified with a true value) causes any sequence of spaces and/or tabs (but not newlines) in an interpolated string to be replaced with a single space.</p>

<p>A true value for the &quot;fill&quot; option causes (only) newlines to be squeezed.</p>

<p>To minimize all whitespace, you need to specify both options. Hence:</p>

<pre><code><code>        <span class="variable">$format</span> <span class="operator">=</span> <span class="string">"EG&gt; [[[[[[[[[[[[[[[[[[[[["</span><span class="operator">;</span>
        <span class="variable">$data</span>   <span class="operator">=</span> <span class="string">"h  e\t l lo\nworld\t\t\t\t\t"</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="variable">$format</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">;</span>              <span class="comment"># all whitespace preserved:</span>
                                                <span class="comment">#</span>
                                                <span class="comment"># EG&gt; h  e            l lo</span>
                                                <span class="comment"># EG&gt; world</span>
        
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">squeeze</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">},</span>                <span class="comment"># only newlines preserved:</span>
                   <span class="variable">$format</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">;</span>              <span class="comment">#</span>
                                                <span class="comment"># EG&gt; h e l lo</span>
                                                <span class="comment"># EG&gt; world</span>
        
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">fill</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">},</span>                   <span class="comment"># only spaces/tabs preserved:</span>
                    <span class="variable">$format</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">;</span>             <span class="comment">#</span>
                                                <span class="comment"># EG&gt; h  e        l lo world</span>
        
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">squeeze</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">,</span> <span class="string">fill</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">},</span>       <span class="comment"># no whitespace preserved:</span>
                   <span class="variable">$format</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">;</span>              <span class="comment">#</span>
                                                <span class="comment"># EG&gt; h e l lo world</span>
</code></code></pre>

<p>Whether or not filling or squeezing is in effect, <code><code>form</code></code> can also be directed to trim any extra whitespace from the end of each line it formats, using the &quot;trim&quot; option. If this option is specified with a true value, every line returned by <code><code>form</code></code> will automatically have the substitution <code><code>s/[ \t]+$//gm</code></code> applied to it.</p>

<p>Hence:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="keyword">length</span> <span class="variable">form</span> <span class="string">"[[[[[[[[[["</span><span class="operator">,</span> <span class="string">"short"</span><span class="operator">;</span>
        <span class="comment"># 11</span>
        
        <span class="keyword">print</span> <span class="keyword">length</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">trim</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">},</span> <span class="string">"[[[[[[[[[["</span><span class="operator">,</span> <span class="string">"short"</span><span class="operator">;</span>
        <span class="comment"># 6</span>
</code></code></pre>

<p>It is also possible to control the character used to fill lines that are too short, using the &#39;filler&#39; option. If this option is specified the value of the &#39;filler&#39; flag is used as the fill string, rather than the default <code><code>&quot; &quot;</code></code>.</p>

<p>For example:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">filler</span><span class="operator">=&gt;</span><span class="string">'*'</span> <span class="operator">},</span>
                <span class="string">"Pay bearer: ^^^^^^^^^^^^^^^^^^^"</span><span class="operator">,</span>
                <span class="string">'$123.45'</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<pre><code><code>        Pay bearer: ******$123.45******</code></code></pre>

<p>If the filler string is longer than one character, it is truncated to the appropriate length. So:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">filler</span><span class="operator">=&gt;</span><span class="string">'--&gt;'</span> <span class="operator">},</span>
                <span class="string">"Pay bearer: ]]]]]]]]]]]]]]]]]]]"</span><span class="operator">,</span>
                <span class="operator">[</span><span class="string">'$1234.50'</span><span class="operator">,</span> <span class="string">'$123.45'</span><span class="operator">,</span> <span class="string">'$12.34'</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<pre><code><code>        Pay bearer: -&gt;--&gt;--&gt;--&gt;$1234.50
        Pay bearer: --&gt;--&gt;--&gt;--&gt;$123.45
        Pay bearer: &gt;--&gt;--&gt;--&gt;--&gt;$12.34</code></code></pre>

<p>If the value of the &#39;filler&#39; option is a hash, then it&#39;s &#39;left&#39; and &#39;right&#39; entries specify separate filler strings for each side of an interpolated value. So:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">filler</span><span class="operator">=&gt;</span><span class="operator">{</span><span class="string">left</span><span class="operator">=&gt;</span><span class="string">'-&gt;'</span><span class="operator">,</span> <span class="string">right</span><span class="operator">=&gt;</span><span class="string">'*'</span><span class="operator">}</span> <span class="operator">},</span>
                <span class="string">"Pay bearer: &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;"</span><span class="operator">,</span>
                <span class="string">'$123.45'</span><span class="operator">,</span>
                <span class="string">"Pay bearer: &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;"</span><span class="operator">,</span>
                <span class="string">'$123.45'</span><span class="operator">,</span>
                <span class="string">"Pay bearer: ^^^^^^^^^^^^^^^^^^"</span><span class="operator">,</span>
                <span class="string">'$123.45'</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<pre><code><code>        Pay bearer: $123.45***********
        Pay bearer: &gt;-&gt;-&gt;-&gt;-&gt;-&gt;$123.45
        Pay bearer: &gt;-&gt;-&gt;$123.45******</code></code></pre>

<h2 id="Temporary-and-permanent-default-options">Temporary and permanent default options</h2>

<p>If <code><code>form</code></code> is called with options, but no template string or data, it resets it&#39;s defaults to the options specified. If called in a void context:</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">squeeze</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">trim</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">};</span>
</code></code></pre>

<p>the options become permanent defaults.</p>

<p>However, when called with only options in non-void context, <code><code>form</code></code> resets its defaults to those options and returns an object. The reset default values persist only until that returned object is destroyed. Hence to temporarily reset <code><code>form</code></code>&#39;s defaults within a single subroutine:</p>

<pre><code><code>        <span class="keyword">sub</span><span class="variable"> single </span><span class="operator">{</span>
                <span class="keyword">my</span> <span class="variable">$tmp</span> <span class="operator">=</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">squeeze</span> <span class="operator">=&gt;</span> <span class="number">1</span><span class="operator">,</span> <span class="string">trim</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">};</span>
        
                <span class="comment"># do formatting with the obove defaults</span>
        
        <span class="operator">}</span> <span class="comment"># form's defaults revert to previous values as $tmp object destroyed</span>
</code></code></pre>

<h2 id="Multi-line-format-specifiers-and-interleaving">Multi-line format specifiers and interleaving</h2>

<p>By default, if a format specifier contains two or more lines (i.e. one or more newline characters), the entire format specifier is repeatedly filled as a unit, until all block fields have consumed their corresponding arguments. For example, to build a simple look-up table:</p>

<pre><code><code>        <span class="keyword">my</span> <span class="variable">@values</span>   <span class="operator">=</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="number">12</span><span class="operator">);</span>
        
        <span class="keyword">my</span> <span class="variable">@squares</span>  <span class="operator">=</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="keyword">sprintf</span> <span class="string">"%.6g"</span><span class="operator">,</span> <span class="variable">$_</span><span class="operator">**</span><span class="number">2</span>    <span class="operator">}</span> <span class="variable">@values</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@roots</span>    <span class="operator">=</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="keyword">sprintf</span> <span class="string">"%.6g"</span><span class="operator">,</span> <span class="keyword">sqrt</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span> <span class="operator">}</span> <span class="variable">@values</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@logs</span>     <span class="operator">=</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="keyword">sprintf</span> <span class="string">"%.6g"</span><span class="operator">,</span> <span class="keyword">log</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">)</span>  <span class="operator">}</span> <span class="variable">@values</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">@inverses</span> <span class="operator">=</span> <span class="keyword">map</span> <span class="operator">{</span> <span class="keyword">sprintf</span> <span class="string">"%.6g"</span><span class="operator">,</span> <span class="number">1</span><span class="operator">/</span><span class="variable">$_</span>     <span class="operator">}</span> <span class="variable">@values</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">"  N      N**2    sqrt(N)      log(N)      1/N"</span><span class="operator">,</span>
        <span class="string">"====================================================="</span><span class="operator">,</span>
        <span class="string">"| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
        -----------------------------------------------------"</span><span class="operator">,</span>
        <span class="operator">\</span><span class="variable">@values</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@squares</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@roots</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@logs</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@inverses</span><span class="operator">;</span>
</code></code></pre>

<p>The multiline format specifier:</p>

<pre><code><code>        &quot;| [[  |  [[[  |  [[[[[[[[[[ | [[[[[[[[[ | [[[[[[[[[ |
        -----------------------------------------------------&quot;,</code></code></pre>

<p>is treated as a single logical line. So <code><code>form</code></code> alternately fills the first physical line (interpolating one value from each of the arrays) and the second physical line (which puts a line of dashes between each row of the table) producing:</p>

<pre><code><code>          N      N**2    sqrt(N)      log(N)      1/N
        =====================================================
        | 1   |  1    |  1          | 0         | 1         |
        -----------------------------------------------------
        | 2   |  4    |  1.41421    | 0.693147  | 0.5       |
        -----------------------------------------------------
        | 3   |  9    |  1.73205    | 1.09861   | 0.333333  |
        -----------------------------------------------------
        | 4   |  16   |  2          | 1.38629   | 0.25      |
        -----------------------------------------------------
        | 5   |  25   |  2.23607    | 1.60944   | 0.2       |
        -----------------------------------------------------
        | 6   |  36   |  2.44949    | 1.79176   | 0.166667  |
        -----------------------------------------------------
        | 7   |  49   |  2.64575    | 1.94591   | 0.142857  |
        -----------------------------------------------------
        | 8   |  64   |  2.82843    | 2.07944   | 0.125     |
        -----------------------------------------------------
        | 9   |  81   |  3          | 2.19722   | 0.111111  |
        -----------------------------------------------------
        | 10  |  100  |  3.16228    | 2.30259   | 0.1       |
        -----------------------------------------------------
        | 11  |  121  |  3.31662    | 2.3979    | 0.0909091 |
        -----------------------------------------------------
        | 12  |  144  |  3.4641     | 2.48491   | 0.0833333 |
        -----------------------------------------------------</code></code></pre>

<p>This implies that formats and the variables from which they&#39;re filled need to be interleaved. That is, a multi-line specification like this:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">"Passed:                      ##
           [[[[[[[[[[[[[[[             # single format specification
        Failed:                        # (needs two sets of data)
           [[[[[[[[[[[[[[["</span><span class="operator">,</span>          <span class="comment">##</span>
        
        <span class="operator">\</span><span class="variable">@passes</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@fails</span><span class="operator">;</span>            <span class="comment">##  data for previous format</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        Passed:
           &lt;pass 1&gt;
        Failed:
           &lt;fail 1&gt;
        Passed:
           &lt;pass 2&gt;
        Failed:
           &lt;fail 2&gt;
        Passed:
           &lt;pass 3&gt;
        Failed:
           &lt;fail 3&gt;</code></code></pre>

<p>because the four-line format specifier is treated as a single unit, to be repeatedly filled until all the data in <code><code>@passes</code></code> and <code><code>@fails</code></code> has been consumed.</p>

<p>Unlike the table example, where this unit filling correctly put a line of dashes between lines of data, in this case the alternation of passes and fails is probably <i>not</i> the desired effect.</p>

<p>Judging by the labels, it is far more likely that the user wanted:</p>

<pre><code><code>        Passed:
           &lt;pass 1&gt;
           &lt;pass 2&gt;
           &lt;pass 3&gt;
        Failed:
           &lt;fail 4&gt;
           &lt;fail 5&gt;
           &lt;fail 6&gt;</code></code></pre>

<p>To achieve that, either explicitly interleave the formats and their data sources:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> 
        <span class="string">"Passed:"</span><span class="operator">,</span>               <span class="comment">## single format (no data required)</span>
        <span class="string">"   [[[[[[[[[[[[[[["</span><span class="operator">,</span>    <span class="comment">## single format (needs one set of data)</span>
            <span class="operator">\</span><span class="variable">@passes</span><span class="operator">,</span>            <span class="comment">## data for previous format</span>
        <span class="string">"Failed:"</span><span class="operator">,</span>               <span class="comment">## single format (no data required)</span>
        <span class="string">"   [[[[[[[[[[[[[[["</span><span class="operator">,</span>    <span class="comment">## single format (needs one set of data)</span>
            <span class="operator">\</span><span class="variable">@fails</span><span class="operator">;</span>             <span class="comment">## data for previous format</span>
</code></code></pre>

<p>or instruct <code><code>form</code></code> to do it for you automagically, by setting the &#39;interleave&#39; flag true:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">interleave</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">}</span>
        <span class="string">"Passed:                 ##
           [[[[[[[[[[[[[[[        # single format
        Failed:                   # (needs two sets of data)
           [[[[[[[[[[[[[[["</span><span class="operator">,</span>     <span class="comment">##</span>
        
                                 <span class="comment">## data to be automagically interleaved</span>
        <span class="operator">\</span><span class="variable">@passes</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@fails</span><span class="operator">;</span>        <span class="comment"># as necessary between lines of previous</span>
                                 <span class="comment">## format</span>
</code></code></pre>

<h2 id="How-hyphenates">How <code><code>form</code></code> hyphenates</h2>

<p>Any line with a block field repeats on subsequent lines until all block fields on that line have consumed all their data. Non-block fields on these lines are replaced by the appropriate number of spaces.</p>

<p>Words are wrapped whole, unless they will not fit into the field at all, in which case they are broken and (by default) hyphenated. Simple hyphenation is used (i.e. break at the <i>N-1</i>th character and insert a &#39;-&#39;), unless a suitable alternative subroutine is specified instead.</p>

<p>Words will not be broken if the break would leave less than 2 characters on the current line. This minimum can be varied by setting the &#39;minbreak&#39; option to a numeric value indicating the minumum total broken characters (including hyphens) required on the current line. Note that, for very narrow fields, words will still be broken (but <i>unhyphenated</i>). For example:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">'~'</span><span class="operator">,</span> <span class="string">'split'</span><span class="operator">;</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        s
        p
        l
        i
        t</code></code></pre>

<p>whilst:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span><span class="string">minbreak</span><span class="operator">=&gt;</span><span class="number">1</span><span class="operator">},</span> <span class="string">'~'</span><span class="operator">,</span> <span class="string">'split'</span><span class="operator">;</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        s-
        p-
        l-
        i-
        t</code></code></pre>

<p>Alternative breaking subroutines can be specified using the &quot;break&quot; option in a configuration hash. For example:</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">my_line_breaker</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p><code><code>form</code></code> expects any user-defined line-breaking subroutine to take three arguments (the string to be broken, the maximum permissible length of the initial section, and the total width of the field being filled). The <code><code>hypenate</code></code> sub must return a list of two strings: the initial (broken) section of the word, and the remainder of the string respectively).</p>

<p>For example:</p>

<pre><code><code>        <span class="keyword">sub</span><span class="variable"> tilde_break = sub</span><span class="operator">(</span>$$$<span class="operator">)</span>
        <span class="operator">{</span>
                <span class="operator">(</span><span class="keyword">substr</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span><span class="number">0</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span><span class="operator">).</span><span class="string">'~'</span><span class="operator">,</span> <span class="keyword">substr</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span><span class="variable">$_</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span><span class="operator">));</span>
        <span class="operator">}</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">tilde_break</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>makes &#39;~&#39; the hyphenation character, whilst:</p>

<pre><code><code>        <span class="keyword">sub</span><span class="variable"> wrap_and_slop = sub</span><span class="operator">(</span>$$$<span class="operator">)</span>
        <span class="operator">{</span>
                <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$text</span><span class="operator">,</span> <span class="variable">$reqlen</span><span class="operator">,</span> <span class="variable">$fldlen</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                <span class="keyword">if</span> <span class="operator">(</span><span class="variable">$reqlen</span><span class="operator">==</span><span class="variable">$fldlen</span><span class="operator">)</span> <span class="operator">{</span> <span class="variable">$text</span> <span class="operator">=~</span> <span class="regex">m/\A(\s*\S*)(.*)/s</span> <span class="operator">}</span>
                <span class="keyword">else</span>                  <span class="operator">{</span> <span class="operator">(</span><span class="string">""</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">)</span> <span class="operator">}</span>
        <span class="operator">}</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">wrap_and_slop</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>wraps excessively long words to the next line and &quot;slops&quot; them over the right margin if necessary.</p>

<p>The Text::Reform package provides three functions to simplify the use of variant hyphenation schemes. The exportable subroutine <code><code>Text::Reform::break_wrap</code></code> generates a reference to a subroutine implementing the &quot;wrap-and-slop&quot; algorithm shown in the last example, which could therefore be rewritten:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw( form break_wrap )</span><span class="operator">;</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_wrap</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>The subroutine <code><code>Text::Reform::break_with</code></code> takes a single string argument and returns a reference to a sub which hyphenates by cutting off the text at the right margin and appending the string argument. Hence the first of the two examples could be rewritten:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw( form break_with )</span><span class="operator">;</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_with</span><span class="operator">(</span><span class="string">'~'</span><span class="operator">)</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>The subroutine <code><code>Text::Reform::break_at</code></code> takes a single string argument and returns a reference to a sub which hyphenates by breaking immediately after that string. For example:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw( form break_at )</span><span class="operator">;</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_at</span><span class="operator">(</span><span class="string">'-'</span><span class="operator">)</span> <span class="operator">}</span>
               <span class="string">"[[[[[[[[[[[[[["</span><span class="operator">,</span>
               <span class="string">"The Newton-Raphson methodology"</span><span class="operator">;</span>
        
        <span class="comment"># returns:</span>
        <span class="comment">#</span>
        <span class="comment">#       "The Newton-</span>
        <span class="comment">#        Raphson </span>
        <span class="comment">#        methodology"</span>
</code></code></pre>

<p>Note that this differs from the behaviour of <code><code>break_with</code></code>, which would be:</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_with</span><span class="operator">(</span><span class="string">'-'</span><span class="operator">)</span> <span class="operator">}</span>
               <span class="string">"[[[[[[[[[[[[[["</span><span class="operator">,</span>
               <span class="string">"The Newton-Raphson methodology"</span><span class="operator">;</span>
        
        <span class="comment"># returns:</span>
        <span class="comment">#</span>
        <span class="comment">#       "The Newton-R-</span>
        <span class="comment">#        aphson metho-</span>
        <span class="comment">#        dology"</span>
</code></code></pre>

<p>Hence <code><code>break_at</code></code> is generally a better choice.</p>

<p><code><code>break_at</code></code> also takes an &#39;except&#39; option, which tells the resulting subroutine not to break in the middle of certain strings. For example:</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_at</span><span class="operator">(</span><span class="string">'-'</span><span class="operator">,</span> <span class="operator">{</span><span class="string">except</span><span class="operator">=&gt;</span><span class="string">qr/Newton-Raphson/</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">}</span>
               <span class="string">"[[[[[[[[[[[[[["</span><span class="operator">,</span>
               <span class="string">"The Newton-Raphson methodology"</span><span class="operator">;</span>
        
        <span class="comment"># returns:</span>
        <span class="comment">#</span>
        <span class="comment">#       "The</span>
            <span class="comment">#        Newton-Raphson </span>
        <span class="comment">#        methodology"</span>
</code></code></pre>

<p>This option is particularly useful for preserving URLs.</p>

<p>The subroutine <code><code>Text::Reform::break_TeX</code></code> returns a reference to a sub which hyphenates using Jan Pazdziora&#39;s TeX::Hyphen module. For example:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw( form break_wrap )</span><span class="operator">;</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">break</span> <span class="operator">=&gt;</span> <span class="variable">break_TeX</span> <span class="operator">}</span>
             <span class="variable">$format_str</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>Note that in the previous examples there is no leading &#39;\&amp;&#39; before <code><code>break_wrap</code></code>, <code><code>break_with</code></code>, or <code><code>break_TeX</code></code>, since each is being directly <i>called</i> (and returns a reference to some other suitable subroutine);</p>

<h2 id="The-formatting-algorithm">The <code><code>form</code></code> formatting algorithm</h2>

<p>The algorithm <code><code>form</code></code> uses is:</p>

<pre><code><code>        1. If interleaving is specified, split the first string in the
           argument list into individual format lines and add a
           terminating newline (unless one is already present).
           Otherwise, treat the entire string as a single &quot;line&quot; (like
           /s does in regexes)

        2. For each format line...

                2.1. determine the number of fields and shift
                     that many values off the argument list and
                     into the filling list. If insufficient
                     arguments are available, generate as many 
                     empty strings as are required.

                2.2. generate a text line by filling each field
                     in the format line with the initial contents
                     of the corresponding arg in the filling list
                     (and remove those initial contents from the arg).

                2.3. replace any &lt;,&gt;, or ^ fields by an equivalent
                     number of spaces. Splice out the corresponding
                     args from the filling list.

                2.4. Repeat from step 2.2 until all args in the
                     filling list are empty.

        3. concatenate the text lines generated in step 2

        4. repeat from step 1 until the argument list is empty</code></code></pre>

<h2 id="examples"><code><code>form</code></code> examples</h2>

<p>As an example of the use of <code><code>form</code></code>, the following:</p>

<pre><code><code>        <span class="variable">$count</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"A big long piece of text to be formatted exquisitely"</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">q
        q{       ||||  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;   },
        $count, $text,
        q</span><span class="operator">{</span>       <span class="operator">----------------</span>   <span class="operator">},</span>
        <span class="string">q{       ^^^^  ]]]]]]]]]]|  }</span><span class="operator">,</span>
        <span class="variable">$count</span><span class="operator">+</span><span class="number">11</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">,</span>
        <span class="string">q{                       =  
                 ]]].[[[            }</span><span class="operator">,</span>
        <span class="string">"123 123.4\n123.456789"</span><span class="operator">;</span>
</code></code></pre>

<p>produces the following output:</p>

<pre><code><code>                 1    A big long
                ----------------
                 12     piece of|
                      text to be|
                       formatted|
                      exquisite-|
                              ly|
                                =
                123.0
                                =
                123.4
                                =
                123.456</code></code></pre>

<p>Note that block fields in a multi-line format string, cause the entire multi-line format to be repeated as often as necessary.</p>

<p>Picture strings and replacement values are interleaved in the traditional <code><code>format</code></code> format, but care is needed to ensure that the correct number of substitution values are provided. Another example:</p>

<pre><code><code>        <span class="variable">$report</span> <span class="operator">=</span> <span class="variable">form</span>
                <span class="string">'Name           Rank    Serial Number'</span><span class="operator">,</span>
                <span class="string">'====           ====    ============='</span><span class="operator">,</span>
                <span class="string">'&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;  ^^^^    &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;'</span><span class="operator">,</span>
                 <span class="variable">$name</span><span class="operator">,</span>         <span class="variable">$rank</span><span class="operator">,</span>  <span class="variable">$serial_number</span><span class="operator">,</span>
                <span class="string">''</span>
                <span class="string">'Age    Sex     Description'</span><span class="operator">,</span>
                <span class="string">'===    ===     ==========='</span><span class="operator">,</span>
                <span class="string">'^^^    ^^^     [[[[[[[[[[['</span><span class="operator">,</span>
                 <span class="variable">$age</span><span class="operator">,</span>  <span class="variable">$sex</span><span class="operator">,</span>   <span class="variable">$description</span><span class="operator">;</span>
</code></code></pre>

<h2 id="How-consumes-strings">How <code><code>form</code></code> consumes strings</h2>

<p>Unlike <code><code>format</code></code>, within <code><code>form</code></code> non-block fields <i>do</i> consume the text they format, so the following:</p>

<pre><code><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"a line of text to be formatted over three lines"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n"</span><span class="operator">,</span>
                    <span class="variable">$text</span><span class="operator">,</span>        <span class="variable">$text</span><span class="operator">,</span>        <span class="variable">$text</span><span class="operator">;</span>
</code></code></pre>

<p>produces:</p>

<pre><code><code>        a line of
          text to
            be fo-</code></code></pre>

<p>not:</p>

<pre><code><code>        a line of
          a line 
            a line</code></code></pre>

<p>To achieve the latter effect, convert the variable arguments to independent literals (by double-quoted interpolation):</p>

<pre><code><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"a line of text to be formatted over three lines"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n"</span><span class="operator">,</span>
                   <span class="string">"</span><span class="variable">$text</span><span class="string">"</span><span class="operator">,</span>      <span class="string">"</span><span class="variable">$text</span><span class="string">"</span><span class="operator">,</span>      <span class="string">"</span><span class="variable">$text</span><span class="string">"</span><span class="operator">;</span>
</code></code></pre>

<p>Although values passed from variable arguments are progressively consumed <i>within</i> <code><code>form</code></code>, the values of the original variables passed to <code><code>form</code></code> are <i>not</i> altered. Hence:</p>

<pre><code><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"a line of text to be formatted over three lines"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n"</span><span class="operator">,</span>
                    <span class="variable">$text</span><span class="operator">,</span>        <span class="variable">$text</span><span class="operator">,</span>        <span class="variable">$text</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$text</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>will print:</p>

<pre><code><code>        a line of
          text to
            be fo-
        a line of text to be formatted over three lines</code></code></pre>

<p>To cause <code><code>form</code></code> to consume the values of the original variables passed to it, pass them as references. Thus:</p>

<pre><code><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"a line of text to be formatted over three lines"</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n  &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\n    &lt;&lt;&lt;&lt;&lt;&lt;\n"</span><span class="operator">,</span>
                    <span class="operator">\</span><span class="variable">$text</span><span class="operator">,</span>       <span class="operator">\</span><span class="variable">$text</span><span class="operator">,</span>       <span class="operator">\</span><span class="variable">$text</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">$text</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</code></code></pre>

<p>will print:</p>

<pre><code><code>        a line of
          text to
            be fo-
        rmatted over three lines</code></code></pre>

<p>Note that, for safety, the &quot;non-consuming&quot; behaviour takes precedence, so if a variable is passed to <code><code>form</code></code> both by reference <i>and</i> by value, its final value will be unchanged.</p>

<h2 id="Numerical-formatting">Numerical formatting</h2>

<p>The &quot;&gt;&gt;&gt;.&lt;&lt;&lt;&quot; and &quot;]]].[[[&quot; field specifiers may be used to format numeric values about a fixed decimal place marker. For example:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">'(]]]]].[[)'</span><span class="operator">,</span> <span class="operator">&lt;&lt;</span><span class="default">EONUMS</span><span class="operator">;</span><span class="string">
                   1
                   1.0
                   1.001
                   1.009
                   123.456
                   1234567
                   one two
        </span><span class="default">EONUMS</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        (    1.0 )
        (    1.0 )
        (    1.00)
        (    1.01)
        (  123.46)
        (#####.##)
        (?????.??)
        (?????.??)</code></code></pre>

<p>Fractions are rounded to the specified number of places after the decimal, but only significant digits are shown. That&#39;s why, in the above example, 1 and 1.0 are formatted as &quot;1.0&quot;, whilst 1.001 is formatted as &quot;1.00&quot;.</p>

<p>You can specify that the maximal number of decimal places always be used by giving the configuration option &#39;numeric&#39; a value that matches /\bAllPlaces\b/i. For example:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">numeric</span> <span class="operator">=&gt;</span> <span class="variable">AllPlaces</span> <span class="operator">},</span>
                   <span class="string">'(]]]]].[[)'</span><span class="operator">,</span> <span class="operator">&lt;&lt;</span><span class="default">'EONUMS'</span><span class="operator">;</span><span class="string">
                   1
                   1.0
        </span><span class="default">EONUMS</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        (    1.00)
        (    1.00)</code></code></pre>

<p>Note that although decimal digits are rounded to fit the specified width, the integral part of a number is never modified. If there are not enough places before the decimal place to represent the number, the entire number is replaced with hashes.</p>

<p>If a non-numeric sequence is passed as data for a numeric field, it is formatted as a series of question marks. This querulous behaviour can be changed by giving the configuration option &#39;numeric&#39; a value that matches /\bSkipNaN\b/i in which case, any invalid numeric data is simply ignored. For example:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="operator">{</span> <span class="string">numeric</span> <span class="operator">=&gt;</span> <span class="string">'SkipNaN'</span> <span class="operator">}</span>
                   <span class="string">'(]]]]].[[)'</span><span class="operator">,</span>
                   <span class="operator">&lt;&lt;</span><span class="default">EONUMS</span><span class="operator">;</span><span class="string">
                   1
                   two three
                   4
        </span><span class="default">EONUMS</span>
</code></code></pre>

<p>would print:</p>

<pre><code><code>        (    1.0 )
        (    4.0 )</code></code></pre>

<h2 id="Filling-block-fields-with-lists-of-values">Filling block fields with lists of values</h2>

<p>If an argument corresponding to a field is an array reference, then <code><code>form</code></code> automatically joins the elements of the array into a single string, separating each element with a newline character. As a result, a call like this:</p>

<pre><code><code>        <span class="variable">@values</span> <span class="operator">=</span> <span class="string">qw( 1 10 100 1000 )</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"(]]]].[[)"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@values</span><span class="operator">;</span>
</code></code></pre>

<p>will print out</p>

<pre><code><code>         (   1.00)
         (  10.00)
         ( 100.00)
         (1000.00)</code></code></pre>

<p>as might be expected.</p>

<p>Note however that arrays must be passed by reference (so that <code><code>form</code></code> knows that the entire array holds data for a single field). If the previous example had not passed @values by reference:</p>

<pre><code><code>        <span class="variable">@values</span> <span class="operator">=</span> <span class="string">qw( 1 10 100 1000 )</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"(]]]].[[)"</span><span class="operator">,</span> <span class="variable">@values</span><span class="operator">;</span>
</code></code></pre>

<p>the output would have been:</p>

<pre><code><code>         (   1.00)
         10
         100
         1000</code></code></pre>

<p>This is because @values would have been interpolated into <code><code>form</code></code>&#39;s argument list, so only $value[0] would have been used as the data for the initial format string. The remaining elements of @value would have been treated as separate format strings, and printed out &quot;verbatim&quot;.</p>

<p>Note too that, because arrays must be passed using a reference, their original contents are consumed by <code><code>form</code></code>, just like the contents of scalars passed by reference.</p>

<p>To avoid having an array consumed by <code><code>form</code></code>, pass it as an anonymous array:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span> <span class="string">"(]]]].[[)"</span><span class="operator">,</span> <span class="operator">[</span><span class="variable">@values</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<h2 id="Headers-footers-and-pages">Headers, footers, and pages</h2>

<p>The <code><code>form</code></code> subroutine can also insert headers, footers, and page-feeds as it formats. These features are controlled by the &quot;header&quot;, &quot;footer&quot;, &quot;pagefeed&quot;, &quot;pagelen&quot;, and &quot;pagenum&quot; options.</p>

<p>The &quot;pagenum&quot; option takes a scalar value or a reference to a scalar variable and starts page numbering at that value. If a reference to a scalar variable is specified, the value of that variable is updated as the formatting proceeds, so that the final page number is available in it after formatting. This can be useful for multi-part reports.</p>

<p>The &quot;pagelen&quot; option specifies the total number of lines in a page (including headers, footers, and page-feeds).</p>

<p>The &quot;pagewidth&quot; option specifies the total number of columns in a page.</p>

<p>If the &quot;header&quot; option is specified with a string value, that string is used as the header of every page generated. If it is specified as a reference to a subroutine, that subroutine is called at the start of every page and its return value used as the header string. When called, the subroutine is passed the current page number.</p>

<p>Likewise, if the &quot;footer&quot; option is specified with a string value, that string is used as the footer of every page generated. If it is specified as a reference to a subroutine, that subroutine is called at the <i>start</i> of every page and its return value used as the footer string. When called, the footer subroutine is passed the current page number.</p>

<p>Both the header and footer options can also be specified as hash references. In this case the hash entries for keys &quot;left&quot;, &quot;centre&quot; (or &quot;center&quot;), and &quot;right&quot; specify what is to appear on the left, centre, and right of the header/footer. The entry for the key &quot;width&quot; specifies how wide the footer is to be. If the &quot;width&quot; key is omitted, the &quot;pagewidth&quot; configuration option (which defaults to 72 characters) is used.</p>

<p>The &quot;left&quot;, &quot;centre&quot;, and &quot;right&quot; values may be literal strings, or subroutines (just as a normal header/footer specification may be.) See the second example, below.</p>

<p>Another alternative for header and footer options is to specify them as a subroutine that returns a hash reference. The subroutine is called for each page, then the resulting hash is treated like the hashes described in the preceding paragraph. See the third example, below.</p>

<p>The &quot;pagefeed&quot; option acts in exactly the same way, to produce a pagefeed which is appended after the footer. But note that the pagefeed is not counted as part of the page length.</p>

<p>All three of these page components are recomputed at the start of each new page, before the page contents are formatted (recomputing the header and footer first makes it possible to determine how many lines of data to format so as to adhere to the specified page length).</p>

<p>When the call to <code><code>form</code></code> is complete and the data has been fully formatted, the footer subroutine is called one last time, with an extra argument of 1. The string returned by this final call is used as the final footer.</p>

<p>So for example, a 60-line per page report, starting at page 7, with appropriate headers and footers might be set up like so:</p>

<pre><code><code>        <span class="variable">$page</span> <span class="operator">=</span> <span class="number">7</span><span class="operator">;</span>
        
        <span class="variable">form</span> <span class="operator">{</span> <span class="string">header</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">"Page </span><span class="variable">$_</span><span class="string">[0]\n\n"</span> <span class="operator">},</span>
               <span class="string">footer</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$pagenum</span><span class="operator">,</span> <span class="variable">$lastpage</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">@_</span><span class="operator">;</span>
                               <span class="keyword">return</span> <span class="string">""</span> <span class="keyword">if</span> <span class="variable">$lastpage</span><span class="operator">;</span>
                               <span class="keyword">return</span> <span class="string">"-"</span><span class="variable">x50</span> <span class="operator">.</span> <span class="string">"\n"</span>
                                             <span class="operator">.</span><span class="variable">form</span> <span class="string">"&gt;"</span><span class="variable">x50</span><span class="operator">,</span> <span class="string">"..."</span><span class="operator">.(</span><span class="variable">$pagenum</span><span class="operator">+</span><span class="number">1</span><span class="operator">);</span>
                              <span class="operator">},</span>
               <span class="string">pagefeed</span> <span class="operator">=&gt;</span> <span class="string">"\n\n"</span><span class="operator">,</span>
               <span class="string">pagelen</span>  <span class="operator">=&gt;</span> <span class="number">60</span>
               <span class="string">pagenum</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$page</span><span class="operator">,</span>
             <span class="operator">},</span>
             <span class="variable">$template</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>Note the recursive use of <code><code>form</code></code> within the &quot;footer&quot; option!</p>

<p>Alternatively, to set up headers and footers such that the running head is right justified in the header and the page number is centred in the footer:</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">header</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">right</span> <span class="operator">=&gt;</span> <span class="string">"Running head"</span> <span class="operator">}</span><span class="operator">,</span>
               <span class="string">footer</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">centre</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="string">"Page </span><span class="variable">$_</span><span class="string">[0]"</span> <span class="operator">}</span> <span class="operator">}</span><span class="operator">,</span>
               <span class="string">pagelen</span>  <span class="operator">=&gt;</span> <span class="number">60</span>
             <span class="operator">},</span>
             <span class="variable">$template</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<p>The footer in the previous example could also have been specified the other way around, as a subroutine that returns a hash (rather than a hash containing a subroutine):</p>

<pre><code><code>        <span class="variable">form</span> <span class="operator">{</span> <span class="string">header</span> <span class="operator">=&gt;</span> <span class="operator">{</span> <span class="string">right</span> <span class="operator">=&gt;</span> <span class="string">"Running head"</span> <span class="operator">}</span><span class="operator">,</span>
               <span class="string">footer</span> <span class="operator">=&gt;</span> <span class="keyword">sub</span><span class="variable"> </span><span class="operator">{</span> <span class="keyword">return</span> <span class="operator">{</span><span class="string">centre</span> <span class="operator">=&gt;</span> <span class="string">"Page </span><span class="variable">$_</span><span class="string">[0]"</span><span class="operator">}</span> <span class="operator">},</span>
               <span class="string">pagelen</span>  <span class="operator">=&gt;</span> <span class="number">60</span>
             <span class="operator">},</span>
             <span class="variable">$template</span><span class="operator">,</span>
             <span class="variable">@data</span><span class="operator">;</span>
</code></code></pre>

<h2 id="The-option">The <code><code>cols</code></code> option</h2>

<p>Sometimes data to be used in a <code><code>form</code></code> call needs to be extracted from a nested data structure. For example, whilst it&#39;s easy to print a table if you already have the data in columns:</p>

<pre><code><code>        <span class="variable">@name</span>  <span class="operator">=</span> <span class="string">qw(Tom Dick Harry)</span><span class="operator">;</span>
        <span class="variable">@score</span> <span class="operator">=</span> <span class="string">qw( 88   54    99)</span><span class="operator">;</span>
        <span class="variable">@time</span>  <span class="operator">=</span> <span class="string">qw( 15   13    18)</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'Name             Score     Time'</span><span class="operator">,</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'[[[[[[[[[[[[[[   |||||     ||||'</span><span class="operator">,</span>
         <span class="operator">\</span><span class="variable">@name</span><span class="operator">,</span>          <span class="operator">\</span><span class="variable">@score</span><span class="operator">,</span>  <span class="operator">\</span><span class="variable">@time</span><span class="operator">;</span>
</code></code></pre>

<p>if the data is aggregrated by rows:</p>

<pre><code><code>        <span class="variable">@data</span> <span class="operator">=</span> <span class="operator">(</span>
            <span class="operator">{</span> <span class="string">name</span><span class="operator">=&gt;</span><span class="string">'Tom'</span><span class="operator">,</span>   <span class="string">score</span><span class="operator">=&gt;</span><span class="number">88</span><span class="operator">,</span> <span class="string">time</span><span class="operator">=&gt;</span><span class="number">15</span> <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span> <span class="string">name</span><span class="operator">=&gt;</span><span class="string">'Dick'</span><span class="operator">,</span>  <span class="string">score</span><span class="operator">=&gt;</span><span class="number">54</span><span class="operator">,</span> <span class="string">time</span><span class="operator">=&gt;</span><span class="number">13</span> <span class="operator">}</span><span class="operator">,</span>
            <span class="operator">{</span> <span class="string">name</span><span class="operator">=&gt;</span><span class="string">'Harry'</span><span class="operator">,</span> <span class="string">score</span><span class="operator">=&gt;</span><span class="number">99</span><span class="operator">,</span> <span class="string">time</span><span class="operator">=&gt;</span><span class="number">18</span> <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">);</span>
</code></code></pre>

<p>you need to do some fancy mapping before it can be fed to <code><code>form</code></code>:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'Name             Score     Time'</span><span class="operator">,</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'[[[[[[[[[[[[[[   |||||     ||||'</span><span class="operator">,</span>
        <span class="operator">[</span><span class="keyword">map</span> <span class="variable">$$_</span><span class="operator">{</span><span class="string">name</span><span class="operator">}</span><span class="operator">,</span>  <span class="variable">@data</span><span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span><span class="keyword">map</span> <span class="variable">$$_</span><span class="operator">{</span><span class="string">score</span><span class="operator">}</span><span class="operator">,</span> <span class="variable">@data</span><span class="operator">]</span><span class="operator">,</span>
        <span class="operator">[</span><span class="keyword">map</span> <span class="variable">$$_</span><span class="operator">{</span><span class="string">time</span><span class="operator">}</span> <span class="operator">,</span> <span class="variable">@data</span><span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>Or you could just use the <code><code>&#39;cols&#39;</code></code> option:</p>

<pre><code><code>        <span class="keyword">use</span> <span class="variable">Text::Reform</span> <span class="string">qw(form columns)</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'Name             Score     Time'</span><span class="operator">,</span>
        <span class="string">'-------------------------------'</span><span class="operator">,</span>
        <span class="string">'[[[[[[[[[[[[[[   |||||     ||||'</span><span class="operator">,</span>
        <span class="operator">{</span> <span class="string">cols</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw(name score time)</span><span class="operator">]</span><span class="operator">,</span>
          <span class="string">from</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@data</span>
        <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<p>This option takes an array of strings that specifies the keys of the hash entries to be extracted into columns. The <code><code>&#39;from&#39;</code></code> entry (which must be present) also takes an array, which is expected to contain a list of references to hashes. For each key specified, this option inserts into <code><code>form</code></code>&#39;s argument list a reference to an array containing the entries for that key, extracted from each of the hash references supplied by <code><code>&#39;from&#39;</code></code>. So, for example, the option:</p>

<pre><code><code>        <span class="operator">{</span> <span class="string">cols</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="string">qw(name score time)</span><span class="operator">]</span><span class="operator">,</span>
          <span class="string">from</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@data</span>
        <span class="operator">}</span>
</code></code></pre>

<p>is replaced by three array references, the first containing the <code><code>&#39;name&#39;</code></code> entries for each hash inside <code><code>@data</code></code>, the second containing the <code><code>&#39;score&#39;</code></code> entries for each hash inside <code><code>@data</code></code>, and the third containing the <code><code>&#39;time&#39;</code></code> entries for each hash inside <code><code>@data</code></code>.</p>

<p>If, instead, you have a list of arrays containing the data:</p>

<pre><code><code>        <span class="variable">@data</span> <span class="operator">=</span> <span class="operator">(</span>
                <span class="comment"># Time  Name     Score</span>
                <span class="operator">[</span> <span class="number">15</span><span class="operator">,</span>   <span class="string">'Tom'</span><span class="operator">,</span>   <span class="number">88</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="operator">[</span> <span class="number">13</span><span class="operator">,</span>   <span class="string">'Dick'</span><span class="operator">,</span>  <span class="number">54</span> <span class="operator">]</span><span class="operator">,</span>
                <span class="operator">[</span> <span class="number">18</span><span class="operator">,</span>   <span class="string">'Harry'</span><span class="operator">,</span> <span class="number">99</span> <span class="operator">]</span><span class="operator">,</span>
        <span class="operator">);</span>
</code></code></pre>

<p>the <code><code>&#39;cols&#39;</code></code> option can extract the appropriate columns for that too. You just specify the required indices, rather than keys:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">'-----------------------------'</span><span class="operator">,</span>   
        <span class="string">'Name             Score   Time'</span><span class="operator">,</span>   
        <span class="string">'-----------------------------'</span><span class="operator">,</span>   
        <span class="string">'[[[[[[[[[[[[[[   |||||   ||||'</span><span class="operator">,</span>
        <span class="operator">{</span> <span class="string">cols</span> <span class="operator">=&gt;</span> <span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span>
          <span class="string">from</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">@data</span>
        <span class="operator">}</span>
</code></code></pre>

<p>Note that the indices can be in any order, and the resulting arrays are returned in the same order.</p>

<p>If you need to merge columns extracted from two hierarchical data structures, just concatenate the data structures first, like so:</p>

<pre><code><code>        print form
        &#39;---------------------------------------&#39;,   
        &#39;Name             Score   Time   Ranking
        &#39;---------------------------------------&#39;,   
        &#39;[[[[[[[[[[[[[[   |||||   ||||   |||||||&#39;,
        { cols =&gt; [1,2,0],
          from =&gt; [@data, @olddata],
        }</code></code></pre>

<p>Of course, this only works if the columns are in the same positions in both data sets (and both datasets are stored in arrays) or if the columns have the same keys (and both datasets are in hashes). If not, you would need to format each dataset separately, like so:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">form</span>
        <span class="string">'-----------------------------'</span><span class="operator">,</span>   
        <span class="string">'Name             Score   Time'</span>
        <span class="string">'-----------------------------'</span><span class="operator">,</span>   
        <span class="string">'[[[[[[[[[[[[[[   |||||   ||||'</span><span class="operator">,</span>
        <span class="operator">{</span> <span class="string">cols</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="number">1</span><span class="operator">,</span><span class="number">2</span><span class="operator">,</span><span class="number">0</span><span class="operator">]</span><span class="operator">,</span>  <span class="string">from</span><span class="operator">=&gt;\</span><span class="variable">@data</span> <span class="operator">}</span><span class="operator">,</span>
        <span class="string">'[[[[[[[[[[[[[[   |||||   ||||'</span><span class="operator">,</span>
        <span class="operator">{</span> <span class="string">cols</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="number">3</span><span class="operator">,</span><span class="number">8</span><span class="operator">,</span><span class="number">1</span><span class="operator">]</span><span class="operator">,</span>  <span class="string">from</span><span class="operator">=&gt;\</span><span class="variable">@olddata</span> <span class="operator">}</span><span class="operator">,</span>
        <span class="string">'[[[[[[[[[[[[[[   |||||   ||||'</span><span class="operator">,</span>
        <span class="operator">{</span> <span class="string">cols</span><span class="operator">=&gt;</span><span class="operator">[</span><span class="string">qw(name score time)</span><span class="operator">]</span><span class="operator">,</span>  <span class="string">from</span><span class="operator">=&gt;\</span><span class="variable">@otherdata</span> <span class="operator">}</span><span class="operator">;</span>
</code></code></pre>

<h2 id="The-sub1">The <code><code>tag</code></code> sub</h2>

<p>The <code><code>tag</code></code> subroutine may be exported from the module. It takes two arguments: a tag specifier and a text to be entagged. The tag specifier indicates the indenting of the tag, and of the text. The sub generates an end-tag (using the usual &quot;/<i>tag</i>&quot; variant), unless an explicit end-tag is provided as the third argument.</p>

<p>The tag specifier consists of the following components (in order):</p>

<dl>

<dt id="An-optional-vertical-spacer-zero-or-more-whitespace-separated-newlines-">An optional vertical spacer (zero or more whitespace-separated newlines)</dt>
<dd>

<p>One or more whitespace characters up to a final mandatory newline. This vertical space is inserted before the tag and after the end-tag</p>

</dd>
<dt id="An-optional-tag-indent">An optional tag indent</dt>
<dd>

<p>Zero or more whitespace characters. Both the tag and the end-tag are indented by this whitespace.</p>

</dd>
<dt id="An-optional-left-opening-tag-delimiter">An optional left (opening) tag delimiter</dt>
<dd>

<p>Zero or more non-&quot;word&quot; characters (not alphanumeric or &#39;_&#39;). If the opening delimiter is omitted, the character &#39;&lt;&#39; is used.</p>

</dd>
<dt id="A-tag">A tag</dt>
<dd>

<p>One or more &quot;word&quot; characters (alphanumeric or &#39;_&#39;).</p>

</dd>
<dt id="Optional-tag-arguments">Optional tag arguments</dt>
<dd>

<p>Any number of any characters</p>

</dd>
<dt id="An-optional-right-closing-tag-delimiter">An optional right (closing) tag delimiter</dt>
<dd>

<p>Zero or more non-&quot;word&quot; characters which balance some sequential portion of the opening tag delimiter. For example, if the opening delimiter is &quot;&lt;-(&quot; then any of the following are acceptible closing delimiters: &quot;)-&gt;&quot;, &quot;-&gt;&quot;, or &quot;&gt;&quot;. If the closing delimiter is omitted, the &quot;inverse&quot; of the opening delimiter is used (for example, &quot;)-&gt;&quot;),</p>

</dd>
<dt id="An-optional-vertical-spacer-zero-or-more-newlines-">An optional vertical spacer (zero or more newlines)</dt>
<dd>

<p>One or more whitespace characters up to a mandatory newline. This vertical space is inserted before and after the complete text.</p>

</dd>
<dt id="An-optional-text-indent">An optional text indent</dt>
<dd>

<p>Zero or more space of tab characters. Each line of text is indented by this whitespace (in addition to the tag indent).</p>

</dd>
</dl>

<p>For example:</p>

<pre><code><code>        <span class="variable">$text</span> <span class="operator">=</span> <span class="string">"three lines\nof tagged\ntext"</span><span class="operator">;</span>
        
        <span class="keyword">print</span> <span class="variable">tag</span> <span class="string">"A HREF=#nextsection"</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<pre><code><code>        &lt;A HREF=#nextsection&gt;three lines
        of tagged
        text&lt;/A&gt;</code></code></pre>

<p>whereas:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">tag</span> <span class="string">"[-:GRIN&gt;&gt;&gt;\n"</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<pre><code><code>        [-:GRIN&gt;&gt;&gt;:-]
        three lines
        of tagged
        text
        [-:/GRIN&gt;&gt;&gt;:-]</code></code></pre>

<p>and:</p>

<pre><code><code>        <span class="keyword">print</span> <span class="variable">tag</span> <span class="string">"\n\n   &lt;BOLD&gt;\n\n   "</span><span class="operator">,</span> <span class="variable">$text</span><span class="operator">,</span> <span class="string">"&lt;END BOLD&gt;"</span><span class="operator">;</span>
</code></code></pre>

<p>prints:</p>

<p><span style="white-space: nowrap;"> </span></p>

<pre><code><code>           &lt;BOLD&gt;

              three lines
              of tagged
              text

           &lt;END BOLD&gt;</code></code></pre>

<p><span style="white-space: nowrap;"> </span></p>

<p>(with the indicated spacing fore and aft).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Damian Conway (damian@conway.org)</p>

<h1 id="BUGS">BUGS</h1>

<p>The module uses <code><code>POSIX::strtod</code></code>, which may be broken under certain versions of Windows. Applying the WINDOWS_PATCH patch to Reform.pm will replace the POSIX function with a copycat subroutine.</p>

<p>There are undoubtedly serious bugs lurking somewhere in code this funky :-) Bug reports and other feedback are most welcome.</p>

<h1 id="LICENCE-AND-COPYRIGHT">LICENCE AND COPYRIGHT</h1>

<p>Copyright (c) 1997-2007, Damian Conway <code><code>&lt;DCONWAY@CPAN.org&gt;</code></code>. All rights reserved.</p>

<p>This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See <a href="../../lib/pods/perlartistic.html">perlartistic</a>.</p>

<h1 id="DISCLAIMER-OF-WARRANTY">DISCLAIMER OF WARRANTY</h1>

<p>BECAUSE THIS SOFTWARE IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR THE SOFTWARE, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE SOFTWARE &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE SOFTWARE IS WITH YOU. SHOULD THE SOFTWARE PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR, OR CORRECTION.</p>

<p>IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR REDISTRIBUTE THE SOFTWARE AS PERMITTED BY THE ABOVE LICENCE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE SOFTWARE (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE SOFTWARE TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.</p>


</body>

</html>


