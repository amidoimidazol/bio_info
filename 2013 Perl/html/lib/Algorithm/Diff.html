<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#INTRODUCTION">INTRODUCTION</a></li>
  <li><a href="#USAGE">USAGE</a>
    <ul>
      <li><a href="#"></a></li>
      <li><a href="#1"></a></li>
      <li><a href="#2"></a></li>
      <li><a href="#3"></a></li>
      <li><a href="#4"></a></li>
      <li><a href="#5"></a></li>
      <li><a href="#6"></a></li>
      <li><a href="#7"></a></li>
      <li><a href="#8"></a></li>
      <li><a href="#9"></a></li>
    </ul>
  </li>
  <li><a href="#KEY-GENERATION-FUNCTIONS">KEY GENERATION FUNCTIONS</a></li>
  <li><a href="#ERROR-CHECKING">ERROR CHECKING</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#LICENSE">LICENSE</a></li>
  <li><a href="#MAILING-LIST">MAILING LIST</a></li>
  <li><a href="#CREDITS">CREDITS</a></li>
  <li><a href="#POD-ERRORS">POD ERRORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Algorithm::Diff - Compute `intelligent&#39; differences between two files / lists</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    <span class="keyword">require</span> <span class="variable">Algorithm::Diff</span><span class="operator">;</span>
    
    <span class="comment"># This example produces traditional 'diff' output:</span>
    
    <span class="keyword">my</span> <span class="variable">$diff</span> <span class="operator">=</span> <span class="variable">Algorithm::Diff</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Base</span><span class="operator">(</span> <span class="number">1</span> <span class="operator">);</span>   <span class="comment"># Return line numbers, not indices</span>
    <span class="keyword">while</span><span class="operator">(</span>  <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Next</span><span class="operator">()</span>  <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">next</span>   <span class="keyword">if</span>  <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Same</span><span class="operator">();</span>
        <span class="keyword">my</span> <span class="variable">$sep</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
        <span class="keyword">if</span><span class="operator">(</span>  <span class="operator">!</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">2</span><span class="operator">)</span>  <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">printf</span> <span class="string">"%d,%dd%d\n"</span><span class="operator">,</span>
                <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span><span class="string">qw( Min1 Max1 Max2 )</span><span class="operator">);</span>
        <span class="operator">}</span> <span class="keyword">elsif</span><span class="operator">(</span>  <span class="operator">!</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">1</span><span class="operator">)</span>  <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">printf</span> <span class="string">"%da%d,%d\n"</span><span class="operator">,</span>
                <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span><span class="string">qw( Max1 Min2 Max2 )</span><span class="operator">);</span>
        <span class="operator">}</span> <span class="keyword">else</span> <span class="operator">{</span>
            <span class="variable">$sep</span> <span class="operator">=</span> <span class="string">"---\n"</span><span class="operator">;</span>
            <span class="keyword">printf</span> <span class="string">"%d,%dc%d,%d\n"</span><span class="operator">,</span>
                <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span><span class="string">qw( Min1 Max1 Min2 Max2 )</span><span class="operator">);</span>
        <span class="operator">}</span>
        <span class="keyword">print</span> <span class="string">"&lt; </span><span class="variable">$_</span><span class="string">"</span>   <span class="keyword">for</span>  <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
        <span class="keyword">print</span> <span class="variable">$sep</span><span class="operator">;</span>
        <span class="keyword">print</span> <span class="string">"&gt; </span><span class="variable">$_</span><span class="string">"</span>   <span class="keyword">for</span>  <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>
    <span class="operator">}</span>
    
    
    <span class="comment"># Alternate interfaces:</span>
    
    <span class="keyword">use</span> <span class="variable">Algorithm::Diff</span> <span class="string">qw(
        LCS LCS_length LCSidx
        diff sdiff compact_diff
        traverse_sequences traverse_balanced )</span><span class="operator">;</span>
    
    <span class="variable">@lcs</span>    <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$lcsref</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$count</span>  <span class="operator">=</span> <span class="variable">LCS_length</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    <span class="operator">(</span> <span class="variable">$seq1idxref</span><span class="operator">,</span> <span class="variable">$seq2idxref</span> <span class="operator">)</span> <span class="operator">=</span> <span class="variable">LCSidx</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    
    <span class="comment"># Complicated interfaces:</span>
    
    <span class="variable">@diffs</span>  <span class="operator">=</span> <span class="variable">diff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    <span class="variable">@sdiffs</span> <span class="operator">=</span> <span class="variable">sdiff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    <span class="variable">@cdiffs</span> <span class="operator">=</span> <span class="variable">compact_diff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    
    <span class="variable">traverse_sequences</span><span class="operator">(</span>
        <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span>
        <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span>
        <span class="operator">{</span>   <span class="string">MATCH</span>     <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback1</span><span class="operator">,</span>
            <span class="string">DISCARD_A</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback2</span><span class="operator">,</span>
            <span class="string">DISCARD_B</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback3</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">\&amp;</span><span class="variable">key_generator</span><span class="operator">,</span>
        <span class="variable">@extra_args</span><span class="operator">,</span>
    <span class="operator">);</span>
    
    <span class="variable">traverse_balanced</span><span class="operator">(</span>
        <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span>
        <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span>
        <span class="operator">{</span>   <span class="string">MATCH</span>     <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback1</span><span class="operator">,</span>
            <span class="string">DISCARD_A</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback2</span><span class="operator">,</span>
            <span class="string">DISCARD_B</span> <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback3</span><span class="operator">,</span>
            <span class="string">CHANGE</span>    <span class="operator">=&gt;</span> <span class="operator">\&amp;</span><span class="variable">callback4</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="operator">\&amp;</span><span class="variable">key_generator</span><span class="operator">,</span>
        <span class="variable">@extra_args</span><span class="operator">,</span>
    <span class="operator">);</span>
</code></code></pre>

<h1 id="INTRODUCTION">INTRODUCTION</h1>

<p>(by Mark-Jason Dominus)</p>

<p>I once read an article written by the authors of <code><code>diff</code></code>; they said that they worked very hard on the algorithm until they found the right one.</p>

<p>I think what they ended up using (and I hope someone will correct me, because I am not very confident about this) was the `longest common subsequence&#39; method. In the LCS problem, you have two sequences of items:</p>

<pre><code><code>    a b c d f g h j q z

    a b c d e f g i j k r x y z</code></code></pre>

<p>and you want to find the longest sequence of items that is present in both original sequences in the same order. That is, you want to find a new sequence <i>S</i> which can be obtained from the first sequence by deleting some items, and from the secend sequence by deleting other items. You also want <i>S</i> to be as long as possible. In this case <i>S</i> is</p>

<pre><code><code>    a b c d f g j z</code></code></pre>

<p>From there it&#39;s only a small step to get diff-like output:</p>

<pre><code><code>    e   h i   k   q r x y
    +   - +   +   - + + +</code></code></pre>

<p>This module solves the LCS problem. It also includes a canned function to generate <code><code>diff</code></code>-like output.</p>

<p>It might seem from the example above that the LCS of two sequences is always pretty obvious, but that&#39;s not always the case, especially when the two sequences have many repeated elements. For example, consider</p>

<pre><code><code>    a x b y c z p d q
    a b c a x b y c z</code></code></pre>

<p>A naive approach might start by matching up the <code><code>a</code></code> and <code><code>b</code></code> that appear at the beginning of each sequence, like this:</p>

<pre><code><code>    a x b y c         z p d q
    a   b   c a b y c z</code></code></pre>

<p>This finds the common subsequence <code><code>a b c z</code></code>. But actually, the LCS is <code><code>a x b y c z</code></code>:</p>

<pre><code><code>          a x b y c z p d q
    a b c a x b y c z</code></code></pre>

<p>or</p>

<pre><code><code>    a       x b y c z p d q
    a b c a x b y c z</code></code></pre>

<h1 id="USAGE">USAGE</h1>

<p>(See also the README file and several example scripts include with this module.)</p>

<p>This module now provides an object-oriented interface that uses less memory and is easier to use than most of the previous procedural interfaces. It also still provides several exportable functions. We&#39;ll deal with these in ascending order of difficulty: <code><code>LCS</code></code>, <code><code>LCS_length</code></code>, <code><code>LCSidx</code></code>, OO interface, <code><code>prepare</code></code>, <code><code>diff</code></code>, <code><code>sdiff</code></code>, <code><code>traverse_sequences</code></code>, and <code><code>traverse_balanced</code></code>.</p>

<h2 id=""><code><code>LCS</code></code></h2>

<p>Given references to two lists of items, LCS returns an array containing their longest common subsequence. In scalar context, it returns a reference to such a list.</p>

<pre><code><code>    <span class="variable">@lcs</span>    <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$lcsref</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>LCS</code></code> may be passed an optional third parameter; this is a CODE reference to a key generation function. See <a href="#KEY-GENERATION-FUNCTIONS">&quot;KEY GENERATION FUNCTIONS&quot;</a>.</p>

<pre><code><code>    <span class="variable">@lcs</span>    <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">keyGen</span><span class="operator">,</span> <span class="variable">@args</span> <span class="operator">);</span>
    <span class="variable">$lcsref</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">keyGen</span><span class="operator">,</span> <span class="variable">@args</span> <span class="operator">);</span>
</code></code></pre>

<p>Additional parameters, if any, will be passed to the key generation routine.</p>

<h2 id="1"><code><code>LCS_length</code></code></h2>

<p>This is just like <code><code>LCS</code></code> except it only returns the length of the longest common subsequence. This provides a performance gain of about 9% compared to <code><code>LCS</code></code>.</p>

<h2 id="2"><code><code>LCSidx</code></code></h2>

<p>Like <code><code>LCS</code></code> except it returns references to two arrays. The first array contains the indices into @seq1 where the LCS items are located. The second array contains the indices into @seq2 where the LCS items are located.</p>

<p>Therefore, the following three lists will contain the same values:</p>

<pre><code><code>    <span class="keyword">my</span><span class="operator">(</span> <span class="variable">$idx1</span><span class="operator">,</span> <span class="variable">$idx2</span> <span class="operator">)</span> <span class="operator">=</span> <span class="variable">LCSidx</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">@list1</span> <span class="operator">=</span> <span class="variable">@seq1</span><span class="operator">[</span> <span class="variable">@$idx1</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">@list2</span> <span class="operator">=</span> <span class="variable">@seq2</span><span class="operator">[</span> <span class="variable">@$idx2</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">@list3</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
</code></code></pre>

<h2 id="3"><code><code>new</code></code></h2>

<pre><code><code>    <span class="variable">$diff</span> <span class="operator">=</span> <span class="variable">Algorithm::Diffs</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$diff</span> <span class="operator">=</span> <span class="variable">Algorithm::Diffs</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">%opts</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>new</code></code> computes the smallest set of additions and deletions necessary to turn the first sequence into the second and compactly records them in the object.</p>

<p>You use the object to iterate over <i>hunks</i>, where each hunk represents a contiguous section of items which should be added, deleted, replaced, or left unchanged.</p>

<ul>

<p>The following summary of all of the methods looks a lot like Perl code but some of the symbols have different meanings:</p>

<pre><code><code>    [ ]     Encloses optional arguments
    :       Is followed by the default value for an optional argument
    |       Separates alternate return results</code></code></pre>

<p>Method summary:</p>

<pre><code><code>    <span class="variable">$obj</span>        <span class="operator">=</span> <span class="variable">Algorithm::Diff</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span> <span class="operator">[</span> <span class="operator">\</span><span class="variable">%opts</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$pos</span>        <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Next</span><span class="operator">(</span>  <span class="operator">[</span> <span class="variable">$count</span> <span class="operator">:</span> <span class="number">1</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$revPos</span>     <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Prev</span><span class="operator">(</span>  <span class="operator">[</span> <span class="variable">$count</span> <span class="operator">:</span> <span class="number">1</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$obj</span>        <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">(</span> <span class="operator">[</span> <span class="variable">$pos</span> <span class="operator">:</span> <span class="number">0</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$copy</span>       <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">(</span>  <span class="operator">[</span> <span class="variable">$pos</span><span class="operator">,</span> <span class="operator">[</span> <span class="variable">$newBase</span> <span class="operator">]</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$oldBase</span>    <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Base</span><span class="operator">(</span>  <span class="operator">[</span> <span class="variable">$newBase</span> <span class="operator">]</span> <span class="operator">);</span>
</code></code></pre>

<p>Note that all of the following methods <code><code>die</code></code> if used on an object that is &quot;reset&quot; (not currently pointing at any hunk).</p>

<pre><code><code>    <span class="variable">$bits</span>       <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Diff</span><span class="operator">(</span>  <span class="operator">);</span>
    <span class="variable">@items</span><span class="operator">|</span><span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Same</span><span class="operator">(</span>  <span class="operator">);</span>
    <span class="variable">@items</span><span class="operator">|</span><span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span> <span class="variable">$seqNum</span> <span class="operator">);</span>
    <span class="variable">@idxs</span> <span class="operator">|</span><span class="variable">$cnt</span> <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span> <span class="variable">$seqNum</span><span class="operator">,</span> <span class="operator">[</span> <span class="variable">$base</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$minIdx</span>     <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Min</span><span class="operator">(</span>   <span class="variable">$seqNum</span><span class="operator">,</span> <span class="operator">[</span> <span class="variable">$base</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">$maxIdx</span>     <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Max</span><span class="operator">(</span>   <span class="variable">$seqNum</span><span class="operator">,</span> <span class="operator">[</span> <span class="variable">$base</span> <span class="operator">]</span> <span class="operator">);</span>
    <span class="variable">@values</span>     <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span>   <span class="variable">@names</span> <span class="operator">);</span>
</code></code></pre>

<p>Passing in <code><code>undef</code></code> for an optional argument is always treated the same as if no argument were passed in.</p>

<p><code><code>Next</code></code></p>

<pre><code><code>    <span class="variable">$pos</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Next</span><span class="operator">();</span>    <span class="comment"># Move forward 1 hunk</span>
    <span class="variable">$pos</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Next</span><span class="operator">(</span> <span class="number">2</span> <span class="operator">);</span> <span class="comment"># Move forward 2 hunks</span>
    <span class="variable">$pos</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Next</span><span class="operator">(-</span><span class="number">5</span><span class="operator">);</span>  <span class="comment"># Move backward 5 hunks</span>
</code></code></pre>

<p><code><code>Next</code></code> moves the object to point at the next hunk. The object starts out &quot;reset&quot;, which means it isn&#39;t pointing at any hunk. If the object is reset, then <code><code>Next()</code></code> moves to the first hunk.</p>

<p><code><code>Next</code></code> returns a true value iff the move didn&#39;t go past the last hunk. So <code><code>Next(0)</code></code> will return true iff the object is not reset.</p>

<p>Actually, <code><code>Next</code></code> returns the object&#39;s new position, which is a number between 1 and the number of hunks (inclusive), or returns a false value.</p>

<p><code><code>Prev</code></code></p>

<p><code><code>Prev($N)</code></code> is almost identical to <code><code>Next(-$N)</code></code>; it moves to the $Nth previous hunk. On a &#39;reset&#39; object, <code><code>Prev()</code></code> [and <code><code>Next(-1)</code></code>] move to the last hunk.</p>

<p>The position returned by <code><code>Prev</code></code> is relative to the <i>end</i> of the hunks; -1 for the last hunk, -2 for the second-to-last, etc.</p>

<p><code><code>Reset</code></code></p>

<pre><code><code>    <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">();</span>     <span class="comment"># Reset the object's position</span>
    <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">(</span><span class="variable">$pos</span><span class="operator">);</span> <span class="comment"># Move to the specified hunk</span>
    <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>    <span class="comment"># Move to the first hunk</span>
    <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">(-</span><span class="number">1</span><span class="operator">);</span>   <span class="comment"># Move to the last hunk</span>
</code></code></pre>

<p><code><code>Reset</code></code> returns the object, so, for example, you could use <code><code>$diff-&gt;Reset()-&gt;Next(-1)</code></code> to get the number of hunks.</p>

<p><code><code>Copy</code></code></p>

<pre><code><code>    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">(</span> <span class="variable">$newPos</span><span class="operator">,</span> <span class="variable">$newBase</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>Copy</code></code> returns a copy of the object. The copy and the orignal object share most of their data, so making copies takes very little memory. The copy maintains its own position (separate from the original), which is the main purpose of copies. It also maintains its own base.</p>

<p>By default, the copy&#39;s position starts out the same as the original object&#39;s position. But <code><code>Copy</code></code> takes an optional first argument to set the new position, so the following three snippets are equivalent:</p>

<pre><code><code>    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">(</span><span class="variable">$pos</span><span class="operator">);</span>
    
    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">();</span>
    <span class="variable">$copy</span><span class="operator">-&gt;</span><span class="variable">Reset</span><span class="operator">(</span><span class="variable">$pos</span><span class="operator">);</span>
    
    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">()-&gt;</span><span class="variable">Reset</span><span class="operator">(</span><span class="variable">$pos</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>Copy</code></code> takes an optional second argument to set the base for the copy. If you wish to change the base of the copy but leave the position the same as in the original, here are two equivalent ways:</p>

<pre><code><code>    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">();</span>
    <span class="variable">$copy</span><span class="operator">-&gt;</span><span class="variable">Base</span><span class="operator">(</span> <span class="number">0</span> <span class="operator">);</span>
    
    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">(</span><span class="keyword">undef</span><span class="operator">,</span><span class="number">0</span><span class="operator">);</span>
</code></code></pre>

<p>Here are two equivalent way to get a &quot;reset&quot; copy:</p>

<pre><code><code>    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">(</span><span class="number">0</span><span class="operator">);</span>
    
    <span class="variable">$copy</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Copy</span><span class="operator">()-&gt;</span><span class="variable">Reset</span><span class="operator">();</span>
</code></code></pre>

<p><code><code>Diff</code></code></p>

<pre><code><code>    <span class="variable">$bits</span> <span class="operator">=</span> <span class="variable">$obj</span><span class="operator">-&gt;</span><span class="variable">Diff</span><span class="operator">();</span>
</code></code></pre>

<p><code><code>Diff</code></code> returns a true value iff the current hunk contains items that are different between the two sequences. It actually returns one of the follow 4 values:</p>

<dl>

<dt id="pod3">3</dt>
<dd>

<p><code><code>3==(1|2)</code></code>. This hunk contains items from @seq1 and the items from @seq2 that should replace them. Both sequence 1 and 2 contain changed items so both the 1 and 2 bits are set.</p>

</dd>
<dt id="pod2">2</dt>
<dd>

<p>This hunk only contains items from @seq2 that should be inserted (not items from @seq1). Only sequence 2 contains changed items so only the 2 bit is set.</p>

</dd>
<dt id="pod1">1</dt>
<dd>

<p>This hunk only contains items from @seq1 that should be deleted (not items from @seq2). Only sequence 1 contains changed items so only the 1 bit is set.</p>

</dd>
<dt id="pod0">0</dt>
<dd>

<p>This means that the items in this hunk are the same in both sequences. Neither sequence 1 nor 2 contain changed items so neither the 1 nor the 2 bits are set.</p>

</dd>
</dl>

<p><code><code>Same</code></code></p>

<p><code><code>Same</code></code> returns a true value iff the current hunk contains items that are the same in both sequences. It actually returns the list of items if they are the same or an emty list if they aren&#39;t. In a scalar context, it returns the size of the list.</p>

<p><code><code>Items</code></code></p>

<pre><code><code>    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>
    <span class="variable">@items</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="variable">$seqNum</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>Items</code></code> returns the (number of) items from the specified sequence that are part of the current hunk.</p>

<p>If the current hunk contains only insertions, then <code><code>$diff-&gt;Items(1)</code></code> will return an empty list (0 in a scalar conext). If the current hunk contains only deletions, then <code><code>$diff-&gt;Items(2)</code></code> will return an empty list (0 in a scalar conext).</p>

<p>If the hunk contains replacements, then both <code><code>$diff-&gt;Items(1)</code></code> and <code><code>$diff-&gt;Items(2)</code></code> will return different, non-empty lists.</p>

<p>Otherwise, the hunk contains identical items and all of the following will return the same lists:</p>

<pre><code><code>    <span class="variable">@items</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
    <span class="variable">@items</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>
    <span class="variable">@items</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Same</span><span class="operator">();</span>
</code></code></pre>

<p><code><code>Range</code></code></p>

<pre><code><code>    <span class="variable">$count</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span> <span class="variable">$seqNum</span> <span class="operator">);</span>
    <span class="variable">@indices</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span> <span class="variable">$seqNum</span> <span class="operator">);</span>
    <span class="variable">@indices</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span> <span class="variable">$seqNum</span><span class="operator">,</span> <span class="variable">$base</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>Range</code></code> is like <code><code>Items</code></code> except that it returns a list of <i>indices</i> to the items rather than the items themselves. By default, the index of the first item (in each sequence) is 0 but this can be changed by calling the <code><code>Base</code></code> method. So, by default, the following two snippets return the same lists:</p>

<pre><code><code>    <span class="variable">@list</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">2</span><span class="operator">);</span>
    <span class="variable">@list</span> <span class="operator">=</span> <span class="variable">@seq2</span><span class="operator">[</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span><span class="number">2</span><span class="operator">)</span> <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>You can also specify the base to use as the second argument. So the following two snippets <i>always</i> return the same lists:</p>

<pre><code><code>    <span class="variable">@list</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Items</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
    <span class="variable">@list</span> <span class="operator">=</span> <span class="variable">@seq1</span><span class="operator">[</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Range</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span><span class="number">0</span><span class="operator">)</span> <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p><code><code>Base</code></code></p>

<pre><code><code>    <span class="variable">$curBase</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Base</span><span class="operator">();</span>
    <span class="variable">$oldBase</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Base</span><span class="operator">(</span><span class="variable">$newBase</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>Base</code></code> sets and/or returns the current base (usually 0 or 1) that is used when you request range information. The base defaults to 0 so that range information is returned as array indices. You can set the base to 1 if you want to report traditional line numbers instead.</p>

<p><code><code>Min</code></code></p>

<pre><code><code>    <span class="variable">$min1</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Min</span><span class="operator">(</span><span class="number">1</span><span class="operator">);</span>
    <span class="variable">$min</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Min</span><span class="operator">(</span> <span class="variable">$seqNum</span><span class="operator">,</span> <span class="variable">$base</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>Min</code></code> returns the first value that <code><code>Range</code></code> would return (given the same arguments) or returns <code><code>undef</code></code> if <code><code>Range</code></code> would return an empty list.</p>

<p><code><code>Max</code></code></p>

<p><code><code>Max</code></code> returns the last value that <code><code>Range</code></code> would return or <code><code>undef</code></code>.</p>

<p><code><code>Get</code></code></p>

<pre><code><code>    <span class="operator">(</span> <span class="variable">$n</span><span class="operator">,</span> <span class="variable">$x</span><span class="operator">,</span> <span class="variable">$r</span> <span class="operator">)</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span><span class="string">qw( min1 max1 range1 )</span><span class="operator">);</span>
    <span class="variable">@values</span> <span class="operator">=</span> <span class="variable">$diff</span><span class="operator">-&gt;</span><span class="variable">Get</span><span class="operator">(</span><span class="string">qw( 0min2 1max2 range2 same base )</span><span class="operator">);</span>
</code></code></pre>

<p><code><code>Get</code></code> returns one or more scalar values. You pass in a list of the names of the values you want returned. Each name must match one of the following regexes:</p>

<pre><code><code>    /^(-?\d+)?(min|max)[12]$/i
    /^(range[12]|same|diff|base)$/i</code></code></pre>

<p>The 1 or 2 after a name says which sequence you want the information for (and where allowed, it is required). The optional number before &quot;min&quot; or &quot;max&quot; is the base to use. So the following equalities hold:</p>

<pre><code><code>    $diff-&gt;Get(&#39;min1&#39;) == $diff-&gt;Min(1)
    $diff-&gt;Get(&#39;0min2&#39;) == $diff-&gt;Min(2,0)</code></code></pre>

<p>Using <code><code>Get</code></code> in a scalar context when you&#39;ve passed in more than one name is a fatal error (<code><code>die</code></code> is called).</p>

</ul>

<h2 id="4"><code><code>prepare</code></code></h2>

<p>Given a reference to a list of items, <code><code>prepare</code></code> returns a reference to a hash which can be used when comparing this sequence to other sequences with <code><code>LCS</code></code> or <code><code>LCS_length</code></code>.</p>

<pre><code><code>    <span class="variable">$prep</span> <span class="operator">=</span> <span class="variable">prepare</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span> <span class="operator">);</span>
    <span class="keyword">for</span> <span class="variable">$i</span> <span class="operator">(</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">10_000</span> <span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">@lcs</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="variable">$prep</span><span class="operator">,</span> <span class="variable">$seq</span><span class="operator">[</span><span class="variable">$i</span><span class="operator">]</span> <span class="operator">);</span>
        <span class="comment"># do something useful with @lcs</span>
    <span class="operator">}</span>
</code></code></pre>

<p><code><code>prepare</code></code> may be passed an optional third parameter; this is a CODE reference to a key generation function. See <a href="#KEY-GENERATION-FUNCTIONS">&quot;KEY GENERATION FUNCTIONS&quot;</a>.</p>

<pre><code><code>    <span class="variable">$prep</span> <span class="operator">=</span> <span class="variable">prepare</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">keyGen</span> <span class="operator">);</span>
    <span class="keyword">for</span> <span class="variable">$i</span> <span class="operator">(</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">10_000</span> <span class="operator">)</span>
    <span class="operator">{</span>
        <span class="variable">@lcs</span> <span class="operator">=</span> <span class="variable">LCS</span><span class="operator">(</span> <span class="variable">$seq</span><span class="operator">[</span><span class="variable">$i</span><span class="operator">]</span><span class="operator">,</span> <span class="variable">$prep</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">keyGen</span> <span class="operator">);</span>
        <span class="comment"># do something useful with @lcs</span>
    <span class="operator">}</span>
</code></code></pre>

<p>Using <code><code>prepare</code></code> provides a performance gain of about 50% when calling LCS many times compared with not preparing.</p>

<h2 id="5"><code><code>diff</code></code></h2>

<pre><code><code>    <span class="variable">@diffs</span>     <span class="operator">=</span> <span class="variable">diff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$diffs_ref</span> <span class="operator">=</span> <span class="variable">diff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>diff</code></code> computes the smallest set of additions and deletions necessary to turn the first sequence into the second, and returns a description of these changes. The description is a list of <i>hunks</i>; each hunk represents a contiguous section of items which should be added, deleted, or replaced. (Hunks containing unchanged items are not included.)</p>

<p>The return value of <code><code>diff</code></code> is a list of hunks, or, in scalar context, a reference to such a list. If there are no differences, the list will be empty.</p>

<p>Here is an example. Calling <code><code>diff</code></code> for the following two sequences:</p>

<pre><code><code>    a b c e h j l m n p
    b c d e f j k l m r s t</code></code></pre>

<p>would produce the following list:</p>

<pre><code><code>    (
      [ [ &#39;-&#39;, 0, &#39;a&#39; ] ],

      [ [ &#39;+&#39;, 2, &#39;d&#39; ] ],

      [ [ &#39;-&#39;, 4, &#39;h&#39; ],
        [ &#39;+&#39;, 4, &#39;f&#39; ] ],

      [ [ &#39;+&#39;, 6, &#39;k&#39; ] ],

      [ [ &#39;-&#39;,  8, &#39;n&#39; ],
        [ &#39;-&#39;,  9, &#39;p&#39; ],
        [ &#39;+&#39;,  9, &#39;r&#39; ],
        [ &#39;+&#39;, 10, &#39;s&#39; ],
        [ &#39;+&#39;, 11, &#39;t&#39; ] ],
    )</code></code></pre>

<p>There are five hunks here. The first hunk says that the <code><code>a</code></code> at position 0 of the first sequence should be deleted (<code><code>-</code></code>). The second hunk says that the <code><code>d</code></code> at position 2 of the second sequence should be inserted (<code><code>+</code></code>). The third hunk says that the <code><code>h</code></code> at position 4 of the first sequence should be removed and replaced with the <code><code>f</code></code> from position 4 of the second sequence. And so on.</p>

<p><code><code>diff</code></code> may be passed an optional third parameter; this is a CODE reference to a key generation function. See <a href="#KEY-GENERATION-FUNCTIONS">&quot;KEY GENERATION FUNCTIONS&quot;</a>.</p>

<p>Additional parameters, if any, will be passed to the key generation routine.</p>

<h2 id="6"><code><code>sdiff</code></code></h2>

<pre><code><code>    <span class="variable">@sdiffs</span>     <span class="operator">=</span> <span class="variable">sdiff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
    <span class="variable">$sdiffs_ref</span> <span class="operator">=</span> <span class="variable">sdiff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span> <span class="operator">);</span>
</code></code></pre>

<p><code><code>sdiff</code></code> computes all necessary components to show two sequences and their minimized differences side by side, just like the Unix-utility <i>sdiff</i> does:</p>

<pre><code><code>    same             same
    before     |     after
    old        &lt;     -
    -          &gt;     new</code></code></pre>

<p>It returns a list of array refs, each pointing to an array of display instructions. In scalar context it returns a reference to such a list. If there are no differences, the list will have one entry per item, each indicating that the item was unchanged.</p>

<p>Display instructions consist of three elements: A modifier indicator (<code><code>+</code></code>: Element added, <code><code>-</code></code>: Element removed, <code><code>u</code></code>: Element unmodified, <code><code>c</code></code>: Element changed) and the value of the old and new elements, to be displayed side-by-side.</p>

<p>An <code><code>sdiff</code></code> of the following two sequences:</p>

<pre><code><code>    a b c e h j l m n p
    b c d e f j k l m r s t</code></code></pre>

<p>results in</p>

<pre><code><code>    ( [ &#39;-&#39;, &#39;a&#39;, &#39;&#39;  ],
      [ &#39;u&#39;, &#39;b&#39;, &#39;b&#39; ],
      [ &#39;u&#39;, &#39;c&#39;, &#39;c&#39; ],
      [ &#39;+&#39;, &#39;&#39;,  &#39;d&#39; ],
      [ &#39;u&#39;, &#39;e&#39;, &#39;e&#39; ],
      [ &#39;c&#39;, &#39;h&#39;, &#39;f&#39; ],
      [ &#39;u&#39;, &#39;j&#39;, &#39;j&#39; ],
      [ &#39;+&#39;, &#39;&#39;,  &#39;k&#39; ],
      [ &#39;u&#39;, &#39;l&#39;, &#39;l&#39; ],
      [ &#39;u&#39;, &#39;m&#39;, &#39;m&#39; ],
      [ &#39;c&#39;, &#39;n&#39;, &#39;r&#39; ],
      [ &#39;c&#39;, &#39;p&#39;, &#39;s&#39; ],
      [ &#39;+&#39;, &#39;&#39;,  &#39;t&#39; ],
    )</code></code></pre>

<p><code><code>sdiff</code></code> may be passed an optional third parameter; this is a CODE reference to a key generation function. See <a href="#KEY-GENERATION-FUNCTIONS">&quot;KEY GENERATION FUNCTIONS&quot;</a>.</p>

<p>Additional parameters, if any, will be passed to the key generation routine.</p>

<h2 id="7"><code><code>compact_diff</code></code></h2>

<p><code><code>compact_diff</code></code> is much like <code><code>sdiff</code></code> except it returns a much more compact description consisting of just one flat list of indices. An example helps explain the format:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">@a</span> <span class="operator">=</span> <span class="string">qw( a b c   e  h j   l m n p      )</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">@b</span> <span class="operator">=</span> <span class="string">qw(   b c d e f  j k l m    r s t )</span><span class="operator">;</span>
    <span class="variable">@cdiff</span> <span class="operator">=</span> <span class="variable">compact_diff</span><span class="operator">(</span> <span class="operator">\</span><span class="variable">@a</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@b</span> <span class="operator">);</span>
    <span class="comment"># Returns:</span>
    <span class="comment">#   @a      @b       @a       @b</span>
    <span class="comment">#  start   start   values   values</span>
    <span class="operator">(</span>    <span class="number">0</span><span class="operator">,</span>      <span class="number">0</span><span class="operator">,</span>   <span class="comment">#       =</span>
         <span class="number">0</span><span class="operator">,</span>      <span class="number">0</span><span class="operator">,</span>   <span class="comment">#    a  !</span>
         <span class="number">1</span><span class="operator">,</span>      <span class="number">0</span><span class="operator">,</span>   <span class="comment">#  b c  =  b c</span>
         <span class="number">3</span><span class="operator">,</span>      <span class="number">2</span><span class="operator">,</span>   <span class="comment">#       !  d</span>
         <span class="number">3</span><span class="operator">,</span>      <span class="number">3</span><span class="operator">,</span>   <span class="comment">#    e  =  e</span>
         <span class="number">4</span><span class="operator">,</span>      <span class="number">4</span><span class="operator">,</span>   <span class="comment">#    f  !  h</span>
         <span class="number">5</span><span class="operator">,</span>      <span class="number">5</span><span class="operator">,</span>   <span class="comment">#    j  =  j</span>
         <span class="number">6</span><span class="operator">,</span>      <span class="number">6</span><span class="operator">,</span>   <span class="comment">#       !  k</span>
         <span class="number">6</span><span class="operator">,</span>      <span class="number">7</span><span class="operator">,</span>   <span class="comment">#  l m  =  l m</span>
         <span class="number">8</span><span class="operator">,</span>      <span class="number">9</span><span class="operator">,</span>   <span class="comment">#  n p  !  r s t</span>
        <span class="number">10</span><span class="operator">,</span>     <span class="number">12</span><span class="operator">,</span>   <span class="comment">#</span>
    <span class="operator">);</span>
</code></code></pre>

<p>The 0th, 2nd, 4th, etc. entries are all indices into @seq1 (@a in the above example) indicating where a hunk begins. The 1st, 3rd, 5th, etc. entries are all indices into @seq2 (@b in the above example) indicating where the same hunk begins.</p>

<p>So each pair of indices (except the last pair) describes where a hunk begins (in each sequence). Since each hunk must end at the item just before the item that starts the next hunk, the next pair of indices can be used to determine where the hunk ends.</p>

<p>So, the first 4 entries (0..3) describe the first hunk. Entries 0 and 1 describe where the first hunk begins (and so are always both 0). Entries 2 and 3 describe where the next hunk begins, so subtracting 1 from each tells us where the first hunk ends. That is, the first hunk contains items <code><code>$diff[0]</code></code> through <code><code>$diff[2] - 1</code></code> of the first sequence and contains items <code><code>$diff[1]</code></code> through <code><code>$diff[3] - 1</code></code> of the second sequence.</p>

<p>In other words, the first hunk consists of the following two lists of items:</p>

<pre><code><code>               <span class="comment">#  1st pair     2nd pair</span>
               <span class="comment"># of indices   of indices</span>
                   <span class="variable">@list1</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">0</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
                   <span class="variable">@list2</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">1</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">3</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
               <span class="comment"># Hunk start   Hunk end</span>
</code></code></pre>

<p>Note that the hunks will always alternate between those that are part of the LCS (those that contain unchanged items) and those that contain changes. This means that all we need to be told is whether the first hunk is a &#39;same&#39; or &#39;diff&#39; hunk and we can determine which of the other hunks contain &#39;same&#39; items or &#39;diff&#39; items.</p>

<p>By convention, we always make the first hunk contain unchanged items. So the 1st, 3rd, 5th, etc. hunks (all odd-numbered hunks if you start counting from 1) all contain unchanged items. And the 2nd, 4th, 6th, etc. hunks (all even-numbered hunks if you start counting from 1) all contain changed items.</p>

<p>Since @a and @b don&#39;t begin with the same value, the first hunk in our example is empty (otherwise we&#39;d violate the above convention). Note that the first 4 index values in our example are all zero. Plug these values into our previous code block and we get:</p>

<pre><code><code>    <span class="variable">@hunk1a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">0</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="variable">@hunk1b</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">0</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
</code></code></pre>

<p>And <code><code>0..-1</code></code> returns the empty list.</p>

<p>Move down one pair of indices (2..5) and we get the offset ranges for the second hunk, which contains changed items.</p>

<p>Since <code><code>@diff[2..5]</code></code> contains (0,0,1,0) in our example, the second hunk consists of these two lists of items:</p>

<pre><code><code>        <span class="variable">@hunk2a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">2</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">4</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk2b</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">3</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">5</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk2a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">1</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk2b</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">0</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk2a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">0</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk2b</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk2a</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">'a'</span> <span class="operator">);</span>
        <span class="variable">@hunk2b</span> <span class="operator">=</span> <span class="operator">(</span> <span class="operator">);</span>
</code></code></pre>

<p>That is, we would delete item 0 (&#39;a&#39;) from @a.</p>

<p>Since <code><code>@diff[4..7]</code></code> contains (1,0,3,2) in our example, the third hunk consists of these two lists of items:</p>

<pre><code><code>        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">4</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">6</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">5</span><span class="operator">]</span> <span class="operator">..</span> <span class="variable">$cdiff</span><span class="operator">[</span><span class="number">7</span><span class="operator">]</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">3</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">2</span><span class="operator">-</span><span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@a</span><span class="operator">[</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">2</span> <span class="operator">]</span><span class="operator">;</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="variable">@b</span><span class="operator">[</span> <span class="number">0</span> <span class="operator">..</span> <span class="number">1</span> <span class="operator">]</span><span class="operator">;</span>
            <span class="comment"># or</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="string">qw( b c )</span><span class="operator">;</span>
        <span class="variable">@hunk3a</span> <span class="operator">=</span> <span class="string">qw( b c )</span><span class="operator">;</span>
</code></code></pre>

<p>Note that this third hunk contains unchanged items as our convention demands.</p>

<p>You can continue this process until you reach the last two indices, which will always be the number of items in each sequence. This is required so that subtracting one from each will give you the indices to the last items in each sequence.</p>

<h2 id="8"><code><code>traverse_sequences</code></code></h2>

<p><code><code>traverse_sequences</code></code> used to be the most general facility provided by this module (the new OO interface is more powerful and much easier to use).</p>

<p>Imagine that there are two arrows. Arrow A points to an element of sequence A, and arrow B points to an element of the sequence B. Initially, the arrows point to the first elements of the respective sequences. <code><code>traverse_sequences</code></code> will advance the arrows through the sequences one element at a time, calling an appropriate user-specified callback function before each advance. It willadvance the arrows in such a way that if there are equal elements <code><code>$A[$i]</code></code> and <code><code>$B[$j]</code></code> which are equal and which are part of the LCS, there will be some moment during the execution of <code><code>traverse_sequences</code></code> when arrow A is pointing to <code><code>$A[$i]</code></code> and arrow B is pointing to <code><code>$B[$j]</code></code>. When this happens, <code><code>traverse_sequences</code></code> will call the <code><code>MATCH</code></code> callback function and then it will advance both arrows.</p>

<p>Otherwise, one of the arrows is pointing to an element of its sequence that is not part of the LCS. <code><code>traverse_sequences</code></code> will advance that arrow and will call the <code><code>DISCARD_A</code></code> or the <code><code>DISCARD_B</code></code> callback, depending on which arrow it advanced. If both arrows point to elements that are not part of the LCS, then <code><code>traverse_sequences</code></code> will advance one of them and call the appropriate callback, but it is not specified which it will call.</p>

<p>The arguments to <code><code>traverse_sequences</code></code> are the two sequences to traverse, and a hash which specifies the callback functions, like this:</p>

<pre><code><code>    <span class="variable">traverse_sequences</span><span class="operator">(</span>
        <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span>
        <span class="operator">{</span>   <span class="string">MATCH</span> <span class="operator">=&gt;</span> <span class="variable">$callback_1</span><span class="operator">,</span>
            <span class="string">DISCARD_A</span> <span class="operator">=&gt;</span> <span class="variable">$callback_2</span><span class="operator">,</span>
            <span class="string">DISCARD_B</span> <span class="operator">=&gt;</span> <span class="variable">$callback_3</span><span class="operator">,</span>
        <span class="operator">}</span>
    <span class="operator">);</span>
</code></code></pre>

<p>Callbacks for MATCH, DISCARD_A, and DISCARD_B are invoked with at least the indices of the two arrows as their arguments. They are not expected to return any values. If a callback is omitted from the table, it is not called.</p>

<p>Callbacks for A_FINISHED and B_FINISHED are invoked with at least the corresponding index in A or B.</p>

<p>If arrow A reaches the end of its sequence, before arrow B does, <code><code>traverse_sequences</code></code> will call the <code><code>A_FINISHED</code></code> callback when it advances arrow B, if there is such a function; if not it will call <code><code>DISCARD_B</code></code> instead. Similarly if arrow B finishes first. <code><code>traverse_sequences</code></code> returns when both arrows are at the ends of their respective sequences. It returns true on success and false on failure. At present there is no way to fail.</p>

<p><code><code>traverse_sequences</code></code> may be passed an optional fourth parameter; this is a CODE reference to a key generation function. See <a href="#KEY-GENERATION-FUNCTIONS">&quot;KEY GENERATION FUNCTIONS&quot;</a>.</p>

<p>Additional parameters, if any, will be passed to the key generation function.</p>

<p>If you want to pass additional parameters to your callbacks, but don&#39;t need a custom key generation function, you can get the default by passing undef:</p>

<pre><code><code>    <span class="variable">traverse_sequences</span><span class="operator">(</span>
        <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span>
        <span class="operator">{</span>   <span class="string">MATCH</span> <span class="operator">=&gt;</span> <span class="variable">$callback_1</span><span class="operator">,</span>
            <span class="string">DISCARD_A</span> <span class="operator">=&gt;</span> <span class="variable">$callback_2</span><span class="operator">,</span>
            <span class="string">DISCARD_B</span> <span class="operator">=&gt;</span> <span class="variable">$callback_3</span><span class="operator">,</span>
        <span class="operator">}</span><span class="operator">,</span>
        <span class="keyword">undef</span><span class="operator">,</span>     <span class="comment"># default key-gen</span>
        <span class="variable">$myArgument1</span><span class="operator">,</span>
        <span class="variable">$myArgument2</span><span class="operator">,</span>
        <span class="variable">$myArgument3</span><span class="operator">,</span>
    <span class="operator">);</span>
</code></code></pre>

<p><code><code>traverse_sequences</code></code> does not have a useful return value; you are expected to plug in the appropriate behavior with the callback functions.</p>

<h2 id="9"><code><code>traverse_balanced</code></code></h2>

<p><code><code>traverse_balanced</code></code> is an alternative to <code><code>traverse_sequences</code></code>. It uses a different algorithm to iterate through the entries in the computed LCS. Instead of sticking to one side and showing element changes as insertions and deletions only, it will jump back and forth between the two sequences and report <i>changes</i> occurring as deletions on one side followed immediatly by an insertion on the other side.</p>

<p>In addition to the <code><code>DISCARD_A</code></code>, <code><code>DISCARD_B</code></code>, and <code><code>MATCH</code></code> callbacks supported by <code><code>traverse_sequences</code></code>, <code><code>traverse_balanced</code></code> supports a <code><code>CHANGE</code></code> callback indicating that one element got <code><code>replaced</code></code> by another:</p>

<pre><code><code>    <span class="variable">traverse_balanced</span><span class="operator">(</span>
        <span class="operator">\</span><span class="variable">@seq1</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">@seq2</span><span class="operator">,</span>
        <span class="operator">{</span>   <span class="string">MATCH</span> <span class="operator">=&gt;</span> <span class="variable">$callback_1</span><span class="operator">,</span>
            <span class="string">DISCARD_A</span> <span class="operator">=&gt;</span> <span class="variable">$callback_2</span><span class="operator">,</span>
            <span class="string">DISCARD_B</span> <span class="operator">=&gt;</span> <span class="variable">$callback_3</span><span class="operator">,</span>
            <span class="string">CHANGE</span>    <span class="operator">=&gt;</span> <span class="variable">$callback_4</span><span class="operator">,</span>
        <span class="operator">}</span>
    <span class="operator">);</span>
</code></code></pre>

<p>If no <code><code>CHANGE</code></code> callback is specified, <code><code>traverse_balanced</code></code> will map <code><code>CHANGE</code></code> events to <code><code>DISCARD_A</code></code> and <code><code>DISCARD_B</code></code> actions, therefore resulting in a similar behaviour as <code><code>traverse_sequences</code></code> with different order of events.</p>

<p><code><code>traverse_balanced</code></code> might be a bit slower than <code><code>traverse_sequences</code></code>, noticable only while processing huge amounts of data.</p>

<p>The <code><code>sdiff</code></code> function of this module is implemented as call to <code><code>traverse_balanced</code></code>.</p>

<p><code><code>traverse_balanced</code></code> does not have a useful return value; you are expected to plug in the appropriate behavior with the callback functions.</p>

<h1 id="KEY-GENERATION-FUNCTIONS">KEY GENERATION FUNCTIONS</h1>

<p>Most of the functions accept an optional extra parameter. This is a CODE reference to a key generating (hashing) function that should return a string that uniquely identifies a given element. It should be the case that if two elements are to be considered equal, their keys should be the same (and the other way around). If no key generation function is provided, the key will be the element as a string.</p>

<p>By default, comparisons will use &quot;eq&quot; and elements will be turned into keys using the default stringizing operator &#39;&quot;&quot;&#39;.</p>

<p>Where this is important is when you&#39;re comparing something other than strings. If it is the case that you have multiple different objects that should be considered to be equal, you should supply a key generation function. Otherwise, you have to make sure that your arrays contain unique references.</p>

<p>For instance, consider this example:</p>

<pre><code><code>    <span class="keyword">package</span> <span class="variable">Person</span><span class="operator">;</span>
    
    <span class="keyword">sub</span><span class="variable"> new
    </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$package</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">return</span> <span class="keyword">bless</span> <span class="operator">{</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">''</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">''</span><span class="operator">,</span> <span class="variable">@_</span> <span class="operator">}</span><span class="operator">,</span> <span class="variable">$package</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> clone
    </span><span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$old</span> <span class="operator">=</span> <span class="keyword">shift</span><span class="operator">;</span>
        <span class="keyword">my</span> <span class="variable">$new</span> <span class="operator">=</span> <span class="keyword">bless</span> <span class="operator">{</span> <span class="variable">%$old</span> <span class="operator">}</span><span class="operator">,</span> <span class="keyword">ref</span><span class="operator">(</span><span class="variable">$old</span><span class="operator">);</span>
    <span class="operator">}</span>
    
    <span class="keyword">sub</span><span class="variable"> hash
    </span><span class="operator">{</span>
        <span class="keyword">return</span> <span class="keyword">shift</span><span class="operator">()-&gt;</span><span class="operator">{</span><span class="string">'ssn'</span><span class="operator">}</span><span class="operator">;</span>
    <span class="operator">}</span>
    
    <span class="keyword">my</span> <span class="variable">$person1</span> <span class="operator">=</span> <span class="variable">Person</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Joe'</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">'123-45-6789'</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$person2</span> <span class="operator">=</span> <span class="variable">Person</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Mary'</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">'123-47-0000'</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$person3</span> <span class="operator">=</span> <span class="variable">Person</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Pete'</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">'999-45-2222'</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$person4</span> <span class="operator">=</span> <span class="variable">Person</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Peggy'</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">'123-45-9999'</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$person5</span> <span class="operator">=</span> <span class="variable">Person</span><span class="operator">-&gt;</span><span class="variable">new</span><span class="operator">(</span> <span class="string">name</span> <span class="operator">=&gt;</span> <span class="string">'Frank'</span><span class="operator">,</span> <span class="string">ssn</span> <span class="operator">=&gt;</span> <span class="string">'000-45-9999'</span> <span class="operator">);</span>
</code></code></pre>

<p>If you did this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$array1</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person2</span><span class="operator">,</span> <span class="variable">$person4</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$array2</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person3</span><span class="operator">,</span> <span class="variable">$person4</span><span class="operator">,</span> <span class="variable">$person5</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="variable">Algorithm::Diff::diff</span><span class="operator">(</span> <span class="variable">$array1</span><span class="operator">,</span> <span class="variable">$array2</span> <span class="operator">);</span>
</code></code></pre>

<p>everything would work out OK (each of the objects would be converted into a string like &quot;Person=HASH(0x82425b0)&quot; for comparison).</p>

<p>But if you did this:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$array1</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person2</span><span class="operator">,</span> <span class="variable">$person4</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$array2</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person3</span><span class="operator">,</span> <span class="variable">$person4</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">(),</span> <span class="variable">$person5</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="variable">Algorithm::Diff::diff</span><span class="operator">(</span> <span class="variable">$array1</span><span class="operator">,</span> <span class="variable">$array2</span> <span class="operator">);</span>
</code></code></pre>

<p>$person4 and $person4-&gt;clone() (which have the same name and SSN) would be seen as different objects. If you wanted them to be considered equivalent, you would have to pass in a key generation function:</p>

<pre><code><code>    <span class="keyword">my</span> <span class="variable">$array1</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person2</span><span class="operator">,</span> <span class="variable">$person4</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$array2</span> <span class="operator">=</span> <span class="operator">[</span> <span class="variable">$person1</span><span class="operator">,</span> <span class="variable">$person3</span><span class="operator">,</span> <span class="variable">$person4</span><span class="operator">-&gt;</span><span class="variable">clone</span><span class="operator">(),</span> <span class="variable">$person5</span> <span class="operator">]</span><span class="operator">;</span>
    <span class="variable">Algorithm::Diff::diff</span><span class="operator">(</span> <span class="variable">$array1</span><span class="operator">,</span> <span class="variable">$array2</span><span class="operator">,</span> <span class="operator">\&amp;</span><span class="variable">Person::hash</span> <span class="operator">);</span>
</code></code></pre>

<p>This would use the &#39;ssn&#39; field in each Person as a comparison key, and so would consider $person4 and $person4-&gt;clone() as equal.</p>

<p>You may also pass additional parameters to the key generation function if you wish.</p>

<h1 id="ERROR-CHECKING">ERROR CHECKING</h1>

<p>If you pass these routines a non-reference and they expect a reference, they will die with a message.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>This version released by Tye McQueen (http://perlmonks.org/?node=tye).</p>

<h1 id="LICENSE">LICENSE</h1>

<p>Parts Copyright (c) 2000-2004 Ned Konz. All rights reserved. Parts by Tye McQueen.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl.</p>

<h1 id="MAILING-LIST">MAILING LIST</h1>

<p>Mark-Jason still maintains a mailing list. To join a low-volume mailing list for announcements related to diff and Algorithm::Diff, send an empty mail message to mjd-perl-diff-request@plover.com.</p>

<h1 id="CREDITS">CREDITS</h1>

<p>Versions through 0.59 (and much of this documentation) were written by:</p>

<p>Mark-Jason Dominus, mjd-perl-diff@plover.com</p>

<p>This version borrows some documentation and routine names from Mark-Jason&#39;s, but Diff.pm&#39;s code was completely replaced.</p>

<p>This code was adapted from the Smalltalk code of Mario Wolczko &lt;mario@wolczko.com&gt;, which is available at ftp://st.cs.uiuc.edu/pub/Smalltalk/MANCHESTER/manchester/4.0/diff.st</p>

<p><code><code>sdiff</code></code> and <code><code>traverse_balanced</code></code> were written by Mike Schilli &lt;m@perlmeister.com&gt;.</p>

<p>The algorithm is that described in <i>A Fast Algorithm for Computing Longest Common Subsequences</i>, CACM, vol.20, no.5, pp.350-353, May 1977, with a few minor improvements to improve the speed.</p>

<p>Much work was done by Ned Konz (perl@bike-nomad.com).</p>

<p>The OO interface and some other changes are by Tye McQueen.</p>

<h1 id="POD-ERRORS">POD ERRORS</h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>

<dt id="Around-line-989:">Around line 989:</dt>
<dd>

<p>You can&#39;t have =items (as at line 1021) unless the first thing after the =over is an =item</p>

</dd>
</dl>


</body>

</html>


