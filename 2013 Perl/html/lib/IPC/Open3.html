<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../scineplex.css">
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#See-Also">See Also</a></li>
  <li><a href="#WARNING">WARNING</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>IPC::Open3 - open a process for reading, writing, and error handling using open3()</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code><code>    <span class="variable">$pid</span> <span class="operator">=</span> <span class="variable">open3</span><span class="operator">(\</span><span class="variable">*CHLD_IN</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">*CHLD_OUT</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">*CHLD_ERR</span><span class="operator">,</span>
                    <span class="string">'some cmd and args'</span><span class="operator">,</span> <span class="string">'optarg'</span><span class="operator">,</span> <span class="operator">...);</span>
    
    <span class="keyword">my</span><span class="operator">(</span><span class="variable">$wtr</span><span class="operator">,</span> <span class="variable">$rdr</span><span class="operator">,</span> <span class="variable">$err</span><span class="operator">);</span>
    <span class="keyword">use</span> <span class="variable">Symbol</span> <span class="string">'gensym'</span><span class="operator">;</span> <span class="variable">$err</span> <span class="operator">=</span> <span class="variable">gensym</span><span class="operator">;</span>
    <span class="variable">$pid</span> <span class="operator">=</span> <span class="variable">open3</span><span class="operator">(</span><span class="variable">$wtr</span><span class="operator">,</span> <span class="variable">$rdr</span><span class="operator">,</span> <span class="variable">$err</span><span class="operator">,</span>
                    <span class="string">'some cmd and args'</span><span class="operator">,</span> <span class="string">'optarg'</span><span class="operator">,</span> <span class="operator">...);</span>
    
    <span class="keyword">waitpid</span><span class="operator">(</span> <span class="variable">$pid</span><span class="operator">,</span> <span class="number">0</span> <span class="operator">);</span>
    <span class="keyword">my</span> <span class="variable">$child_exit_status</span> <span class="operator">=</span> <span class="variable">$?</span> <span class="operator">&gt;&gt;</span> <span class="number">8</span><span class="operator">;</span>
</code></code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Extremely similar to open2(), open3() spawns the given $cmd and connects CHLD_OUT for reading from the child, CHLD_IN for writing to the child, and CHLD_ERR for errors. If CHLD_ERR is false, or the same file descriptor as CHLD_OUT, then STDOUT and STDERR of the child are on the same filehandle (this means that an autovivified lexical cannot be used for the STDERR filehandle, see SYNOPSIS). The CHLD_IN will have autoflush turned on.</p>

<p>If CHLD_IN begins with <code><code>&lt;&amp;</code></code>, then CHLD_IN will be closed in the parent, and the child will read from it directly. If CHLD_OUT or CHLD_ERR begins with <code><code>&gt;&amp;</code></code>, then the child will send output directly to that filehandle. In both cases, there will be a dup(2) instead of a pipe(2) made.</p>

<p>If either reader or writer is the null string, this will be replaced by an autogenerated filehandle. If so, you must pass a valid lvalue in the parameter slot so it can be overwritten in the caller, or an exception will be raised.</p>

<p>The filehandles may also be integers, in which case they are understood as file descriptors.</p>

<p>open3() returns the process ID of the child process. It doesn&#39;t return on failure: it just raises an exception matching <code><code>/^open3:/</code></code>. However, <code><code>exec</code></code> failures in the child (such as no such file or permission denied), are just reported to CHLD_ERR, as it is not possible to trap them.</p>

<p>If the child process dies for any reason, the next write to CHLD_IN is likely to generate a SIGPIPE in the parent, which is fatal by default. So you may wish to handle this signal.</p>

<p>Note if you specify <code><code>-</code></code> as the command, in an analogous fashion to <code><code>open(FOO, &quot;-|&quot;)</code></code> the child process will just be the forked Perl process rather than an external command. This feature isn&#39;t yet supported on Win32 platforms.</p>

<p>open3() does not wait for and reap the child process after it exits. Except for short programs where it&#39;s acceptable to let the operating system take care of this, you need to do this yourself. This is normally as simple as calling <code><code>waitpid $pid, 0</code></code> when you&#39;re done with the process. Failing to do this can result in an accumulation of defunct or &quot;zombie&quot; processes. See <a href="../../lib/pods/perlfunc.html#waitpid">&quot;waitpid&quot; in perlfunc</a> for more information.</p>

<p>If you try to read from the child&#39;s stdout writer and their stderr writer, you&#39;ll have problems with blocking, which means you&#39;ll want to use select() or the IO::Select, which means you&#39;d best use sysread() instead of readline() for normal stuff.</p>

<p>This is very dangerous, as you may block forever. It assumes it&#39;s going to talk to something like <b>bc</b>, both writing to it and reading from it. This is presumably safe because you &quot;know&quot; that commands like <b>bc</b> will read a line at a time and output a line at a time. Programs like <b>sort</b> that read their entire input stream first, however, are quite apt to cause deadlock.</p>

<p>The big problem with this approach is that if you don&#39;t have control over source code being run in the child process, you can&#39;t control what it does with pipe buffering. Thus you can&#39;t just open a pipe to <code><code>cat -v</code></code> and continually read and write a line from it.</p>

<h1 id="See-Also">See Also</h1>

<dl>

<dt id="IPC::Open2"><a href="../../lib/IPC/Open2.html">IPC::Open2</a></dt>
<dd>

<p>Like Open3 but without STDERR catpure.</p>

</dd>
<dt id="IPC::Run"><a>IPC::Run</a></dt>
<dd>

<p>This is a CPAN module that has better error handling and more facilities than Open3.</p>

</dd>
</dl>

<h1 id="WARNING">WARNING</h1>

<p>The order of arguments differs from that of open2().</p>


</body>

</html>


